(function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var alertify = createCommonjsModule(function (module) {
    /**
     * alertifyjs 1.11.1 http://alertifyjs.com
     * AlertifyJS is a javascript framework for developing pretty browser dialogs and notifications.
     * Copyright 2018 Mohammad Younes <Mohammad@alertifyjs.com> (http://alertifyjs.com) 
     * Licensed under GPL 3 <https://opensource.org/licenses/gpl-3.0>*/
    ( function ( window ) {
        
        /**
         * Keys enum
         * @type {Object}
         */
        var keys = {
            ENTER: 13,
            ESC: 27,
            F1: 112,
            F12: 123,
            LEFT: 37,
            RIGHT: 39
        };
        /**
         * Default options 
         * @type {Object}
         */
        var defaults = {
            autoReset:true,
            basic:false,
            closable:true,
            closableByDimmer:true,
            frameless:false,
            maintainFocus:true, //global default not per instance, applies to all dialogs
            maximizable:true,
            modal:true,
            movable:true,
            moveBounded:false,
            overflow:true,
            padding: true,
            pinnable:true,
            pinned:true,
            preventBodyShift:false, //global default not per instance, applies to all dialogs
            resizable:true,
            startMaximized:false,
            transition:'pulse',
            notifier:{
                delay:5,
                position:'bottom-right',
                closeButton:false
            },
            glossary:{
                title:'AlertifyJS',
                ok: 'OK',
                cancel: 'Cancel',
                acccpt: 'Accept',
                deny: 'Deny',
                confirm: 'Confirm',
                decline: 'Decline',
                close: 'Close',
                maximize: 'Maximize',
                restore: 'Restore',
            },
            theme:{
                input:'ajs-input',
                ok:'ajs-ok',
                cancel:'ajs-cancel',
            }
        };
        
        //holds open dialogs instances
        var openDialogs = [];

        /**
         * [Helper]  Adds the specified class(es) to the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be added to the class attribute of the element.
         * 
         * @return {undefined}
         */
        function addClass(element,classNames){
            element.className += ' ' + classNames;
        }
        
        /**
         * [Helper]  Removes the specified class(es) from the element.
         *
         * @element {node}      The element
         * @className {string}  One or more space-separated classes to be removed from the class attribute of the element.
         * 
         * @return {undefined}
         */
        function removeClass(element, classNames) {
            var original = element.className.split(' ');
            var toBeRemoved = classNames.split(' ');
            for (var x = 0; x < toBeRemoved.length; x += 1) {
                var index = original.indexOf(toBeRemoved[x]);
                if (index > -1){
                    original.splice(index,1);
                }
            }
            element.className = original.join(' ');
        }

        /**
         * [Helper]  Checks if the document is RTL
         *
         * @return {Boolean} True if the document is RTL, false otherwise.
         */
        function isRightToLeft(){
            return window.getComputedStyle(document.body).direction === 'rtl';
        }
        /**
         * [Helper]  Get the document current scrollTop
         *
         * @return {Number} current document scrollTop value
         */
        function getScrollTop(){
            return ((document.documentElement && document.documentElement.scrollTop) || document.body.scrollTop);
        }

        /**
         * [Helper]  Get the document current scrollLeft
         *
         * @return {Number} current document scrollLeft value
         */
        function getScrollLeft(){
            return ((document.documentElement && document.documentElement.scrollLeft) || document.body.scrollLeft);
        }

        /**
        * Helper: clear contents
        *
        */
        function clearContents(element){
            while (element.lastChild) {
                element.removeChild(element.lastChild);
            }
        }
        /**
         * Extends a given prototype by merging properties from base into sub.
         *
         * @sub {Object} sub The prototype being overwritten.
         * @base {Object} base The prototype being written.
         *
         * @return {Object} The extended prototype.
         */
        function copy(src) {
            if(null === src){
                return src;
            }
            var cpy;
            if(Array.isArray(src)){
                cpy = [];
                for(var x=0;x<src.length;x+=1){
                    cpy.push(copy(src[x]));
                }
                return cpy;
            }
          
            if(src instanceof Date){
                return new Date(src.getTime());
            }
          
            if(src instanceof RegExp){
                cpy = new RegExp(src.source);
                cpy.global = src.global;
                cpy.ignoreCase = src.ignoreCase;
                cpy.multiline = src.multiline;
                cpy.lastIndex = src.lastIndex;
                return cpy;
            }
            
            if(typeof src === 'object'){
                cpy = {};
                // copy dialog pototype over definition.
                for (var prop in src) {
                    if (src.hasOwnProperty(prop)) {
                        cpy[prop] = copy(src[prop]);
                    }
                }
                return cpy;
            }
            return src;
        }
        /**
          * Helper: destruct the dialog
          *
          */
        function destruct(instance, initialize){
            //delete the dom and it's references.
            var root = instance.elements.root;
            root.parentNode.removeChild(root);
            delete instance.elements;
            //copy back initial settings.
            instance.settings = copy(instance.__settings);
            //re-reference init function.
            instance.__init = initialize;
            //delete __internal variable to allow re-initialization.
            delete instance.__internal;
        }

        /**
         * Use a closure to return proper event listener method. Try to use
         * `addEventListener` by default but fallback to `attachEvent` for
         * unsupported browser. The closure simply ensures that the test doesn't
         * happen every time the method is called.
         *
         * @param    {Node}     el    Node element
         * @param    {String}   event Event type
         * @param    {Function} fn    Callback of event
         * @return   {Function}
         */
        var on = (function () {
            if (document.addEventListener) {
                return function (el, event, fn, useCapture) {
                    el.addEventListener(event, fn, useCapture === true);
                };
            } else if (document.attachEvent) {
                return function (el, event, fn) {
                    el.attachEvent('on' + event, fn);
                };
            }
        }());

        /**
         * Use a closure to return proper event listener method. Try to use
         * `removeEventListener` by default but fallback to `detachEvent` for
         * unsupported browser. The closure simply ensures that the test doesn't
         * happen every time the method is called.
         *
         * @param    {Node}     el    Node element
         * @param    {String}   event Event type
         * @param    {Function} fn    Callback of event
         * @return   {Function}
         */
        var off = (function () {
            if (document.removeEventListener) {
                return function (el, event, fn, useCapture) {
                    el.removeEventListener(event, fn, useCapture === true);
                };
            } else if (document.detachEvent) {
                return function (el, event, fn) {
                    el.detachEvent('on' + event, fn);
                };
            }
        }());

        /**
         * Prevent default event from firing
         *
         * @param  {Event} event Event object
         * @return {undefined}

        function prevent ( event ) {
            if ( event ) {
                if ( event.preventDefault ) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                }
            }
        }
        */
        var transition = (function () {
            var t, type;
            var supported = false;
            var transitions = {
                'animation'        : 'animationend',
                'OAnimation'       : 'oAnimationEnd oanimationend',
                'msAnimation'      : 'MSAnimationEnd',
                'MozAnimation'     : 'animationend',
                'WebkitAnimation'  : 'webkitAnimationEnd'
            };

            for (t in transitions) {
                if (document.documentElement.style[t] !== undefined) {
                    type = transitions[t];
                    supported = true;
                    break;
                }
            }

            return {
                type: type,
                supported: supported
            };
        }());

        /**
        * Creates event handler delegate that sends the instance as last argument.
        * 
        * @return {Function}    a function wrapper which sends the instance as last argument.
        */
        function delegate(context, method) {
            return function () {
                if (arguments.length > 0) {
                    var args = [];
                    for (var x = 0; x < arguments.length; x += 1) {
                        args.push(arguments[x]);
                    }
                    args.push(context);
                    return method.apply(context, args);
                }
                return method.apply(context, [null, context]);
            };
        }
        /**
        * Helper for creating a dialog close event.
        * 
        * @return {object}
        */
        function createCloseEvent(index, button) {
            return {
                index: index,
                button: button,
                cancel: false
            };
        }
        /**
        * Helper for dispatching events.
        *
        * @param  {string} evenType The type of the event to disptach.
        * @param  {object} instance The dialog instance disptaching the event.
        *
        * @return   {any}   The result of the invoked function.
        */
        function dispatchEvent(eventType, instance) {
            if ( typeof instance.get(eventType) === 'function' ) {
                return instance.get(eventType).call(instance);
            }
        }


        /**
         * Super class for all dialogs
         *
         * @return {Object}		base dialog prototype
         */
        var dialog = (function () {
            var //holds the list of used keys.
                usedKeys = [],
                //dummy variable, used to trigger dom reflow.
                reflow = null,
                //holds body tab index in case it has any.
                tabindex = false,
                //condition for detecting safari
                isSafari = window.navigator.userAgent.indexOf('Safari') > -1 && window.navigator.userAgent.indexOf('Chrome') < 0,
                //dialog building blocks
                templates = {
                    dimmer:'<div class="ajs-dimmer"></div>',
                    /*tab index required to fire click event before body focus*/
                    modal: '<div class="ajs-modal" tabindex="0"></div>',
                    dialog: '<div class="ajs-dialog" tabindex="0"></div>',
                    reset: '<button class="ajs-reset"></button>',
                    commands: '<div class="ajs-commands"><button class="ajs-pin"></button><button class="ajs-maximize"></button><button class="ajs-close"></button></div>',
                    header: '<div class="ajs-header"></div>',
                    body: '<div class="ajs-body"></div>',
                    content: '<div class="ajs-content"></div>',
                    footer: '<div class="ajs-footer"></div>',
                    buttons: { primary: '<div class="ajs-primary ajs-buttons"></div>', auxiliary: '<div class="ajs-auxiliary ajs-buttons"></div>' },
                    button: '<button class="ajs-button"></button>',
                    resizeHandle: '<div class="ajs-handle"></div>',
                },
                //common class names
                classes = {
                    animationIn: 'ajs-in',
                    animationOut: 'ajs-out',
                    base: 'alertify',
                    basic:'ajs-basic',
                    capture: 'ajs-capture',
                    closable:'ajs-closable',
                    fixed: 'ajs-fixed',
                    frameless:'ajs-frameless',
                    hidden: 'ajs-hidden',
                    maximize: 'ajs-maximize',
                    maximized: 'ajs-maximized',
                    maximizable:'ajs-maximizable',
                    modeless: 'ajs-modeless',
                    movable: 'ajs-movable',
                    noSelection: 'ajs-no-selection',
                    noOverflow: 'ajs-no-overflow',
                    noPadding:'ajs-no-padding',
                    pin:'ajs-pin',
                    pinnable:'ajs-pinnable',
                    prefix: 'ajs-',
                    resizable: 'ajs-resizable',
                    restore: 'ajs-restore',
                    shake:'ajs-shake',
                    unpinned:'ajs-unpinned',
                };

            /**
             * Helper: initializes the dialog instance
             * 
             * @return	{Number}	The total count of currently open modals.
             */
            function initialize(instance){
                
                if(!instance.__internal){

                    //no need to expose init after this.
                    delete instance.__init;
                  
                    //keep a copy of initial dialog settings
                    if(!instance.__settings){
                        instance.__settings = copy(instance.settings);
                    }
                    
                    //get dialog buttons/focus setup
                    var setup;
                    if(typeof instance.setup === 'function'){
                        setup = instance.setup();
                        setup.options = setup.options  || {};
                        setup.focus = setup.focus  || {};
                    }else{
                        setup = {
                            buttons:[],
                            focus:{
                                element:null,
                                select:false
                            },
                            options:{
                            }
                        };
                    }
                    
                    //initialize hooks object.
                    if(typeof instance.hooks !== 'object'){
                        instance.hooks = {};
                    }

                    //copy buttons defintion
                    var buttonsDefinition = [];
                    if(Array.isArray(setup.buttons)){
                        for(var b=0;b<setup.buttons.length;b+=1){
                            var ref  = setup.buttons[b],
                                cpy = {};
                            for (var i in ref) {
                                if (ref.hasOwnProperty(i)) {
                                    cpy[i] = ref[i];
                                }
                            }
                            buttonsDefinition.push(cpy);
                        }
                    }

                    var internal = instance.__internal = {
                        /**
                         * Flag holding the open state of the dialog
                         * 
                         * @type {Boolean}
                         */
                        isOpen:false,
                        /**
                         * Active element is the element that will receive focus after
                         * closing the dialog. It defaults as the body tag, but gets updated
                         * to the last focused element before the dialog was opened.
                         *
                         * @type {Node}
                         */
                        activeElement:document.body,
                        timerIn:undefined,
                        timerOut:undefined,
                        buttons: buttonsDefinition,
                        focus: setup.focus,
                        options: {
                            title: undefined,
                            modal: undefined,
                            basic:undefined,
                            frameless:undefined,
                            pinned: undefined,
                            movable: undefined,
                            moveBounded:undefined,
                            resizable: undefined,
                            autoReset: undefined,
                            closable: undefined,
                            closableByDimmer: undefined,
                            maximizable: undefined,
                            startMaximized: undefined,
                            pinnable: undefined,
                            transition: undefined,
                            padding:undefined,
                            overflow:undefined,
                            onshow:undefined,
                            onclosing:undefined,
                            onclose:undefined,
                            onfocus:undefined,
                            onmove:undefined,
                            onmoved:undefined,
                            onresize:undefined,
                            onresized:undefined,
                            onmaximize:undefined,
                            onmaximized:undefined,
                            onrestore:undefined,
                            onrestored:undefined
                        },
                        resetHandler:undefined,
                        beginMoveHandler:undefined,
                        beginResizeHandler:undefined,
                        bringToFrontHandler:undefined,
                        modalClickHandler:undefined,
                        buttonsClickHandler:undefined,
                        commandsClickHandler:undefined,
                        transitionInHandler:undefined,
                        transitionOutHandler:undefined,
                        destroy:undefined
                    };

                    var elements = {};
                    //root node
                    elements.root = document.createElement('div');
                    
                    elements.root.className = classes.base + ' ' + classes.hidden + ' ';

                    elements.root.innerHTML = templates.dimmer + templates.modal;
                    
                    //dimmer
                    elements.dimmer = elements.root.firstChild;

                    //dialog
                    elements.modal = elements.root.lastChild;
                    elements.modal.innerHTML = templates.dialog;
                    elements.dialog = elements.modal.firstChild;
                    elements.dialog.innerHTML = templates.reset + templates.commands + templates.header + templates.body + templates.footer + templates.resizeHandle + templates.reset;

                    //reset links
                    elements.reset = [];
                    elements.reset.push(elements.dialog.firstChild);
                    elements.reset.push(elements.dialog.lastChild);
                    
                    //commands
                    elements.commands = {};
                    elements.commands.container = elements.reset[0].nextSibling;
                    elements.commands.pin = elements.commands.container.firstChild;
                    elements.commands.maximize = elements.commands.pin.nextSibling;
                    elements.commands.close = elements.commands.maximize.nextSibling;
                    
                    //header
                    elements.header = elements.commands.container.nextSibling;

                    //body
                    elements.body = elements.header.nextSibling;
                    elements.body.innerHTML = templates.content;
                    elements.content = elements.body.firstChild;

                    //footer
                    elements.footer = elements.body.nextSibling;
                    elements.footer.innerHTML = templates.buttons.auxiliary + templates.buttons.primary;
                    
                    //resize handle
                    elements.resizeHandle = elements.footer.nextSibling;

                    //buttons
                    elements.buttons = {};
                    elements.buttons.auxiliary = elements.footer.firstChild;
                    elements.buttons.primary = elements.buttons.auxiliary.nextSibling;
                    elements.buttons.primary.innerHTML = templates.button;
                    elements.buttonTemplate = elements.buttons.primary.firstChild;
                    //remove button template
                    elements.buttons.primary.removeChild(elements.buttonTemplate);
                                   
                    for(var x=0; x < instance.__internal.buttons.length; x+=1) {
                        var button = instance.__internal.buttons[x];
                        
                        // add to the list of used keys.
                        if(usedKeys.indexOf(button.key) < 0){
                            usedKeys.push(button.key);
                        }

                        button.element = elements.buttonTemplate.cloneNode();
                        button.element.innerHTML = button.text;
                        if(typeof button.className === 'string' &&  button.className !== ''){
                            addClass(button.element, button.className);
                        }
                        for(var key in button.attrs){
                            if(key !== 'className' && button.attrs.hasOwnProperty(key)){
                                button.element.setAttribute(key, button.attrs[key]);
                            }
                        }
                        if(button.scope === 'auxiliary'){
                            elements.buttons.auxiliary.appendChild(button.element);
                        }else{
                            elements.buttons.primary.appendChild(button.element);
                        }
                    }
                    //make elements pubic
                    instance.elements = elements;
                    
                    //save event handlers delegates
                    internal.resetHandler = delegate(instance, onReset);
                    internal.beginMoveHandler = delegate(instance, beginMove);
                    internal.beginResizeHandler = delegate(instance, beginResize);
                    internal.bringToFrontHandler = delegate(instance, bringToFront);
                    internal.modalClickHandler = delegate(instance, modalClickHandler);
                    internal.buttonsClickHandler = delegate(instance, buttonsClickHandler);
                    internal.commandsClickHandler = delegate(instance, commandsClickHandler);
                    internal.transitionInHandler = delegate(instance, handleTransitionInEvent);
                    internal.transitionOutHandler = delegate(instance, handleTransitionOutEvent);

                    //settings
                    for(var opKey in internal.options){
                        if(setup.options[opKey] !== undefined){
                            // if found in user options
                            instance.set(opKey, setup.options[opKey]);
                        }else if(alertify.defaults.hasOwnProperty(opKey)) {
                            // else if found in defaults options
                            instance.set(opKey, alertify.defaults[opKey]);
                        }else if(opKey === 'title' ) {
                            // else if title key, use alertify.defaults.glossary
                            instance.set(opKey, alertify.defaults.glossary[opKey]);
                        }
                    }

                    // allow dom customization
                    if(typeof instance.build === 'function'){
                        instance.build();
                    }
                }
                
                //add to the end of the DOM tree.
                document.body.appendChild(instance.elements.root);
            }

            /**
             * Helper: maintains scroll position
             *
             */
            var scrollX, scrollY;
            function saveScrollPosition(){
                scrollX = getScrollLeft();
                scrollY = getScrollTop();
            }
            function restoreScrollPosition(){
                window.scrollTo(scrollX, scrollY);
            }

            /**
             * Helper: adds/removes no-overflow class from body
             *
             */
            function ensureNoOverflow(){
                var requiresNoOverflow = 0;
                for(var x=0;x<openDialogs.length;x+=1){
                    var instance = openDialogs[x];
                    if(instance.isModal() || instance.isMaximized()){
                        requiresNoOverflow+=1;
                    }
                }
                if(requiresNoOverflow === 0 && document.body.className.indexOf(classes.noOverflow) >= 0){
                    //last open modal or last maximized one
                    removeClass(document.body, classes.noOverflow);
                    preventBodyShift(false);
                }else if(requiresNoOverflow > 0 && document.body.className.indexOf(classes.noOverflow) < 0){
                    //first open modal or first maximized one
                    preventBodyShift(true);
                    addClass(document.body, classes.noOverflow);
                }
            }
            var top = '', topScroll = 0;
            /**
             * Helper: prevents body shift.
             *
             */
            function preventBodyShift(add){
                if(alertify.defaults.preventBodyShift && document.documentElement.scrollHeight > document.documentElement.clientHeight){
                    if(add ){//&& openDialogs[openDialogs.length-1].elements.dialog.clientHeight <= document.documentElement.clientHeight){
                        topScroll = scrollY;
                        top = window.getComputedStyle(document.body).top;
                        addClass(document.body, classes.fixed);
                        document.body.style.top = -scrollY + 'px';
                    } else {
                        scrollY = topScroll;
                        document.body.style.top = top;
                        removeClass(document.body, classes.fixed);
                        restoreScrollPosition();
                    }
                }
            }
    		
            /**
             * Sets the name of the transition used to show/hide the dialog
             * 
             * @param {Object} instance The dilog instance.
             *
             */
            function updateTransition(instance, value, oldValue){
                if(typeof oldValue === 'string'){
                    removeClass(instance.elements.root,classes.prefix +  oldValue);
                }
                addClass(instance.elements.root, classes.prefix + value);
                reflow = instance.elements.root.offsetWidth;
            }
    		
            /**
             * Toggles the dialog display mode
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function updateDisplayMode(instance){
                if(instance.get('modal')){

                    //make modal
                    removeClass(instance.elements.root, classes.modeless);

                    //only if open
                    if(instance.isOpen()){
                        unbindModelessEvents(instance);

                        //in case a pinned modless dialog was made modal while open.
                        updateAbsPositionFix(instance);

                        ensureNoOverflow();
                    }
                }else{
                    //make modelss
                    addClass(instance.elements.root, classes.modeless);

                    //only if open
                    if(instance.isOpen()){
                        bindModelessEvents(instance);

                        //in case pin/unpin was called while a modal is open
                        updateAbsPositionFix(instance);

                        ensureNoOverflow();
                    }
                }
            }

            /**
             * Toggles the dialog basic view mode 
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function updateBasicMode(instance){
                if (instance.get('basic')) {
                    // add class
                    addClass(instance.elements.root, classes.basic);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.basic);
                }
            }

            /**
             * Toggles the dialog frameless view mode 
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function updateFramelessMode(instance){
                if (instance.get('frameless')) {
                    // add class
                    addClass(instance.elements.root, classes.frameless);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.frameless);
                }
            }
    		
            /**
             * Helper: Brings the modeless dialog to front, attached to modeless dialogs.
             *
             * @param {Event} event Focus event
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bringToFront(event, instance){
                
                // Do not bring to front if preceeded by an open modal
                var index = openDialogs.indexOf(instance);
                for(var x=index+1;x<openDialogs.length;x+=1){
                    if(openDialogs[x].isModal()){
                        return;
                    }
                }
    			
                // Bring to front by making it the last child.
                if(document.body.lastChild !== instance.elements.root){
                    document.body.appendChild(instance.elements.root);
                    //also make sure its at the end of the list
                    openDialogs.splice(openDialogs.indexOf(instance),1);
                    openDialogs.push(instance);
                    setFocus(instance);
                }
    			
                return false;
            }
    		
            /**
             * Helper: reflects dialogs options updates
             *
             * @param {Object} instance The dilog instance.
             * @param {String} option The updated option name.
             *
             * @return	{undefined}	
             */
            function optionUpdated(instance, option, oldValue, newValue){
                switch(option){
                case 'title':
                    instance.setHeader(newValue);
                    break;
                case 'modal':
                    updateDisplayMode(instance);
                    break;
                case 'basic':
                    updateBasicMode(instance);
                    break;
                case 'frameless':
                    updateFramelessMode(instance);
                    break;
                case 'pinned':
                    updatePinned(instance);
                    break;
                case 'closable':
                    updateClosable(instance);
                    break;
                case 'maximizable':
                    updateMaximizable(instance);
                    break;
                case 'pinnable':
                    updatePinnable(instance);
                    break;
                case 'movable':
                    updateMovable(instance);
                    break;
                case 'resizable':
                    updateResizable(instance);
                    break;
                case 'padding':
                    if(newValue){
                        removeClass(instance.elements.root, classes.noPadding);
                    }else if(instance.elements.root.className.indexOf(classes.noPadding) < 0){
                        addClass(instance.elements.root, classes.noPadding);
                    }
                    break;
                case 'overflow':
                    if(newValue){
                        removeClass(instance.elements.root, classes.noOverflow);
                    }else if(instance.elements.root.className.indexOf(classes.noOverflow) < 0){
                        addClass(instance.elements.root, classes.noOverflow);
                    }
                    break;
                case 'transition':
                    updateTransition(instance,newValue, oldValue);
                    break;
                }

                // internal on option updated event
                if(typeof instance.hooks.onupdate === 'function'){
                    instance.hooks.onupdate.call(instance, option, oldValue, newValue);
                }
            }
    		
            /**
             * Helper: reflects dialogs options updates
             *
             * @param {Object} instance The dilog instance.
             * @param {Object} obj The object to set/get a value on/from.
             * @param {Function} callback The callback function to call if the key was found.
             * @param {String|Object} key A string specifying a propery name or a collection of key value pairs.
             * @param {Object} value Optional, the value associated with the key (in case it was a string).
             * @param {String} option The updated option name.
             *
             * @return	{Object} result object 
             *	The result objects has an 'op' property, indicating of this is a SET or GET operation.
             *		GET: 
             *		- found: a flag indicating if the key was found or not.
             *		- value: the property value.
             *		SET:
             *		- items: a list of key value pairs of the properties being set.
             *				each contains:
             *					- found: a flag indicating if the key was found or not.
             *					- key: the property key.
             *					- value: the property value.
             */
            function update(instance, obj, callback, key, value){
                var result = {op:undefined, items: [] };
                if(typeof value === 'undefined' && typeof key === 'string') {
                    //get
                    result.op = 'get';
                    if(obj.hasOwnProperty(key)){
                        result.found = true;
                        result.value = obj[key];
                    }else{
                        result.found = false;
                        result.value = undefined;
                    }
                }
                else
                {
                    var old;
                    //set
                    result.op = 'set';
                    if(typeof key === 'object'){
                        //set multiple
                        var args = key;
                        for (var prop in args) {
                            if (obj.hasOwnProperty(prop)) {
                                if(obj[prop] !== args[prop]){
                                    old = obj[prop];
                                    obj[prop] = args[prop];
                                    callback.call(instance,prop, old, args[prop]);
                                }
                                result.items.push({ 'key': prop, 'value': args[prop], 'found':true});
                            }else{
                                result.items.push({ 'key': prop, 'value': args[prop], 'found':false});
                            }
                        }
                    } else if (typeof key === 'string'){
                        //set single
                        if (obj.hasOwnProperty(key)) {
                            if(obj[key] !== value){
                                old  = obj[key];
                                obj[key] = value;
                                callback.call(instance,key, old, value);
                            }
                            result.items.push({'key': key, 'value': value , 'found':true});

                        }else{
                            result.items.push({'key': key, 'value': value , 'found':false});
                        }
                    } else {
                        //invalid params
                        throw new Error('args must be a string or object');
                    }
                }
                return result;
            }


            /**
             * Triggers a close event.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function triggerClose(instance) {
                var found;
                triggerCallback(instance, function (button) {
                    return found = (button.invokeOnClose === true);
                });
                //none of the buttons registered as onclose callback
                //close the dialog
                if (!found && instance.isOpen()) {
                    instance.close();
                }
            }

            /**
             * Dialogs commands event handler, attached to the dialog commands element.
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function commandsClickHandler(event, instance) {
                var target = event.srcElement || event.target;
                switch (target) {
                case instance.elements.commands.pin:
                    if (!instance.isPinned()) {
                        pin(instance);
                    } else {
                        unpin(instance);
                    }
                    break;
                case instance.elements.commands.maximize:
                    if (!instance.isMaximized()) {
                        maximize(instance);
                    } else {
                        restore(instance);
                    }
                    break;
                case instance.elements.commands.close:
                    triggerClose(instance);
                    break;
                }
                return false;
            }

            /**
             * Helper: pins the modeless dialog.
             *
             * @param {Object} instance	The dialog instance.
             * 
             * @return {undefined}
             */
            function pin(instance) {
                //pin the dialog
                instance.set('pinned', true);
            }

            /**
             * Helper: unpins the modeless dialog.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function unpin(instance) {
                //unpin the dialog 
                instance.set('pinned', false);
            }


            /**
             * Helper: enlarges the dialog to fill the entire screen.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function maximize(instance) {
                // allow custom `onmaximize` method
                dispatchEvent('onmaximize', instance);
                //maximize the dialog 
                addClass(instance.elements.root, classes.maximized);
                if (instance.isOpen()) {
                    ensureNoOverflow();
                }
                // allow custom `onmaximized` method
                dispatchEvent('onmaximized', instance);
            }

            /**
             * Helper: returns the dialog to its former size.
             *
             * @param {Object} instance	The dilog instance.
             * 
             * @return {undefined}
             */
            function restore(instance) {
                // allow custom `onrestore` method
                dispatchEvent('onrestore', instance);
                //maximize the dialog 
                removeClass(instance.elements.root, classes.maximized);
                if (instance.isOpen()) {
                    ensureNoOverflow();
                }
                // allow custom `onrestored` method
                dispatchEvent('onrestored', instance);
            }

            /**
             * Show or hide the maximize box.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updatePinnable(instance) {
                if (instance.get('pinnable')) {
                    // add class
                    addClass(instance.elements.root, classes.pinnable);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.pinnable);
                }
            }

            /**
             * Helper: Fixes the absolutly positioned modal div position.
             *
             * @param {Object} instance The dialog instance.
             *
             * @return {undefined}
             */
            function addAbsPositionFix(instance) {
                var scrollLeft = getScrollLeft();
                instance.elements.modal.style.marginTop = getScrollTop() + 'px';
                instance.elements.modal.style.marginLeft = scrollLeft + 'px';
                instance.elements.modal.style.marginRight = (-scrollLeft) + 'px';
            }

            /**
             * Helper: Removes the absolutly positioned modal div position fix.
             *
             * @param {Object} instance The dialog instance.
             *
             * @return {undefined}
             */
            function removeAbsPositionFix(instance) {
                var marginTop = parseInt(instance.elements.modal.style.marginTop, 10);
                var marginLeft = parseInt(instance.elements.modal.style.marginLeft, 10);
                instance.elements.modal.style.marginTop = '';
                instance.elements.modal.style.marginLeft = '';
                instance.elements.modal.style.marginRight = '';

                if (instance.isOpen()) {
                    var top = 0,
                        left = 0
                    ;
                    if (instance.elements.dialog.style.top !== '') {
                        top = parseInt(instance.elements.dialog.style.top, 10);
                    }
                    instance.elements.dialog.style.top = (top + (marginTop - getScrollTop())) + 'px';

                    if (instance.elements.dialog.style.left !== '') {
                        left = parseInt(instance.elements.dialog.style.left, 10);
                    }
                    instance.elements.dialog.style.left = (left + (marginLeft - getScrollLeft())) + 'px';
                }
            }
            /**
             * Helper: Adds/Removes the absolutly positioned modal div position fix based on its pinned setting.
             *
             * @param {Object} instance The dialog instance.
             *
             * @return {undefined}
             */
            function updateAbsPositionFix(instance) {
                // if modeless and unpinned add fix
                if (!instance.get('modal') && !instance.get('pinned')) {
                    addAbsPositionFix(instance);
                } else {
                    removeAbsPositionFix(instance);
                }
            }
            /**
             * Toggles the dialog position lock | modeless only.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to make it modal, false otherwise.
             *
             * @return {undefined}
             */
            function updatePinned(instance) {
                if (instance.get('pinned')) {
                    removeClass(instance.elements.root, classes.unpinned);
                    if (instance.isOpen()) {
                        removeAbsPositionFix(instance);
                    }
                } else {
                    addClass(instance.elements.root, classes.unpinned);
                    if (instance.isOpen() && !instance.isModal()) {
                        addAbsPositionFix(instance);
                    }
                }
            }

            /**
             * Show or hide the maximize box.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateMaximizable(instance) {
                if (instance.get('maximizable')) {
                    // add class
                    addClass(instance.elements.root, classes.maximizable);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.maximizable);
                }
            }

            /**
             * Show or hide the close box.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateClosable(instance) {
                if (instance.get('closable')) {
                    // add class
                    addClass(instance.elements.root, classes.closable);
                    bindClosableEvents(instance);
                } else {
                    // remove class
                    removeClass(instance.elements.root, classes.closable);
                    unbindClosableEvents(instance);
                }
            }

            // flag to cancel click event if already handled by end resize event (the mousedown, mousemove, mouseup sequence fires a click event.).
            var cancelClick = false;

            /**
             * Helper: closes the modal dialog when clicking the modal
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function modalClickHandler(event, instance) {
                var target = event.srcElement || event.target;
                if (!cancelClick && target === instance.elements.modal && instance.get('closableByDimmer') === true) {
                    triggerClose(instance);
                }
                cancelClick = false;
                return false;
            }

            // flag to cancel keyup event if already handled by click event (pressing Enter on a focusted button).
            var cancelKeyup = false;
            /** 
             * Helper: triggers a button callback
             *
             * @param {Object}		The dilog instance.
             * @param {Function}	Callback to check which button triggered the event.
             *
             * @return {undefined}
             */
            function triggerCallback(instance, check) {
                for (var idx = 0; idx < instance.__internal.buttons.length; idx += 1) {
                    var button = instance.__internal.buttons[idx];
                    if (!button.element.disabled && check(button)) {
                        var closeEvent = createCloseEvent(idx, button);
                        if (typeof instance.callback === 'function') {
                            instance.callback.apply(instance, [closeEvent]);
                        }
                        //close the dialog only if not canceled.
                        if (closeEvent.cancel === false) {
                            instance.close();
                        }
                        break;
                    }
                }
            }

            /**
             * Clicks event handler, attached to the dialog footer.
             *
             * @param {Event}		DOM event object.
             * @param {Object}		The dilog instance.
             * 
             * @return {undefined}
             */
            function buttonsClickHandler(event, instance) {
                var target = event.srcElement || event.target;
                triggerCallback(instance, function (button) {
                    // if this button caused the click, cancel keyup event
                    return button.element === target && (cancelKeyup = true);
                });
            }

            /**
             * Keyup event handler, attached to the document.body
             *
             * @param {Event}		DOM event object.
             * @param {Object}		The dilog instance.
             * 
             * @return {undefined}
             */
            function keyupHandler(event) {
                //hitting enter while button has focus will trigger keyup too.
                //ignore if handled by clickHandler
                if (cancelKeyup) {
                    cancelKeyup = false;
                    return;
                }
                var instance = openDialogs[openDialogs.length - 1];
                var keyCode = event.keyCode;
                if (instance.__internal.buttons.length === 0 && keyCode === keys.ESC && instance.get('closable') === true) {
                    triggerClose(instance);
                    return false;
                }else if (usedKeys.indexOf(keyCode) > -1) {
                    triggerCallback(instance, function (button) {
                        return button.key === keyCode;
                    });
                    return false;
                }
            }
            /**
            * Keydown event handler, attached to the document.body
            *
            * @param {Event}		DOM event object.
            * @param {Object}		The dilog instance.
            * 
            * @return {undefined}
            */
            function keydownHandler(event) {
                var instance = openDialogs[openDialogs.length - 1];
                var keyCode = event.keyCode;
                if (keyCode === keys.LEFT || keyCode === keys.RIGHT) {
                    var buttons = instance.__internal.buttons;
                    for (var x = 0; x < buttons.length; x += 1) {
                        if (document.activeElement === buttons[x].element) {
                            switch (keyCode) {
                            case keys.LEFT:
                                buttons[(x || buttons.length) - 1].element.focus();
                                return;
                            case keys.RIGHT:
                                buttons[(x + 1) % buttons.length].element.focus();
                                return;
                            }
                        }
                    }
                }else if (keyCode < keys.F12 + 1 && keyCode > keys.F1 - 1 && usedKeys.indexOf(keyCode) > -1) {
                    event.preventDefault();
                    event.stopPropagation();
                    triggerCallback(instance, function (button) {
                        return button.key === keyCode;
                    });
                    return false;
                }
            }


            /**
             * Sets focus to proper dialog element
             *
             * @param {Object} instance The dilog instance.
             * @param {Node} [resetTarget=undefined] DOM element to reset focus to.
             *
             * @return {undefined}
             */
            function setFocus(instance, resetTarget) {
                // reset target has already been determined.
                if (resetTarget) {
                    resetTarget.focus();
                } else {
                    // current instance focus settings
                    var focus = instance.__internal.focus;
                    // the focus element.
                    var element = focus.element;

                    switch (typeof focus.element) {
                    // a number means a button index
                    case 'number':
                        if (instance.__internal.buttons.length > focus.element) {
                            //in basic view, skip focusing the buttons.
                            if (instance.get('basic') === true) {
                                element = instance.elements.reset[0];
                            } else {
                                element = instance.__internal.buttons[focus.element].element;
                            }
                        }
                        break;
                    // a string means querySelector to select from dialog body contents.
                    case 'string':
                        element = instance.elements.body.querySelector(focus.element);
                        break;
                    // a function should return the focus element.
                    case 'function':
                        element = focus.element.call(instance);
                        break;
                    }
                    
                    // if no focus element, default to first reset element.
                    if ((typeof element === 'undefined' || element === null) && instance.__internal.buttons.length === 0) {
                        element = instance.elements.reset[0];
                    }
                    // focus
                    if (element && element.focus) {
                        element.focus();
                        // if selectable
                        if (focus.select && element.select) {
                            element.select();
                        }
                    }
                }
            }

            /**
             * Focus event handler, attached to document.body and dialogs own reset links.
             * handles the focus for modal dialogs only.
             *
             * @param {Event} event DOM focus event object.
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function onReset(event, instance) {

                // should work on last modal if triggered from document.body 
                if (!instance) {
                    for (var x = openDialogs.length - 1; x > -1; x -= 1) {
                        if (openDialogs[x].isModal()) {
                            instance = openDialogs[x];
                            break;
                        }
                    }
                }
                // if modal
                if (instance && instance.isModal()) {
                    // determine reset target to enable forward/backward tab cycle.
                    var resetTarget, target = event.srcElement || event.target;
                    var lastResetElement = target === instance.elements.reset[1] || (instance.__internal.buttons.length === 0 && target === document.body);

                    // if last reset link, then go to maximize or close
                    if (lastResetElement) {
                        if (instance.get('maximizable')) {
                            resetTarget = instance.elements.commands.maximize;
                        } else if (instance.get('closable')) {
                            resetTarget = instance.elements.commands.close;
                        }
                    }
                    // if no reset target found, try finding the best button
                    if (resetTarget === undefined) {
                        if (typeof instance.__internal.focus.element === 'number') {
                            // button focus element, go to first available button
                            if (target === instance.elements.reset[0]) {
                                resetTarget = instance.elements.buttons.auxiliary.firstChild || instance.elements.buttons.primary.firstChild;
                            } else if (lastResetElement) {
                                //restart the cycle by going to first reset link
                                resetTarget = instance.elements.reset[0];
                            }
                        } else {
                            // will reach here when tapping backwards, so go to last child
                            // The focus element SHOULD NOT be a button (logically!).
                            if (target === instance.elements.reset[0]) {
                                resetTarget = instance.elements.buttons.primary.lastChild || instance.elements.buttons.auxiliary.lastChild;
                            }
                        }
                    }
                    // focus
                    setFocus(instance, resetTarget);
                }
            }
            /**
             * Transition in transitionend event handler. 
             *
             * @param {Event}		TransitionEnd event object.
             * @param {Object}		The dilog instance.
             *
             * @return {undefined}
             */
            function handleTransitionInEvent(event, instance) {
                // clear the timer
                clearTimeout(instance.__internal.timerIn);

                // once transition is complete, set focus
                setFocus(instance);

                //restore scroll to prevent document jump
                restoreScrollPosition();

                // allow handling key up after transition ended.
                cancelKeyup = false;

                // allow custom `onfocus` method
                dispatchEvent('onfocus', instance);

                // unbind the event
                off(instance.elements.dialog, transition.type, instance.__internal.transitionInHandler);

                removeClass(instance.elements.root, classes.animationIn);
            }

            /**
             * Transition out transitionend event handler. 
             *
             * @param {Event}		TransitionEnd event object.
             * @param {Object}		The dilog instance.
             *
             * @return {undefined}
             */
            function handleTransitionOutEvent(event, instance) {
                // clear the timer
                clearTimeout(instance.__internal.timerOut);
                // unbind the event
                off(instance.elements.dialog, transition.type, instance.__internal.transitionOutHandler);

                // reset move updates
                resetMove(instance);
                // reset resize updates
                resetResize(instance);

                // restore if maximized
                if (instance.isMaximized() && !instance.get('startMaximized')) {
                    restore(instance);
                }

                // return focus to the last active element
                if (alertify.defaults.maintainFocus && instance.__internal.activeElement) {
                    instance.__internal.activeElement.focus();
                    instance.__internal.activeElement = null;
                }
                
                //destory the instance
                if (typeof instance.__internal.destroy === 'function') {
                    instance.__internal.destroy.apply(instance);
                }
            }
            /* Controls moving a dialog around */
            //holde the current moving instance
            var movable = null,
                //holds the current X offset when move starts
                offsetX = 0,
                //holds the current Y offset when move starts
                offsetY = 0,
                xProp = 'pageX',
                yProp = 'pageY',
                bounds = null,
                refreshTop = false,
                moveDelegate = null
            ;

            /**
             * Helper: sets the element top/left coordinates
             *
             * @param {Event} event	DOM event object.
             * @param {Node} element The element being moved.
             * 
             * @return {undefined}
             */
            function moveElement(event, element) {
                var left = (event[xProp] - offsetX),
                    top  = (event[yProp] - offsetY);

                if(refreshTop){
                    top -= document.body.scrollTop;
                }
               
                element.style.left = left + 'px';
                element.style.top = top + 'px';
               
            }
            /**
             * Helper: sets the element top/left coordinates within screen bounds
             *
             * @param {Event} event	DOM event object.
             * @param {Node} element The element being moved.
             * 
             * @return {undefined}
             */
            function moveElementBounded(event, element) {
                var left = (event[xProp] - offsetX),
                    top  = (event[yProp] - offsetY);

                if(refreshTop){
                    top -= document.body.scrollTop;
                }
                
                element.style.left = Math.min(bounds.maxLeft, Math.max(bounds.minLeft, left)) + 'px';
                if(refreshTop){
                    element.style.top = Math.min(bounds.maxTop, Math.max(bounds.minTop, top)) + 'px';
                }else{
                    element.style.top = Math.max(bounds.minTop, top) + 'px';
                }
            }
                

            /**
             * Triggers the start of a move event, attached to the header element mouse down event.
             * Adds no-selection class to the body, disabling selection while moving.
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance The dilog instance.
             * 
             * @return {Boolean} false
             */
            function beginMove(event, instance) {
                if (resizable === null && !instance.isMaximized() && instance.get('movable')) {
                    var eventSrc, left=0, top=0;
                    if (event.type === 'touchstart') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                        xProp = 'clientX';
                        yProp = 'clientY';
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }

                    if (eventSrc) {

                        var element = instance.elements.dialog;
                        addClass(element, classes.capture);

                        if (element.style.left) {
                            left = parseInt(element.style.left, 10);
                        }

                        if (element.style.top) {
                            top = parseInt(element.style.top, 10);
                        }
                        
                        offsetX = eventSrc[xProp] - left;
                        offsetY = eventSrc[yProp] - top;

                        if(instance.isModal()){
                            offsetY += instance.elements.modal.scrollTop;
                        }else if(instance.isPinned()){
                            offsetY -= document.body.scrollTop;
                        }
                        
                        if(instance.get('moveBounded')){
                            var current = element,
                                offsetLeft = -left,
                                offsetTop = -top;
                            
                            //calc offset
                            do {
                                offsetLeft += current.offsetLeft;
                                offsetTop += current.offsetTop;
                            } while (current = current.offsetParent);
                            
                            bounds = {
                                maxLeft : offsetLeft,
                                minLeft : -offsetLeft,
                                maxTop  : document.documentElement.clientHeight - element.clientHeight - offsetTop,
                                minTop  : -offsetTop
                            };
                            moveDelegate = moveElementBounded;
                        }else{
                            bounds = null;
                            moveDelegate = moveElement;
                        }
                        
                        // allow custom `onmove` method
                        dispatchEvent('onmove', instance);

                        refreshTop = !instance.isModal() && instance.isPinned();
                        movable = instance;
                        moveDelegate(eventSrc, element);
                        addClass(document.body, classes.noSelection);
                        return false;
                    }
                }
            }

            /**
             * The actual move handler,  attached to document.body mousemove event.
             *
             * @param {Event} event	DOM event object.
             * 
             * @return {undefined}
             */
            function move(event) {
                if (movable) {
                    var eventSrc;
                    if (event.type === 'touchmove') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }
                    if (eventSrc) {
                        moveDelegate(eventSrc, movable.elements.dialog);
                    }
                }
            }

            /**
             * Triggers the end of a move event,  attached to document.body mouseup event.
             * Removes no-selection class from document.body, allowing selection.
             *
             * @return {undefined}
             */
            function endMove() {
                if (movable) {
                    var instance = movable;
                    movable = bounds = null;
                    removeClass(document.body, classes.noSelection);
                    removeClass(instance.elements.dialog, classes.capture);
                    // allow custom `onmoved` method
                    dispatchEvent('onmoved', instance);
                }
            }

            /**
             * Resets any changes made by moving the element to its original state,
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function resetMove(instance) {
                movable = null;
                var element = instance.elements.dialog;
                element.style.left = element.style.top = '';
            }

            /**
             * Updates the dialog move behavior.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateMovable(instance) {
                if (instance.get('movable')) {
                    // add class
                    addClass(instance.elements.root, classes.movable);
                    if (instance.isOpen()) {
                        bindMovableEvents(instance);
                    }
                } else {

                    //reset
                    resetMove(instance);
                    // remove class
                    removeClass(instance.elements.root, classes.movable);
                    if (instance.isOpen()) {
                        unbindMovableEvents(instance);
                    }
                }
            }

            /* Controls moving a dialog around */
            //holde the current instance being resized		
            var resizable = null,
                //holds the staring left offset when resize starts.
                startingLeft = Number.Nan,
                //holds the staring width when resize starts.
                startingWidth = 0,
                //holds the initial width when resized for the first time.
                minWidth = 0,
                //holds the offset of the resize handle.
                handleOffset = 0
            ;

            /**
             * Helper: sets the element width/height and updates left coordinate if neccessary.
             *
             * @param {Event} event	DOM mousemove event object.
             * @param {Node} element The element being moved.
             * @param {Boolean} pinned A flag indicating if the element being resized is pinned to the screen.
             * 
             * @return {undefined}
             */
            function resizeElement(event, element, pageRelative) {

                //calculate offsets from 0,0
                var current = element;
                var offsetLeft = 0;
                var offsetTop = 0;
                do {
                    offsetLeft += current.offsetLeft;
                    offsetTop += current.offsetTop;
                } while (current = current.offsetParent);

                // determine X,Y coordinates.
                var X, Y;
                if (pageRelative === true) {
                    X = event.pageX;
                    Y = event.pageY;
                } else {
                    X = event.clientX;
                    Y = event.clientY;
                }
                // rtl handling
                var isRTL = isRightToLeft();
                if (isRTL) {
                    // reverse X 
                    X = document.body.offsetWidth - X;
                    // if has a starting left, calculate offsetRight
                    if (!isNaN(startingLeft)) {
                        offsetLeft = document.body.offsetWidth - offsetLeft - element.offsetWidth;
                    }
                }

                // set width/height
                element.style.height = (Y - offsetTop + handleOffset) + 'px';
                element.style.width = (X - offsetLeft + handleOffset) + 'px';

                // if the element being resized has a starting left, maintain it.
                // the dialog is centered, divide by half the offset to maintain the margins.
                if (!isNaN(startingLeft)) {
                    var diff = Math.abs(element.offsetWidth - startingWidth) * 0.5;
                    if (isRTL) {
                        //negate the diff, why?
                        //when growing it should decrease left
                        //when shrinking it should increase left
                        diff *= -1;
                    }
                    if (element.offsetWidth > startingWidth) {
                        //growing
                        element.style.left = (startingLeft + diff) + 'px';
                    } else if (element.offsetWidth >= minWidth) {
                        //shrinking
                        element.style.left = (startingLeft - diff) + 'px';
                    }
                }
            }

            /**
             * Triggers the start of a resize event, attached to the resize handle element mouse down event.
             * Adds no-selection class to the body, disabling selection while moving.
             *
             * @param {Event} event	DOM event object.
             * @param {Object} instance The dilog instance.
             * 
             * @return {Boolean} false
             */
            function beginResize(event, instance) {
                if (!instance.isMaximized()) {
                    var eventSrc;
                    if (event.type === 'touchstart') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }
                    if (eventSrc) {
                        // allow custom `onresize` method
                        dispatchEvent('onresize', instance);
                        
                        resizable = instance;
                        handleOffset = instance.elements.resizeHandle.offsetHeight / 2;
                        var element = instance.elements.dialog;
                        addClass(element, classes.capture);
                        startingLeft = parseInt(element.style.left, 10);
                        element.style.height = element.offsetHeight + 'px';
                        element.style.minHeight = instance.elements.header.offsetHeight + instance.elements.footer.offsetHeight + 'px';
                        element.style.width = (startingWidth = element.offsetWidth) + 'px';

                        if (element.style.maxWidth !== 'none') {
                            element.style.minWidth = (minWidth = element.offsetWidth) + 'px';
                        }
                        element.style.maxWidth = 'none';
                        addClass(document.body, classes.noSelection);
                        return false;
                    }
                }
            }

            /**
             * The actual resize handler,  attached to document.body mousemove event.
             *
             * @param {Event} event	DOM event object.
             * 
             * @return {undefined}
             */
            function resize(event) {
                if (resizable) {
                    var eventSrc;
                    if (event.type === 'touchmove') {
                        event.preventDefault();
                        eventSrc = event.targetTouches[0];
                    } else if (event.button === 0) {
                        eventSrc = event;
                    }
                    if (eventSrc) {
                        resizeElement(eventSrc, resizable.elements.dialog, !resizable.get('modal') && !resizable.get('pinned'));
                    }
                }
            }

            /**
             * Triggers the end of a resize event,  attached to document.body mouseup event.
             * Removes no-selection class from document.body, allowing selection.
             *
             * @return {undefined}
             */
            function endResize() {
                if (resizable) {
                    var instance = resizable;
                    resizable = null;
                    removeClass(document.body, classes.noSelection);
                    removeClass(instance.elements.dialog, classes.capture);
                    cancelClick = true;
                    // allow custom `onresized` method
                    dispatchEvent('onresized', instance);
                }
            }

            /**
             * Resets any changes made by resizing the element to its original state.
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function resetResize(instance) {
                resizable = null;
                var element = instance.elements.dialog;
                if (element.style.maxWidth === 'none') {
                    //clear inline styles.
                    element.style.maxWidth = element.style.minWidth = element.style.width = element.style.height = element.style.minHeight = element.style.left = '';
                    //reset variables.
                    startingLeft = Number.Nan;
                    startingWidth = minWidth = handleOffset = 0;
                }
            }


            /**
             * Updates the dialog move behavior.
             *
             * @param {Object} instance The dilog instance.
             * @param {Boolean} on True to add the behavior, removes it otherwise.
             *
             * @return {undefined}
             */
            function updateResizable(instance) {
                if (instance.get('resizable')) {
                    // add class
                    addClass(instance.elements.root, classes.resizable);
                    if (instance.isOpen()) {
                        bindResizableEvents(instance);
                    }
                } else {
                    //reset
                    resetResize(instance);
                    // remove class
                    removeClass(instance.elements.root, classes.resizable);
                    if (instance.isOpen()) {
                        unbindResizableEvents(instance);
                    }
                }
            }

            /**
             * Reset move/resize on window resize.
             *
             * @param {Event} event	window resize event object.
             *
             * @return {undefined}
             */
            function windowResize(/*event*/) {
                for (var x = 0; x < openDialogs.length; x += 1) {
                    var instance = openDialogs[x];
                    if (instance.get('autoReset')) {
                        resetMove(instance);
                        resetResize(instance);
                    }
                }
            }
            /**
             * Bind dialogs events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindEvents(instance) {
                // if first dialog, hook global handlers
                if (openDialogs.length === 1) {
                    //global
                    on(window, 'resize', windowResize);
                    on(document.body, 'keyup', keyupHandler);
                    on(document.body, 'keydown', keydownHandler);
                    on(document.body, 'focus', onReset);

                    //move
                    on(document.documentElement, 'mousemove', move);
                    on(document.documentElement, 'touchmove', move);
                    on(document.documentElement, 'mouseup', endMove);
                    on(document.documentElement, 'touchend', endMove);
                    //resize
                    on(document.documentElement, 'mousemove', resize);
                    on(document.documentElement, 'touchmove', resize);
                    on(document.documentElement, 'mouseup', endResize);
                    on(document.documentElement, 'touchend', endResize);
                }

                // common events
                on(instance.elements.commands.container, 'click', instance.__internal.commandsClickHandler);
                on(instance.elements.footer, 'click', instance.__internal.buttonsClickHandler);
                on(instance.elements.reset[0], 'focus', instance.__internal.resetHandler);
                on(instance.elements.reset[1], 'focus', instance.__internal.resetHandler);

                //prevent handling key up when dialog is being opened by a key stroke.
                cancelKeyup = true;
                // hook in transition handler
                on(instance.elements.dialog, transition.type, instance.__internal.transitionInHandler);

                // modelss only events
                if (!instance.get('modal')) {
                    bindModelessEvents(instance);
                }

                // resizable
                if (instance.get('resizable')) {
                    bindResizableEvents(instance);
                }

                // movable
                if (instance.get('movable')) {
                    bindMovableEvents(instance);
                }
            }

            /**
             * Unbind dialogs events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindEvents(instance) {
                // if last dialog, remove global handlers
                if (openDialogs.length === 1) {
                    //global
                    off(window, 'resize', windowResize);
                    off(document.body, 'keyup', keyupHandler);
                    off(document.body, 'keydown', keydownHandler);
                    off(document.body, 'focus', onReset);
                    //move
                    off(document.documentElement, 'mousemove', move);
                    off(document.documentElement, 'mouseup', endMove);
                    //resize
                    off(document.documentElement, 'mousemove', resize);
                    off(document.documentElement, 'mouseup', endResize);
                }

                // common events
                off(instance.elements.commands.container, 'click', instance.__internal.commandsClickHandler);
                off(instance.elements.footer, 'click', instance.__internal.buttonsClickHandler);
                off(instance.elements.reset[0], 'focus', instance.__internal.resetHandler);
                off(instance.elements.reset[1], 'focus', instance.__internal.resetHandler);

                // hook out transition handler
                on(instance.elements.dialog, transition.type, instance.__internal.transitionOutHandler);

                // modelss only events
                if (!instance.get('modal')) {
                    unbindModelessEvents(instance);
                }

                // movable
                if (instance.get('movable')) {
                    unbindMovableEvents(instance);
                }

                // resizable
                if (instance.get('resizable')) {
                    unbindResizableEvents(instance);
                }

            }

            /**
             * Bind modeless specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindModelessEvents(instance) {
                on(instance.elements.dialog, 'focus', instance.__internal.bringToFrontHandler, true);
            }

            /**
             * Unbind modeless specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindModelessEvents(instance) {
                off(instance.elements.dialog, 'focus', instance.__internal.bringToFrontHandler, true);
            }



            /**
             * Bind movable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindMovableEvents(instance) {
                on(instance.elements.header, 'mousedown', instance.__internal.beginMoveHandler);
                on(instance.elements.header, 'touchstart', instance.__internal.beginMoveHandler);
            }

            /**
             * Unbind movable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindMovableEvents(instance) {
                off(instance.elements.header, 'mousedown', instance.__internal.beginMoveHandler);
                off(instance.elements.header, 'touchstart', instance.__internal.beginMoveHandler);
            }



            /**
             * Bind resizable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindResizableEvents(instance) {
                on(instance.elements.resizeHandle, 'mousedown', instance.__internal.beginResizeHandler);
                on(instance.elements.resizeHandle, 'touchstart', instance.__internal.beginResizeHandler);
            }

            /**
             * Unbind resizable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindResizableEvents(instance) {
                off(instance.elements.resizeHandle, 'mousedown', instance.__internal.beginResizeHandler);
                off(instance.elements.resizeHandle, 'touchstart', instance.__internal.beginResizeHandler);
            }

            /**
             * Bind closable events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function bindClosableEvents(instance) {
                on(instance.elements.modal, 'click', instance.__internal.modalClickHandler);
            }

            /**
             * Unbind closable specific events
             *
             * @param {Object} instance The dilog instance.
             *
             * @return {undefined}
             */
            function unbindClosableEvents(instance) {
                off(instance.elements.modal, 'click', instance.__internal.modalClickHandler);
            }
            // dialog API
            return {
                __init:initialize,
                /**
                 * Check if dialog is currently open
                 *
                 * @return {Boolean}
                 */
                isOpen: function () {
                    return this.__internal.isOpen;
                },
                isModal: function (){
                    return this.elements.root.className.indexOf(classes.modeless) < 0;
                },
                isMaximized:function(){
                    return this.elements.root.className.indexOf(classes.maximized) > -1;
                },
                isPinned:function(){
                    return this.elements.root.className.indexOf(classes.unpinned) < 0;
                },
                maximize:function(){
                    if(!this.isMaximized()){
                        maximize(this);
                    }
                    return this;
                },
                restore:function(){
                    if(this.isMaximized()){
                        restore(this);
                    }
                    return this;
                },
                pin:function(){
                    if(!this.isPinned()){
                        pin(this);
                    }
                    return this;
                },
                unpin:function(){
                    if(this.isPinned()){
                        unpin(this);
                    }
                    return this;
                },
                bringToFront:function(){
                    bringToFront(null, this);
                    return this;
                },
                /**
                 * Move the dialog to a specific x/y coordinates
                 *
                 * @param {Number} x    The new dialog x coordinate in pixels.
                 * @param {Number} y    The new dialog y coordinate in pixels.
                 *
                 * @return {Object} The dialog instance.
                 */
                moveTo:function(x,y){
                    if(!isNaN(x) && !isNaN(y)){
                        // allow custom `onmove` method
                        dispatchEvent('onmove', this);
                        
                        var element = this.elements.dialog,
                            current = element,
                            offsetLeft = 0,
                            offsetTop = 0;
                        
                        //subtract existing left,top
                        if (element.style.left) {
                            offsetLeft -= parseInt(element.style.left, 10);
                        }
                        if (element.style.top) {
                            offsetTop -= parseInt(element.style.top, 10);
                        }
                        //calc offset
                        do {
                            offsetLeft += current.offsetLeft;
                            offsetTop += current.offsetTop;
                        } while (current = current.offsetParent);

                        //calc left, top
                        var left = (x - offsetLeft);
                        var top  = (y - offsetTop);

                        //// rtl handling
                        if (isRightToLeft()) {
                            left *= -1;
                        }

                        element.style.left = left + 'px';
                        element.style.top = top + 'px';
                        
                        // allow custom `onmoved` method
                        dispatchEvent('onmoved', this);
                    }
                    return this;
                },
                /**
                 * Resize the dialog to a specific width/height (the dialog must be 'resizable').
                 * The dialog can be resized to:
                 *  A minimum width equal to the initial display width
                 *  A minimum height equal to the sum of header/footer heights.
                 *
                 *
                 * @param {Number or String} width    The new dialog width in pixels or in percent.
                 * @param {Number or String} height   The new dialog height in pixels or in percent.
                 *
                 * @return {Object} The dialog instance.
                 */
                resizeTo:function(width,height){
                    var w = parseFloat(width),
                        h = parseFloat(height),
                        regex = /(\d*\.\d+|\d+)%/
                    ;

                    if(!isNaN(w) && !isNaN(h) && this.get('resizable') === true){
                        
                        // allow custom `onresize` method
                        dispatchEvent('onresize', this);
                        
                        if(('' + width).match(regex)){
                            w = w / 100 * document.documentElement.clientWidth ;
                        }

                        if(('' + height).match(regex)){
                            h = h / 100 * document.documentElement.clientHeight;
                        }

                        var element = this.elements.dialog;
                        if (element.style.maxWidth !== 'none') {
                            element.style.minWidth = (minWidth = element.offsetWidth) + 'px';
                        }
                        element.style.maxWidth = 'none';
                        element.style.minHeight = this.elements.header.offsetHeight + this.elements.footer.offsetHeight + 'px';
                        element.style.width = w + 'px';
                        element.style.height = h + 'px';
                        
                        // allow custom `onresized` method
                        dispatchEvent('onresized', this);
                    }
                    return this;
                },
                /**
                 * Gets or Sets dialog settings/options 
                 *
                 * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
                 * @param {Object} value Optional, the value associated with the key (in case it was a string).
                 *
                 * @return {undefined}
                 */
                setting : function (key, value) {
                    var self = this;
                    var result = update(this, this.__internal.options, function(k,o,n){ optionUpdated(self,k,o,n); }, key, value);
                    if(result.op === 'get'){
                        if(result.found){
                            return result.value;
                        }else if(typeof this.settings !== 'undefined'){
                            return update(this, this.settings, this.settingUpdated || function(){}, key, value).value;
                        }else{
                            return undefined;
                        }
                    }else if(result.op === 'set'){
                        if(result.items.length > 0){
                            var callback = this.settingUpdated || function(){};
                            for(var x=0;x<result.items.length;x+=1){
                                var item = result.items[x];
                                if(!item.found && typeof this.settings !== 'undefined'){
                                    update(this, this.settings, callback, item.key, item.value);
                                }
                            }
                        }
                        return this;
                    }
                },
                /**
                 * [Alias] Sets dialog settings/options 
                 */
                set:function(key, value){
                    this.setting(key,value);
                    return this;
                },
                /**
                 * [Alias] Gets dialog settings/options 
                 */
                get:function(key){
                    return this.setting(key);
                },
                /**
                * Sets dialog header
                * @content {string or element}
                *
                * @return {undefined}
                */
                setHeader:function(content){
                    if(typeof content === 'string'){
                        clearContents(this.elements.header);
                        this.elements.header.innerHTML = content;
                    }else if (content instanceof window.HTMLElement && this.elements.header.firstChild !== content){
                        clearContents(this.elements.header);
                        this.elements.header.appendChild(content);
                    }
                    return this;
                },
                /**
                * Sets dialog contents
                * @content {string or element}
                *
                * @return {undefined}
                */
                setContent:function(content){
                    if(typeof content === 'string'){
                        clearContents(this.elements.content);
                        this.elements.content.innerHTML = content;
                    }else if (content instanceof window.HTMLElement && this.elements.content.firstChild !== content){
                        clearContents(this.elements.content);
                        this.elements.content.appendChild(content);
                    }
                    return this;
                },
                /**
                 * Show the dialog as modal
                 *
                 * @return {Object} the dialog instance.
                 */
                showModal: function(className){
                    return this.show(true, className);
                },
                /**
                 * Show the dialog
                 *
                 * @return {Object} the dialog instance.
                 */
                show: function (modal, className) {
                    
                    // ensure initialization
                    initialize(this);

                    if ( !this.__internal.isOpen ) {

                        // add to open dialogs
                        this.__internal.isOpen = true;
                        openDialogs.push(this);

                        // save last focused element
                        if(alertify.defaults.maintainFocus){
                            this.__internal.activeElement = document.activeElement;
                        }

                        // set tabindex attribute on body element this allows script to give it focusable
                        if(!document.body.hasAttribute('tabindex')) {
                            document.body.setAttribute( 'tabindex', tabindex = '0');
                        }

                        //allow custom dom manipulation updates before showing the dialog.
                        if(typeof this.prepare === 'function'){
                            this.prepare();
                        }

                        bindEvents(this);

                        if(modal !== undefined){
                            this.set('modal', modal);
                        }

                        //save scroll to prevent document jump
                        saveScrollPosition();

                        ensureNoOverflow();

                        // allow custom dialog class on show
                        if(typeof className === 'string' && className !== ''){
                            this.__internal.className = className;
                            addClass(this.elements.root, className);
                        }

                        // maximize if start maximized
                        if ( this.get('startMaximized')) {
                            this.maximize();
                        }else if(this.isMaximized()){
                            restore(this);
                        }

                        updateAbsPositionFix(this);

                        removeClass(this.elements.root, classes.animationOut);
                        addClass(this.elements.root, classes.animationIn);

                        // set 1s fallback in case transition event doesn't fire
                        clearTimeout( this.__internal.timerIn);
                        this.__internal.timerIn = setTimeout( this.__internal.transitionInHandler, transition.supported ? 1000 : 100 );

                        if(isSafari){
                            // force desktop safari reflow
                            var root = this.elements.root;
                            root.style.display  = 'none';
                            setTimeout(function(){root.style.display  = 'block';}, 0);
                        }

                        //reflow
                        reflow = this.elements.root.offsetWidth;
                      
                        // show dialog
                        removeClass(this.elements.root, classes.hidden);

                        // internal on show event
                        if(typeof this.hooks.onshow === 'function'){
                            this.hooks.onshow.call(this);
                        }

                        // allow custom `onshow` method
                        dispatchEvent('onshow', this);

                    }else{
                        // reset move updates
                        resetMove(this);
                        // reset resize updates
                        resetResize(this);
                        // shake the dialog to indicate its already open
                        addClass(this.elements.dialog, classes.shake);
                        var self = this;
                        setTimeout(function(){
                            removeClass(self.elements.dialog, classes.shake);
                        },200);
                    }
                    return this;
                },
                /**
                 * Close the dialog
                 *
                 * @return {Object} The dialog instance
                 */
                close: function () {
                    if (this.__internal.isOpen ) {
                        // custom `onclosing` event
                        if(dispatchEvent('onclosing', this) !== false){

                            unbindEvents(this);

                            removeClass(this.elements.root, classes.animationIn);
                            addClass(this.elements.root, classes.animationOut);

                            // set 1s fallback in case transition event doesn't fire
                            clearTimeout( this.__internal.timerOut );
                            this.__internal.timerOut = setTimeout( this.__internal.transitionOutHandler, transition.supported ? 1000 : 100 );
                            // hide dialog
                            addClass(this.elements.root, classes.hidden);
                            //reflow
                            reflow = this.elements.modal.offsetWidth;

                            // remove custom dialog class on hide
                            if (typeof this.__internal.className !== 'undefined' && this.__internal.className !== '') {
                                removeClass(this.elements.root, this.__internal.className);
                            }

                            // internal on close event
                            if(typeof this.hooks.onclose === 'function'){
                                this.hooks.onclose.call(this);
                            }

                            // allow custom `onclose` method
                            dispatchEvent('onclose', this);

                            //remove from open dialogs
                            openDialogs.splice(openDialogs.indexOf(this),1);
                            this.__internal.isOpen = false;

                            ensureNoOverflow();
                        }

                    }
                    // last dialog and tab index was set by us, remove it.
                    if(!openDialogs.length && tabindex === '0'){
                        document.body.removeAttribute('tabindex');
                    }
                    return this;
                },
                /**
                 * Close all open dialogs except this.
                 *
                 * @return {undefined}
                 */
                closeOthers:function(){
                    alertify.closeAll(this);
                    return this;
                },
                /**
                 * Destroys this dialog instance
                 *
                 * @return {undefined}
                 */
                destroy:function(){
                    if (this.__internal.isOpen ) {
                        //mark dialog for destruction, this will be called on tranistionOut event.
                        this.__internal.destroy = function(){
                            destruct(this, initialize);
                        };
                        //close the dialog to unbind all events.
                        this.close();
                    }else{
                        destruct(this, initialize);
                    }
                    return this;
                },
            };
    	} () );
        var notifier = (function () {
            var reflow,
                element,
                openInstances = [],
                classes = {
                    base: 'alertify-notifier',
                    message: 'ajs-message',
                    top: 'ajs-top',
                    right: 'ajs-right',
                    bottom: 'ajs-bottom',
                    left: 'ajs-left',
                    center: 'ajs-center',
                    visible: 'ajs-visible',
                    hidden: 'ajs-hidden',
                    close: 'ajs-close'
                };
            /**
             * Helper: initializes the notifier instance
             *
             */
            function initialize(instance) {

                if (!instance.__internal) {
                    instance.__internal = {
                        position: alertify.defaults.notifier.position,
                        delay: alertify.defaults.notifier.delay,
                    };

                    element = document.createElement('DIV');

                    updatePosition(instance);
                }

                //add to DOM tree.
                if (element.parentNode !== document.body) {
                    document.body.appendChild(element);
                }
            }

            function pushInstance(instance) {
                instance.__internal.pushed = true;
                openInstances.push(instance);
            }
            function popInstance(instance) {
                openInstances.splice(openInstances.indexOf(instance), 1);
                instance.__internal.pushed = false;
            }
            /**
             * Helper: update the notifier instance position
             *
             */
            function updatePosition(instance) {
                element.className = classes.base;
                switch (instance.__internal.position) {
                case 'top-right':
                    addClass(element, classes.top + ' ' + classes.right);
                    break;
                case 'top-left':
                    addClass(element, classes.top + ' ' + classes.left);
                    break;
                case 'top-center':
                    addClass(element, classes.top + ' ' + classes.center);
                    break;
                case 'bottom-left':
                    addClass(element, classes.bottom + ' ' + classes.left);
                    break;
                case 'bottom-center':
                    addClass(element, classes.bottom + ' ' + classes.center);
                    break;

                default:
                case 'bottom-right':
                    addClass(element, classes.bottom + ' ' + classes.right);
                    break;
                }
            }

            /**
            * creates a new notification message
            *
            * @param  {DOMElement} message	The notifier message element
            * @param  {Number} wait   Time (in ms) to wait before the message is dismissed, a value of 0 means keep open till clicked.
            * @param  {Function} callback A callback function to be invoked when the message is dismissed.
            *
            * @return {undefined}
            */
            function create(div, callback) {

                function clickDelegate(event, instance) {
                    if(!instance.__internal.closeButton || event.target.getAttribute('data-close') === 'true'){
                        instance.dismiss(true);
                    }
                }

                function transitionDone(event, instance) {
                    // unbind event
                    off(instance.element, transition.type, transitionDone);
                    // remove the message
                    element.removeChild(instance.element);
                }

                function initialize(instance) {
                    if (!instance.__internal) {
                        instance.__internal = {
                            pushed: false,
                            delay : undefined,
                            timer: undefined,
                            clickHandler: undefined,
                            transitionEndHandler: undefined,
                            transitionTimeout: undefined
                        };
                        instance.__internal.clickHandler = delegate(instance, clickDelegate);
                        instance.__internal.transitionEndHandler = delegate(instance, transitionDone);
                    }
                    return instance;
                }
                function clearTimers(instance) {
                    clearTimeout(instance.__internal.timer);
                    clearTimeout(instance.__internal.transitionTimeout);
                }
                return initialize({
                    /* notification DOM element*/
                    element: div,
                    /*
                     * Pushes a notification message
                     * @param {string or DOMElement} content The notification message content
                     * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
                     *
                     */
                    push: function (_content, _wait) {
                        if (!this.__internal.pushed) {

                            pushInstance(this);
                            clearTimers(this);

                            var content, wait;
                            switch (arguments.length) {
                            case 0:
                                wait = this.__internal.delay;
                                break;
                            case 1:
                                if (typeof (_content) === 'number') {
                                    wait = _content;
                                } else {
                                    content = _content;
                                    wait = this.__internal.delay;
                                }
                                break;
                            case 2:
                                content = _content;
                                wait = _wait;
                                break;
                            }
                            this.__internal.closeButton = alertify.defaults.notifier.closeButton;
                            // set contents
                            if (typeof content !== 'undefined') {
                                this.setContent(content);
                            }
                            // append or insert
                            if (notifier.__internal.position.indexOf('top') < 0) {
                                element.appendChild(this.element);
                            } else {
                                element.insertBefore(this.element, element.firstChild);
                            }
                            reflow = this.element.offsetWidth;
                            addClass(this.element, classes.visible);
                            // attach click event
                            on(this.element, 'click', this.__internal.clickHandler);
                            return this.delay(wait);
                        }
                        return this;
                    },
                    /*
                     * {Function} callback function to be invoked before dismissing the notification message.
                     * Remarks: A return value === 'false' will cancel the dismissal
                     *
                     */
                    ondismiss: function () { },
                    /*
                     * {Function} callback function to be invoked when the message is dismissed.
                     *
                     */
                    callback: callback,
                    /*
                     * Dismisses the notification message
                     * @param {Boolean} clicked A flag indicating if the dismissal was caused by a click.
                     *
                     */
                    dismiss: function (clicked) {
                        if (this.__internal.pushed) {
                            clearTimers(this);
                            if (!(typeof this.ondismiss === 'function' && this.ondismiss.call(this) === false)) {
                                //detach click event
                                off(this.element, 'click', this.__internal.clickHandler);
                                // ensure element exists
                                if (typeof this.element !== 'undefined' && this.element.parentNode === element) {
                                    //transition end or fallback
                                    this.__internal.transitionTimeout = setTimeout(this.__internal.transitionEndHandler, transition.supported ? 1000 : 100);
                                    removeClass(this.element, classes.visible);

                                    // custom callback on dismiss
                                    if (typeof this.callback === 'function') {
                                        this.callback.call(this, clicked);
                                    }
                                }
                                popInstance(this);
                            }
                        }
                        return this;
                    },
                    /*
                     * Delays the notification message dismissal
                     * @param {Number} wait The time (in seconds) to wait before the message is dismissed, a value of 0 means keep open till clicked.
                     *
                     */
                    delay: function (wait) {
                        clearTimers(this);
                        this.__internal.delay = typeof wait !== 'undefined' && !isNaN(+wait) ? +wait : notifier.__internal.delay;
                        if (this.__internal.delay > 0) {
                            var  self = this;
                            this.__internal.timer = setTimeout(function () { self.dismiss(); }, this.__internal.delay * 1000);
                        }
                        return this;
                    },
                    /*
                     * Sets the notification message contents
                     * @param {string or DOMElement} content The notification message content
                     *
                     */
                    setContent: function (content) {
                        if (typeof content === 'string') {
                            clearContents(this.element);
                            this.element.innerHTML = content;
                        } else if (content instanceof window.HTMLElement && this.element.firstChild !== content) {
                            clearContents(this.element);
                            this.element.appendChild(content);
                        }
                        if(this.__internal.closeButton){
                            var close = document.createElement('span');
                            addClass(close, classes.close);
                            close.setAttribute('data-close', true);
                            this.element.appendChild(close);
                        }
                        return this;
                    },
                    /*
                     * Dismisses all open notifications except this.
                     *
                     */
                    dismissOthers: function () {
                        notifier.dismissAll(this);
                        return this;
                    }
                });
            }

            //notifier api
            return {
                /**
                 * Gets or Sets notifier settings.
                 *
                 * @param {string} key The setting name
                 * @param {Variant} value The setting value.
                 *
                 * @return {Object}	if the called as a setter, return the notifier instance.
                 */
                setting: function (key, value) {
                    //ensure init
                    initialize(this);

                    if (typeof value === 'undefined') {
                        //get
                        return this.__internal[key];
                    } else {
                        //set
                        switch (key) {
                        case 'position':
                            this.__internal.position = value;
                            updatePosition(this);
                            break;
                        case 'delay':
                            this.__internal.delay = value;
                            break;
                        }
                    }
                    return this;
                },
                /**
                 * [Alias] Sets dialog settings/options
                 */
                set:function(key,value){
                    this.setting(key,value);
                    return this;
                },
                /**
                 * [Alias] Gets dialog settings/options
                 */
                get:function(key){
                    return this.setting(key);
                },
                /**
                 * Creates a new notification message
                 *
                 * @param {string} type The type of notification message (simply a CSS class name 'ajs-{type}' to be added).
                 * @param {Function} callback  A callback function to be invoked when the message is dismissed.
                 *
                 * @return {undefined}
                 */
                create: function (type, callback) {
                    //ensure notifier init
                    initialize(this);
                    //create new notification message
                    var div = document.createElement('div');
                    div.className = classes.message + ((typeof type === 'string' && type !== '') ? ' ajs-' + type : '');
                    return create(div, callback);
                },
                /**
                 * Dismisses all open notifications.
                 *
                 * @param {Object} excpet [optional] The notification object to exclude from dismissal.
                 *
                 */
                dismissAll: function (except) {
                    var clone = openInstances.slice(0);
                    for (var x = 0; x < clone.length; x += 1) {
                        var  instance = clone[x];
                        if (except === undefined || except !== instance) {
                            instance.dismiss();
                        }
                    }
                }
            };
        })();

        /**
         * Alertify public API
         * This contains everything that is exposed through the alertify object.
         *
         * @return {Object}
         */
        function Alertify() {

            // holds a references of created dialogs
            var dialogs = {};

            /**
             * Extends a given prototype by merging properties from base into sub.
             *
             * @sub {Object} sub The prototype being overwritten.
             * @base {Object} base The prototype being written.
             *
             * @return {Object} The extended prototype.
             */
            function extend(sub, base) {
                // copy dialog pototype over definition.
                for (var prop in base) {
                    if (base.hasOwnProperty(prop)) {
                        sub[prop] = base[prop];
                    }
                }
                return sub;
            }


            /**
            * Helper: returns a dialog instance from saved dialogs.
            * and initializes the dialog if its not already initialized.
            *
            * @name {String} name The dialog name.
            *
            * @return {Object} The dialog instance.
            */
            function get_dialog(name) {
                var dialog = dialogs[name].dialog;
                //initialize the dialog if its not already initialized.
                if (dialog && typeof dialog.__init === 'function') {
                    dialog.__init(dialog);
                }
                return dialog;
            }

            /**
             * Helper:  registers a new dialog definition.
             *
             * @name {String} name The dialog name.
             * @Factory {Function} Factory a function resposible for creating dialog prototype.
             * @transient {Boolean} transient True to create a new dialog instance each time the dialog is invoked, false otherwise.
             * @base {String} base the name of another dialog to inherit from.
             *
             * @return {Object} The dialog definition.
             */
            function register(name, Factory, transient, base) {
                var definition = {
                    dialog: null,
                    factory: Factory
                };

                //if this is based on an existing dialog, create a new definition
                //by applying the new protoype over the existing one.
                if (base !== undefined) {
                    definition.factory = function () {
                        return extend(new dialogs[base].factory(), new Factory());
                    };
                }

                if (!transient) {
                    //create a new definition based on dialog
                    definition.dialog = extend(new definition.factory(), dialog);
                }
                return dialogs[name] = definition;
            }

            return {
                /**
                 * Alertify defaults
                 * 
                 * @type {Object}
                 */
                defaults: defaults,
                /**
                 * Dialogs factory 
                 *
                 * @param {string}      Dialog name.
                 * @param {Function}    A Dialog factory function.
                 * @param {Boolean}     Indicates whether to create a singleton or transient dialog.
                 * @param {String}      The name of the base type to inherit from.
                 */
                dialog: function (name, Factory, transient, base) {

                    // get request, create a new instance and return it.
                    if (typeof Factory !== 'function') {
                        return get_dialog(name);
                    }

                    if (this.hasOwnProperty(name)) {
                        throw new Error('alertify.dialog: name already exists');
                    }

                    // register the dialog
                    var definition = register(name, Factory, transient, base);

                    if (transient) {

                        // make it public
                        this[name] = function () {
                            //if passed with no params, consider it a get request
                            if (arguments.length === 0) {
                                return definition.dialog;
                            } else {
                                var instance = extend(new definition.factory(), dialog);
                                //ensure init
                                if (instance && typeof instance.__init === 'function') {
                                    instance.__init(instance);
                                }
                                instance['main'].apply(instance, arguments);
                                return instance['show'].apply(instance);
                            }
                        };
                    } else {
                        // make it public
                        this[name] = function () {
                            //ensure init
                            if (definition.dialog && typeof definition.dialog.__init === 'function') {
                                definition.dialog.__init(definition.dialog);
                            }
                            //if passed with no params, consider it a get request
                            if (arguments.length === 0) {
                                return definition.dialog;
                            } else {
                                var dialog = definition.dialog;
                                dialog['main'].apply(definition.dialog, arguments);
                                return dialog['show'].apply(definition.dialog);
                            }
                        };
                    }
                },
                /**
                 * Close all open dialogs.
                 *
                 * @param {Object} excpet [optional] The dialog object to exclude from closing.
                 *
                 * @return {undefined}
                 */
                closeAll: function (except) {
                    var clone = openDialogs.slice(0);
                    for (var x = 0; x < clone.length; x += 1) {
                        var instance = clone[x];
                        if (except === undefined || except !== instance) {
                            instance.close();
                        }
                    }
                },
                /**
                 * Gets or Sets dialog settings/options. if the dialog is transient, this call does nothing.
                 *
                 * @param {string} name The dialog name.
                 * @param {String|Object} key A string specifying a propery name or a collection of key/value pairs.
                 * @param {Variant} value Optional, the value associated with the key (in case it was a string).
                 *
                 * @return {undefined}
                 */
                setting: function (name, key, value) {

                    if (name === 'notifier') {
                        return notifier.setting(key, value);
                    }

                    var dialog = get_dialog(name);
                    if (dialog) {
                        return dialog.setting(key, value);
                    }
                },
                /**
                 * [Alias] Sets dialog settings/options 
                 */
                set: function(name,key,value){
                    return this.setting(name, key,value);
                },
                /**
                 * [Alias] Gets dialog settings/options 
                 */
                get: function(name, key){
                    return this.setting(name, key);
                },
                /**
                 * Creates a new notification message.
                 * If a type is passed, a class name "ajs-{type}" will be added.
                 * This allows for custom look and feel for various types of notifications.
                 *
                 * @param  {String | DOMElement}    [message=undefined]		Message text
                 * @param  {String}                 [type='']				Type of log message
                 * @param  {String}                 [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}               [callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                notify: function (message, type, wait, callback) {
                    return notifier.create(type, callback).push(message, wait);
                },
                /**
                 * Creates a new notification message.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                message: function (message, wait, callback) {
                    return notifier.create(null, callback).push(message, wait);
                },
                /**
                 * Creates a new notification message of type 'success'.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                success: function (message, wait, callback) {
                    return notifier.create('success', callback).push(message, wait);
                },
                /**
                 * Creates a new notification message of type 'error'.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                error: function (message, wait, callback) {
                    return notifier.create('error', callback).push(message, wait);
                },
                /**
                 * Creates a new notification message of type 'warning'.
                 *
                 * @param  {String}		[message=undefined]		Message text
                 * @param  {String}     [wait='']				Time (in seconds) to wait before auto-close
                 * @param  {Function}	[callback=undefined]	A callback function to be invoked when the log is closed.
                 *
                 * @return {Object} Notification object.
                 */
                warning: function (message, wait, callback) {
                    return notifier.create('warning', callback).push(message, wait);
                },
                /**
                 * Dismisses all open notifications
                 *
                 * @return {undefined}
                 */
                dismissAll: function () {
                    notifier.dismissAll();
                }
            };
        }
        var alertify = new Alertify();

        /**
        * Alert dialog definition
        *
        * invoked by:
        *	alertify.alert(message);
        *	alertify.alert(title, message);
        *	alertify.alert(message, onok);
        *	alertify.alert(title, message, onok);
         */
        alertify.dialog('alert', function () {
            return {
                main: function (_title, _message, _onok) {
                    var title, message, onok;
                    switch (arguments.length) {
                    case 1:
                        message = _title;
                        break;
                    case 2:
                        if (typeof _message === 'function') {
                            message = _title;
                            onok = _message;
                        } else {
                            title = _title;
                            message = _message;
                        }
                        break;
                    case 3:
                        title = _title;
                        message = _message;
                        onok = _onok;
                        break;
                    }
                    this.set('title', title);
                    this.set('message', message);
                    this.set('onok', onok);
                    return this;
                },
                setup: function () {
                    return {
                        buttons: [
                            {
                                text: alertify.defaults.glossary.ok,
                                key: keys.ESC,
                                invokeOnClose: true,
                                className: alertify.defaults.theme.ok,
                            }
                        ],
                        focus: {
                            element: 0,
                            select: false
                        },
                        options: {
                            maximizable: false,
                            resizable: false
                        }
                    };
                },
                build: function () {
                    // nothing
                },
                prepare: function () {
                    //nothing
                },
                setMessage: function (message) {
                    this.setContent(message);
                },
                settings: {
                    message: undefined,
                    onok: undefined,
                    label: undefined,
                },
                settingUpdated: function (key, oldValue, newValue) {
                    switch (key) {
                    case 'message':
                        this.setMessage(newValue);
                        break;
                    case 'label':
                        if (this.__internal.buttons[0].element) {
                            this.__internal.buttons[0].element.innerHTML = newValue;
                        }
                        break;
                    }
                },
                callback: function (closeEvent) {
                    if (typeof this.get('onok') === 'function') {
                        var returnValue = this.get('onok').call(this, closeEvent);
                        if (typeof returnValue !== 'undefined') {
                            closeEvent.cancel = !returnValue;
                        }
                    }
                }
            };
        });
        /**
         * Confirm dialog object
         *
         *	alertify.confirm(message);
         *	alertify.confirm(message, onok);
         *	alertify.confirm(message, onok, oncancel);
         *	alertify.confirm(title, message, onok, oncancel);
         */
        alertify.dialog('confirm', function () {

            var autoConfirm = {
                timer: null,
                index: null,
                text: null,
                duration: null,
                task: function (event, self) {
                    if (self.isOpen()) {
                        self.__internal.buttons[autoConfirm.index].element.innerHTML = autoConfirm.text + ' (&#8207;' + autoConfirm.duration + '&#8207;) ';
                        autoConfirm.duration -= 1;
                        if (autoConfirm.duration === -1) {
                            clearAutoConfirm(self);
                            var button = self.__internal.buttons[autoConfirm.index];
                            var closeEvent = createCloseEvent(autoConfirm.index, button);

                            if (typeof self.callback === 'function') {
                                self.callback.apply(self, [closeEvent]);
                            }
                            //close the dialog.
                            if (closeEvent.close !== false) {
                                self.close();
                            }
                        }
                    } else {
                        clearAutoConfirm(self);
                    }
                }
            };

            function clearAutoConfirm(self) {
                if (autoConfirm.timer !== null) {
                    clearInterval(autoConfirm.timer);
                    autoConfirm.timer = null;
                    self.__internal.buttons[autoConfirm.index].element.innerHTML = autoConfirm.text;
                }
            }

            function startAutoConfirm(self, index, duration) {
                clearAutoConfirm(self);
                autoConfirm.duration = duration;
                autoConfirm.index = index;
                autoConfirm.text = self.__internal.buttons[index].element.innerHTML;
                autoConfirm.timer = setInterval(delegate(self, autoConfirm.task), 1000);
                autoConfirm.task(null, self);
            }


            return {
                main: function (_title, _message, _onok, _oncancel) {
                    var title, message, onok, oncancel;
                    switch (arguments.length) {
                    case 1:
                        message = _title;
                        break;
                    case 2:
                        message = _title;
                        onok = _message;
                        break;
                    case 3:
                        message = _title;
                        onok = _message;
                        oncancel = _onok;
                        break;
                    case 4:
                        title = _title;
                        message = _message;
                        onok = _onok;
                        oncancel = _oncancel;
                        break;
                    }
                    this.set('title', title);
                    this.set('message', message);
                    this.set('onok', onok);
                    this.set('oncancel', oncancel);
                    return this;
                },
                setup: function () {
                    return {
                        buttons: [
                            {
                                text: alertify.defaults.glossary.ok,
                                key: keys.ENTER,
                                className: alertify.defaults.theme.ok,
                            },
                            {
                                text: alertify.defaults.glossary.cancel,
                                key: keys.ESC,
                                invokeOnClose: true,
                                className: alertify.defaults.theme.cancel,
                            }
                        ],
                        focus: {
                            element: 0,
                            select: false
                        },
                        options: {
                            maximizable: false,
                            resizable: false
                        }
                    };
                },
                build: function () {
                    //nothing
                },
                prepare: function () {
                    //nothing
                },
                setMessage: function (message) {
                    this.setContent(message);
                },
                settings: {
                    message: null,
                    labels: null,
                    onok: null,
                    oncancel: null,
                    defaultFocus: null,
                    reverseButtons: null,
                },
                settingUpdated: function (key, oldValue, newValue) {
                    switch (key) {
                    case 'message':
                        this.setMessage(newValue);
                        break;
                    case 'labels':
                        if ('ok' in newValue && this.__internal.buttons[0].element) {
                            this.__internal.buttons[0].text = newValue.ok;
                            this.__internal.buttons[0].element.innerHTML = newValue.ok;
                        }
                        if ('cancel' in newValue && this.__internal.buttons[1].element) {
                            this.__internal.buttons[1].text = newValue.cancel;
                            this.__internal.buttons[1].element.innerHTML = newValue.cancel;
                        }
                        break;
                    case 'reverseButtons':
                        if (newValue === true) {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[0].element);
                        } else {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[1].element);
                        }
                        break;
                    case 'defaultFocus':
                        this.__internal.focus.element = newValue === 'ok' ? 0 : 1;
                        break;
                    }
                },
                callback: function (closeEvent) {
                    clearAutoConfirm(this);
                    var returnValue;
                    switch (closeEvent.index) {
                    case 0:
                        if (typeof this.get('onok') === 'function') {
                            returnValue = this.get('onok').call(this, closeEvent);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        break;
                    case 1:
                        if (typeof this.get('oncancel') === 'function') {
                            returnValue = this.get('oncancel').call(this, closeEvent);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        break;
                    }
                },
                autoOk: function (duration) {
                    startAutoConfirm(this, 0, duration);
                    return this;
                },
                autoCancel: function (duration) {
                    startAutoConfirm(this, 1, duration);
                    return this;
                }
            };
        });
        /**
         * Prompt dialog object
         *
         * invoked by:
         *	alertify.prompt(message);
         *	alertify.prompt(message, value);
         *	alertify.prompt(message, value, onok);
         *	alertify.prompt(message, value, onok, oncancel);
         *	alertify.prompt(title, message, value, onok, oncancel);
         */
        alertify.dialog('prompt', function () {
            var input = document.createElement('INPUT');
            var p = document.createElement('P');
            return {
                main: function (_title, _message, _value, _onok, _oncancel) {
                    var title, message, value, onok, oncancel;
                    switch (arguments.length) {
                    case 1:
                        message = _title;
                        break;
                    case 2:
                        message = _title;
                        value = _message;
                        break;
                    case 3:
                        message = _title;
                        value = _message;
                        onok = _value;
                        break;
                    case 4:
                        message = _title;
                        value = _message;
                        onok = _value;
                        oncancel = _onok;
                        break;
                    case 5:
                        title = _title;
                        message = _message;
                        value = _value;
                        onok = _onok;
                        oncancel = _oncancel;
                        break;
                    }
                    this.set('title', title);
                    this.set('message', message);
                    this.set('value', value);
                    this.set('onok', onok);
                    this.set('oncancel', oncancel);
                    return this;
                },
                setup: function () {
                    return {
                        buttons: [
                            {
                                text: alertify.defaults.glossary.ok,
                                key: keys.ENTER,
                                className: alertify.defaults.theme.ok,
                            },
                            {
                                text: alertify.defaults.glossary.cancel,
                                key: keys.ESC,
                                invokeOnClose: true,
                                className: alertify.defaults.theme.cancel,
                            }
                        ],
                        focus: {
                            element: input,
                            select: true
                        },
                        options: {
                            maximizable: false,
                            resizable: false
                        }
                    };
                },
                build: function () {
                    input.className = alertify.defaults.theme.input;
                    input.setAttribute('type', 'text');
                    input.value = this.get('value');
                    this.elements.content.appendChild(p);
                    this.elements.content.appendChild(input);
                },
                prepare: function () {
                    //nothing
                },
                setMessage: function (message) {
                    if (typeof message === 'string') {
                        clearContents(p);
                        p.innerHTML = message;
                    } else if (message instanceof window.HTMLElement && p.firstChild !== message) {
                        clearContents(p);
                        p.appendChild(message);
                    }
                },
                settings: {
                    message: undefined,
                    labels: undefined,
                    onok: undefined,
                    oncancel: undefined,
                    value: '',
                    type:'text',
                    reverseButtons: undefined,
                },
                settingUpdated: function (key, oldValue, newValue) {
                    switch (key) {
                    case 'message':
                        this.setMessage(newValue);
                        break;
                    case 'value':
                        input.value = newValue;
                        break;
                    case 'type':
                        switch (newValue) {
                        case 'text':
                        case 'color':
                        case 'date':
                        case 'datetime-local':
                        case 'email':
                        case 'month':
                        case 'number':
                        case 'password':
                        case 'search':
                        case 'tel':
                        case 'time':
                        case 'week':
                            input.type = newValue;
                            break;
                        default:
                            input.type = 'text';
                            break;
                        }
                        break;
                    case 'labels':
                        if (newValue.ok && this.__internal.buttons[0].element) {
                            this.__internal.buttons[0].element.innerHTML = newValue.ok;
                        }
                        if (newValue.cancel && this.__internal.buttons[1].element) {
                            this.__internal.buttons[1].element.innerHTML = newValue.cancel;
                        }
                        break;
                    case 'reverseButtons':
                        if (newValue === true) {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[0].element);
                        } else {
                            this.elements.buttons.primary.appendChild(this.__internal.buttons[1].element);
                        }
                        break;
                    }
                },
                callback: function (closeEvent) {
                    var returnValue;
                    switch (closeEvent.index) {
                    case 0:
                        this.settings.value = input.value;
                        if (typeof this.get('onok') === 'function') {
                            returnValue = this.get('onok').call(this, closeEvent, this.settings.value);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        break;
                    case 1:
                        if (typeof this.get('oncancel') === 'function') {
                            returnValue = this.get('oncancel').call(this, closeEvent);
                            if (typeof returnValue !== 'undefined') {
                                closeEvent.cancel = !returnValue;
                            }
                        }
                        if(!closeEvent.cancel){
                            input.value = this.settings.value;
                        }
                        break;
                    }
                }
            };
        });

        // CommonJS
        {
            module.exports = alertify;
        // AMD
        }

    } ( typeof window !== 'undefined' ? window : commonjsGlobal ) );
    });

    function noop() {}

    function assign(tar, src) {
    	for (var k in src) tar[k] = src[k];
    	return tar;
    }

    function assignTrue(tar, src) {
    	for (var k in src) tar[k] = 1;
    	return tar;
    }

    function addLoc(element, file, line, column, char) {
    	element.__svelte_meta = {
    		loc: { file, line, column, char }
    	};
    }

    function appendNode(node, target) {
    	target.appendChild(node);
    }

    function insertNode(node, target, anchor) {
    	target.insertBefore(node, anchor);
    }

    function detachNode(node) {
    	node.parentNode.removeChild(node);
    }

    function detachBetween(before, after) {
    	while (before.nextSibling && before.nextSibling !== after) {
    		before.parentNode.removeChild(before.nextSibling);
    	}
    }

    function detachBefore(after) {
    	while (after.previousSibling) {
    		after.parentNode.removeChild(after.previousSibling);
    	}
    }

    function destroyEach(iterations, detach) {
    	for (var i = 0; i < iterations.length; i += 1) {
    		if (iterations[i]) iterations[i].d(detach);
    	}
    }

    function createElement(name) {
    	return document.createElement(name);
    }

    function createText(data) {
    	return document.createTextNode(data);
    }

    function createComment() {
    	return document.createComment('');
    }

    function addListener(node, event, handler) {
    	node.addEventListener(event, handler, false);
    }

    function removeListener(node, event, handler) {
    	node.removeEventListener(event, handler, false);
    }

    function setAttribute(node, attribute, value) {
    	node.setAttribute(attribute, value);
    }

    function toNumber(value) {
    	return value === '' ? undefined : +value;
    }

    function selectOption(select, value) {
    	for (var i = 0; i < select.options.length; i += 1) {
    		var option = select.options[i];

    		if (option.__value === value) {
    			option.selected = true;
    			return;
    		}
    	}
    }

    function selectValue(select) {
    	var selectedOption = select.querySelector(':checked') || select.options[0];
    	return selectedOption && selectedOption.__value;
    }

    function blankObject() {
    	return Object.create(null);
    }

    function destroy(detach) {
    	this.destroy = noop;
    	this.fire('destroy');
    	this.set = noop;

    	this._fragment.d(detach !== false);
    	this._fragment = null;
    	this._state = {};
    }

    function destroyDev(detach) {
    	destroy.call(this, detach);
    	this.destroy = function() {
    		console.warn('Component was already destroyed');
    	};
    }

    function _differs(a, b) {
    	return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }

    function fire(eventName, data) {
    	var handlers =
    		eventName in this._handlers && this._handlers[eventName].slice();
    	if (!handlers) return;

    	for (var i = 0; i < handlers.length; i += 1) {
    		var handler = handlers[i];

    		if (!handler.__calling) {
    			try {
    				handler.__calling = true;
    				handler.call(this, data);
    			} finally {
    				handler.__calling = false;
    			}
    		}
    	}
    }

    function get() {
    	return this._state;
    }

    function init(component, options) {
    	component._handlers = blankObject();
    	component._bind = options._bind;

    	component.options = options;
    	component.root = options.root || component;
    	component.store = options.store || component.root.store;
    }

    function on(eventName, handler) {
    	var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
    	handlers.push(handler);

    	return {
    		cancel: function() {
    			var index = handlers.indexOf(handler);
    			if (~index) handlers.splice(index, 1);
    		}
    	};
    }

    function set(newState) {
    	this._set(assign({}, newState));
    	if (this.root._lock) return;
    	this.root._lock = true;
    	callAll(this.root._beforecreate);
    	callAll(this.root._oncreate);
    	callAll(this.root._aftercreate);
    	this.root._lock = false;
    }

    function _set(newState) {
    	var oldState = this._state,
    		changed = {},
    		dirty = false;

    	for (var key in newState) {
    		if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
    	}
    	if (!dirty) return;

    	this._state = assign(assign({}, oldState), newState);
    	this._recompute(changed, this._state);
    	if (this._bind) this._bind(changed, this._state);

    	if (this._fragment) {
    		this.fire("state", { changed: changed, current: this._state, previous: oldState });
    		this._fragment.p(changed, this._state);
    		this.fire("update", { changed: changed, current: this._state, previous: oldState });
    	}
    }

    function setDev(newState) {
    	if (typeof newState !== 'object') {
    		throw new Error(
    			this._debugName + '.set was called without an object of data key-values to update.'
    		);
    	}

    	this._checkReadOnly(newState);
    	set.call(this, newState);
    }

    function callAll(fns) {
    	while (fns && fns.length) fns.shift()();
    }

    function _mount(target, anchor) {
    	this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
    }

    var protoDev = {
    	destroy: destroyDev,
    	get,
    	fire,
    	on,
    	set: setDev,
    	_recompute: noop,
    	_set,
    	_mount,
    	_differs
    };

    /* src\core\ui\outputs\MyFormLink.html generated by Svelte v2.9.5 */

    const file = "src\\core\\ui\\outputs\\MyFormLink.html";

    function create_main_fragment(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (2:1) {#if field.data.form != null}
    function create_if_block_1(component, ctx) {
    	var a, text_value = ctx.field.data.label, text, a_href_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues);
    			addLoc(a, file, 2, 2, 60);
    		},

    		m: function mount(target, anchor) {
    			insertNode(a, target, anchor);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.label)) {
    				text.data = text_value;
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues))) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    // (4:1) {:else}
    function create_if_block_2(component, ctx) {
    	var span, text_value = ctx.field.data.label, text;

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(text_value);
    			addLoc(span, file, 4, 2, 166);
    		},

    		m: function mount(target, anchor) {
    			insertNode(span, target, anchor);
    			appendNode(text, span);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.field.data.form != null) return create_if_block_1;
    		return create_if_block_2;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    function SvelteComponent(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	this._fragment = create_main_fragment(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent.prototype, protoDev);

    SvelteComponent.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\components\MenuItem.html generated by Svelte v2.9.5 */

    let id = 0;
    function data() {
    	id += 1;
    	return {
    		id,
    		field: null,
    		app: null
    	};
    }
    function oncreate() {
    	const { item } = this.get();

    	this.set({
    		field: { data: item },
    		app: window.app
    	});

    	console.log(this.get().field);
    }
    const file$1 = "src\\components\\MenuItem.html";

    function create_main_fragment$1(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field != null) && create_if_block$1(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$1(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (3:2) {#if item.form != null}
    function create_if_block_2$1(component, ctx) {

    	var myformlink_initial_data = { field: ctx.field, app: ctx.app };
    	var myformlink = new SvelteComponent({
    		root: component.root,
    		store: component.store,
    		data: myformlink_initial_data
    	});

    	return {
    		c: function create() {
    			myformlink._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			myformlink._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var myformlink_changes = {};
    			if (changed.field) myformlink_changes.field = ctx.field;
    			if (changed.app) myformlink_changes.app = ctx.app;
    			myformlink._set(myformlink_changes);
    		},

    		d: function destroy$$1(detach) {
    			myformlink.destroy(detach);
    		}
    	};
    }

    // (5:2) {:else}
    function create_if_block_3(component, ctx) {
    	var span, text_value = ctx.item.label, text;

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(text_value);
    			addLoc(span, file$1, 5, 2, 141);
    		},

    		m: function mount(target, anchor) {
    			insertNode(span, target, anchor);
    			appendNode(text, span);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.item) && text_value !== (text_value = ctx.item.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (10:3) {#if item.children.length > 1}
    function create_if_block_5(component, ctx) {
    	var label, text_value = ctx.item.label, text, label_for_value;

    	return {
    		c: function create() {
    			label = createElement("label");
    			text = createText(text_value);
    			label.htmlFor = label_for_value = "menu" + ctx.id;
    			label.className = "toggle-sub";
    			setAttribute(label, "onclick", "");
    			addLoc(label, file$1, 10, 3, 260);
    		},

    		m: function mount(target, anchor) {
    			insertNode(label, target, anchor);
    			appendNode(text, label);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.item) && text_value !== (text_value = ctx.item.label)) {
    				text.data = text_value;
    			}

    			if ((changed.id) && label_for_value !== (label_for_value = "menu" + ctx.id)) {
    				label.htmlFor = label_for_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(label);
    			}
    		}
    	};
    }

    // (12:3) {:else}
    function create_if_block_6(component, ctx) {

    	return {
    		c: noop,

    		m: noop,

    		p: noop,

    		d: noop
    	};
    }

    // (20:3) {#each item.children as child}
    function create_each_block(component, ctx) {
    	var li;

    	var sveltecomponent_initial_data = { item: ctx.child, menu: ctx.menu };
    	var sveltecomponent = new SvelteComponent$1({
    		root: component.root,
    		store: component.store,
    		data: sveltecomponent_initial_data
    	});

    	return {
    		c: function create() {
    			li = createElement("li");
    			sveltecomponent._fragment.c();
    			addLoc(li, file$1, 20, 3, 614);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			sveltecomponent._mount(li, null);
    		},

    		p: function update(changed, ctx) {
    			var sveltecomponent_changes = {};
    			if (changed.item) sveltecomponent_changes.item = ctx.child;
    			if (changed.menu) sveltecomponent_changes.menu = ctx.menu;
    			sveltecomponent._set(sveltecomponent_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			sveltecomponent.destroy();
    		}
    	};
    }

    // (18:2) {#if item.children.length > 1}
    function create_if_block_7(component, ctx) {
    	var ul;

    	var each_value = ctx.item.children;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			ul.className = "sub-nav";
    			addLoc(ul, file$1, 18, 2, 554);
    		},

    		m: function mount(target, anchor) {
    			insertNode(ul, target, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.item || changed.menu) {
    				each_value = ctx.item.children;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (2:1) {#if item.children.length === 0}
    function create_if_block_1$1(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.item.form != null) return create_if_block_2$1;
    		return create_if_block_3;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (8:1) {:else}
    function create_if_block_4(component, ctx) {
    	var div, text_1, input, input_id_value, text_2, if_block_1_anchor;

    	function select_block_type_1(ctx) {
    		if (ctx.item.children.length > 1) return create_if_block_5;
    		return create_if_block_6;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	var if_block_1 = (ctx.item.children.length > 1) && create_if_block_7(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if_block.c();
    			text_1 = createText("\r\n\r\n\t\t");
    			input = createElement("input");
    			text_2 = createText("\r\n\t\t");
    			if (if_block_1) if_block_1.c();
    			if_block_1_anchor = createComment();
    			div.className = "menu top-menu-div";
    			addLoc(div, file$1, 8, 2, 189);
    			setAttribute(input, "type", "checkbox");
    			input.id = input_id_value = "menu" + ctx.id;
    			input.className = "sub-nav-check";
    			addLoc(input, file$1, 16, 2, 455);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			if_block.m(div, null);
    			insertNode(text_1, target, anchor);
    			insertNode(input, target, anchor);
    			insertNode(text_2, target, anchor);
    			if (if_block_1) if_block_1.m(target, anchor);
    			insertNode(if_block_1_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(div, null);
    			}

    			if ((changed.id) && input_id_value !== (input_id_value = "menu" + ctx.id)) {
    				input.id = input_id_value;
    			}

    			if (ctx.item.children.length > 1) {
    				if (if_block_1) {
    					if_block_1.p(changed, ctx);
    				} else {
    					if_block_1 = create_if_block_7(component, ctx);
    					if_block_1.c();
    					if_block_1.m(if_block_1_anchor.parentNode, if_block_1_anchor);
    				}
    			} else if (if_block_1) {
    				if_block_1.d(1);
    				if_block_1 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if_block.d();
    			if (detach) {
    				detachNode(text_1);
    				detachNode(input);
    				detachNode(text_2);
    			}

    			if (if_block_1) if_block_1.d(detach);
    			if (detach) {
    				detachNode(if_block_1_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field != null}
    function create_if_block$1(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_2(ctx) {
    		if (ctx.item.children.length === 0) return create_if_block_1$1;
    		return create_if_block_4;
    	}

    	var current_block_type = select_block_type_2(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.child = list[i];
    	child_ctx.each_value = list;
    	child_ctx.child_index = i;
    	return child_ctx;
    }

    function SvelteComponent$1(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign(data(), options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('item' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'item'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('menu' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'menu'");
    	this._intro = true;

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$1(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$1.prototype, protoDev);

    SvelteComponent$1.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\components\Menu.html generated by Svelte v2.9.5 */

    // function nestedSort(array, comparison) {
    // 	array.sort(comparison);

    // 	for (const item of array) {
    // 		if (item.items != null) {
    // 			nestedSort(item.items, comparison);
    // 		}
    // 	}
    // }

    function data$1() {
    	return {
    		menu: null
    	};
    }
    function oncreate$1() {
    	console.log(this.get().menu);
    	this.set({ self: this });
    	// const getMenuGroup = this.get().getMenuGroup;
    	// const makeUrl = this.get().makeUrl;

    	// Make sure we respect both parent menu sorting order and then leaf-level menu sorting order.
    	// orderIndex: (group.orderIndex * 100000) + formLink.orderIndex
    	// nestedSort(tree, (a, b) => a.orderIndex - b.orderIndex);
    }
    const file$2 = "src\\components\\Menu.html";

    function create_main_fragment$2(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.menu != null) && create_if_block$2(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.menu != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$2(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (3:1) {#each menu.children as item}
    function create_each_block$1(component, ctx) {
    	var li;

    	var menuitem_initial_data = { item: ctx.item, menu: ctx.self };
    	var menuitem = new SvelteComponent$1({
    		root: component.root,
    		store: component.store,
    		data: menuitem_initial_data
    	});

    	return {
    		c: function create() {
    			li = createElement("li");
    			menuitem._fragment.c();
    			addLoc(li, file$2, 3, 1, 72);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			menuitem._mount(li, null);
    		},

    		p: function update(changed, ctx) {
    			var menuitem_changes = {};
    			if (changed.menu) menuitem_changes.item = ctx.item;
    			if (changed.self) menuitem_changes.menu = ctx.self;
    			menuitem._set(menuitem_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			menuitem.destroy();
    		}
    	};
    }

    // (1:0) {#if menu != null}
    function create_if_block$2(component, ctx) {
    	var ul;

    	var each_value = ctx.menu.children;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			ul.className = "menu";
    			addLoc(ul, file$2, 1, 0, 20);
    		},

    		m: function mount(target, anchor) {
    			insertNode(ul, target, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.menu || changed.self) {
    				each_value = ctx.menu.children;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.item = list[i];
    	child_ctx.each_value = list;
    	child_ctx.item_index = i;
    	return child_ctx;
    }

    function SvelteComponent$2(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign(data$1(), options.data);
    	if (!('menu' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'menu'");
    	if (!('self' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'self'");
    	this._intro = true;

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$2(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$1.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$2.prototype, protoDev);

    SvelteComponent$2.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    var isBuffer_1 = function (obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
    };

    function isBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
    }

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object' && !isArray(obj)) {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer_1,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim
    };

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$1() {}

    var on$1 = noop$1;
    var addListener$1 = noop$1;
    var once = noop$1;
    var off = noop$1;
    var removeListener$1 = noop$1;
    var removeAllListeners = noop$1;
    var emit = noop$1;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on$1,
      addListener: addListener$1,
      once: once,
      off: off,
      removeListener: removeListener$1,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      // Note: status is not exposed by XDomainRequest
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          }

          if (!utils.isArray(val)) {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
        function resolveURL(url) {
          var href = url;

          if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                      urlParsingNode.pathname :
                      '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
        return function isURLSameOrigin(requestURL) {
          var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
        };
      })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
    );

    // btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    function E() {
      this.message = 'String contains an invalid character';
    }
    E.prototype = new Error;
    E.prototype.code = 5;
    E.prototype.name = 'InvalidCharacterError';

    function btoa(input) {
      var str = String(input);
      var output = '';
      for (
        // initialize result and counter
        var block, charCode, idx = 0, map = chars;
        // if the next str index does not exist:
        //   change the mapping table to "="
        //   check if d has no fractional digits
        str.charAt(idx | 0) || (map = '=', idx % 1);
        // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
        output += map.charAt(63 & block >> 8 - idx % 1 * 8)
      ) {
        charCode = str.charCodeAt(idx += 3 / 4);
        if (charCode > 0xFF) {
          throw new E();
        }
        block = block << 8 | charCode;
      }
      return output;
    }

    var btoa_1 = btoa;

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

      // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })()
    );

    var btoa$1 = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || btoa_1;

    var xhr = function xhrAdapter(config$$1) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config$$1.data;
        var requestHeaders = config$$1.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();
        var loadEvent = 'onreadystatechange';
        var xDomain = false;

        // For IE 8/9 CORS support
        // Only supports POST and GET calls and doesn't returns the response headers.
        // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
        if (process.env.NODE_ENV !== 'test' &&
            typeof window !== 'undefined' &&
            window.XDomainRequest && !('withCredentials' in request) &&
            !isURLSameOrigin(config$$1.url)) {
          request = new window.XDomainRequest();
          loadEvent = 'onload';
          xDomain = true;
          request.onprogress = function handleProgress() {};
          request.ontimeout = function handleTimeout() {};
        }

        // HTTP basic authentication
        if (config$$1.auth) {
          var username = config$$1.auth.username || '';
          var password = config$$1.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa$1(username + ':' + password);
        }

        request.open(config$$1.method.toUpperCase(), buildURL(config$$1.url, config$$1.params, config$$1.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config$$1.timeout;

        // Listen for ready state
        request[loadEvent] = function handleLoad() {
          if (!request || (request.readyState !== 4 && !xDomain)) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config$$1.responseType || config$$1.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
            status: request.status === 1223 ? 204 : request.status,
            statusText: request.status === 1223 ? 'No Content' : request.statusText,
            headers: responseHeaders,
            config: config$$1,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config$$1, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          reject(createError('timeout of ' + config$$1.timeout + 'ms exceeded', config$$1, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          var cookies$$1 = cookies;

          // Add xsrf header
          var xsrfValue = (config$$1.withCredentials || isURLSameOrigin(config$$1.url)) && config$$1.xsrfCookieName ?
              cookies$$1.read(config$$1.xsrfCookieName) :
              undefined;

          if (xsrfValue) {
            requestHeaders[config$$1.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (config$$1.withCredentials) {
          request.withCredentials = true;
        }

        // Add responseType to request if needed
        if (config$$1.responseType) {
          try {
            request.responseType = config$$1.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config$$1.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config$$1.onDownloadProgress === 'function') {
          request.addEventListener('progress', config$$1.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config$$1.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config$$1.onUploadProgress);
        }

        if (config$$1.cancelToken) {
          // Handle cancellation
          config$$1.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (requestData === undefined) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers || {}
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = utils.merge({
          url: arguments[0]
        }, arguments[1]);
      }

      config = utils.merge(defaults_1, this.defaults, { method: 'get' }, config);
      config.method = config.method.toLowerCase();

      // Support baseURL config
      if (config.baseURL && !isAbsoluteURL(config.url)) {
        config.url = combineURLs(config.baseURL, config.url);
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread$1 = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(utils.merge(defaults_1, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread$1;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var default_1 = axios;
    axios_1.default = default_1;

    var axios$1 = axios_1;

    /**
     * Represents metadata for a single input field. *
     */
    var InputFieldMetadata = /** @class */ (function () {
        function InputFieldMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        InputFieldMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return InputFieldMetadata;
    }());

    /**
     * Represents metadata for a single output field.
     */
    var OutputFieldMetadata = /** @class */ (function () {
        function OutputFieldMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
            // Special case for "paginated-data", to ensure that each column is also
            // an instance of OutputFieldMetadata class, instead of a plain javascript object.
            if (this.customProperties != null && this.customProperties.columns != null) {
                for (var columnPropertyName in this.customProperties.columns) {
                    // Convert column to OutputFieldMetadata instance.
                    var metadataAsJsonObject = this.customProperties.columns[columnPropertyName];
                    this.customProperties.columns[columnPropertyName] = new OutputFieldMetadata(metadataAsJsonObject);
                }
            }
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        OutputFieldMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return OutputFieldMetadata;
    }());

    /**
     * Encapsulates all information needed to render a form.
     */
    var FormMetadata = /** @class */ (function () {
        function FormMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
            this.inputFields = metadata.inputFields.map(function (t) { return new InputFieldMetadata(t); });
            this.outputFields = metadata.outputFields.map(function (t) { return new OutputFieldMetadata(t); });
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        FormMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return FormMetadata;
    }());

    /**
     * Represents a reference to a form.
     */

    /**
     * Represents response of a form.
     */
    var FormResponse = /** @class */ (function (_super) {
        __extends(FormResponse, _super);
        function FormResponse() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return FormResponse;
    }(Object));

    /**
     * Represents a function.
     */
    var ClientFunctionMetadata = /** @class */ (function () {
        function ClientFunctionMetadata(metadata) {
            for (var _i = 0, _a = Object.keys(metadata); _i < _a.length; _i++) {
                var property = _a[_i];
                this[property] = metadata[property];
            }
        }
        /**
         * Gets value of a custom property.
         * @param name name of the custom property to get.
         * @returns value of the custom property or null if the property is undefined.
         */
        ClientFunctionMetadata.prototype.getCustomProperty = function (name) {
            if (this.customProperties != null && this.customProperties[name]) {
                return this.customProperties[name];
            }
            return null;
        };
        return ClientFunctionMetadata;
    }());

    /**
     * Represents a function which can be run at a specific time during form's lifecycle.
     */
    var EventHandlerMetadata = /** @class */ (function (_super) {
        __extends(EventHandlerMetadata, _super);
        function EventHandlerMetadata() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EventHandlerMetadata;
    }(ClientFunctionMetadata));

    /**
     * Metadata describing how to handle the response.
     */
    var FormResponseMetadata = /** @class */ (function () {
        function FormResponseMetadata() {
        }
        return FormResponseMetadata;
    }());

    var axios$2 = axios$1;
    var UmfServer = /** @class */ (function () {
        /**
         * Creates a new instance of UmfApp.
         */
        function UmfServer(getMetadataUrl, postFormUrl) {
            this.eventHandlers = {};
            this.getMetadataUrl = getMetadataUrl;
            this.postFormUrl = postFormUrl;
        }
        UmfServer.prototype.on = function (event, handler) {
            this.eventHandlers[event] = this.eventHandlers[event] || [];
            this.eventHandlers[event].push(handler);
        };
        UmfServer.prototype.fire = function (event, params) {
            var handlersForEvent = this.eventHandlers[event];
            if (handlersForEvent != null && handlersForEvent.length > 0) {
                for (var _i = 0, handlersForEvent_1 = handlersForEvent; _i < handlersForEvent_1.length; _i++) {
                    var handler = handlersForEvent_1[_i];
                    handler(params);
                }
            }
        };
        UmfServer.prototype.getMetadata = function (formId) {
            var _this = this;
            this.fire("request:started");
            return axios$2.get(this.getMetadataUrl + "/" + formId).then(function (response) {
                _this.fire("request:completed");
                return response.data;
            }).catch(function (e) {
                // tslint:disable-next-line:no-console
                console.warn("Did not find form \"" + formId + "\".");
                _this.fire("request:completed");
                return null;
            });
        };
        UmfServer.prototype.getAllMetadata = function () {
            var _this = this;
            this.fire("request:started");
            return axios$2.get(this.getMetadataUrl).then(function (response) {
                _this.fire("request:completed");
                return response.data;
            });
        };
        UmfServer.prototype.postForm = function (form, data) {
            var _this = this;
            this.fire("request:started");
            return axios$2.post(this.postFormUrl, JSON.stringify([{
                    Form: form,
                    RequestId: 1,
                    InputFieldValues: data
                }]), {
                headers: {
                    "Content-Type": "application/json"
                }
            }).then(function (response) {
                var invokeFormResponses = response.data;
                // Make sure metadata is never null.
                invokeFormResponses[0].data.metadata = invokeFormResponses[0].data.metadata || new FormResponseMetadata();
                _this.fire("request:completed");
                return invokeFormResponses[0].data;
            }).catch(function (error) {
                _this.fire("request:completed", error.response.data.error);
                return null;
            });
        };
        return UmfServer;
    }());

    var FormEventArguments = /** @class */ (function () {
        function FormEventArguments(app) {
            this.app = app;
        }
        return FormEventArguments;
    }());

    var FormResponseEventArguments = /** @class */ (function (_super) {
        __extends(FormResponseEventArguments, _super);
        function FormResponseEventArguments(app, response) {
            var _this = _super.call(this, app) || this;
            _this.response = response;
            return _this;
        }
        return FormResponseEventArguments;
    }(FormEventArguments));

    var FormInstance = /** @class */ (function () {
        function FormInstance(metadata, controlRegister) {
            this.outputs = [];
            this.inputs = [];
            this.metadata = new FormMetadata(metadata);
            this.inputs = controlRegister.createInputControllers(this.metadata.inputFields);
        }
        FormInstance.prototype.enforceCanPostOnLoad = function () {
            // If user is trying to auto-submit a form which is not enabled for `PostOnLoad`.
            if (!this.metadata.postOnLoad) {
                throw new Error("Invalid invocation of form '" + this.metadata.id + "'. Form cannot be auto-posted, because *PostOnLoad* is set to false.");
            }
        };
        FormInstance.prototype.allRequiredInputsHaveData = function (asPostOnLoad) {
            return __awaiter(this, void 0, void 0, function () {
                var formData;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (asPostOnLoad) {
                                this.enforceCanPostOnLoad();
                            }
                            return [4 /*yield*/, this.getFormData(asPostOnLoad)];
                        case 1:
                            formData = _a.sent();
                            return [2 /*return*/, formData != null];
                    }
                });
            });
        };
        FormInstance.prototype.submit = function (app, asPostOnLoad, args) {
            return __awaiter(this, void 0, void 0, function () {
                var formData, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (asPostOnLoad) {
                                this.enforceCanPostOnLoad();
                            }
                            return [4 /*yield*/, this.getFormData(asPostOnLoad)];
                        case 1:
                            formData = _a.sent();
                            // If not all required inputs are filled.
                            if (formData == null) {
                                throw new Error("Form '" + this.metadata.id + "' cannot be submitted, because some required input fields do not have values.");
                            }
                            return [4 /*yield*/, this.fire("form:posting", new FormEventArguments(app))];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, app.server.postForm(this.metadata.id, formData)];
                        case 3:
                            response = _a.sent();
                            return [4 /*yield*/, this.fire("form:responseReceived", new FormResponseEventArguments(app, response))];
                        case 4:
                            _a.sent();
                            this.setOutputFieldValues(response);
                            // Null response is treated as a server-side error.
                            if (response == null) {
                                throw new Error("Received null response.");
                            }
                            return [4 /*yield*/, app.runFunctions(response.metadata.functionsToRun)];
                        case 5:
                            _a.sent();
                            app.handleResponse(response, this, args);
                            return [4 /*yield*/, this.fire("form:responseHandled", new FormResponseEventArguments(app, response))];
                        case 6:
                            _a.sent();
                            return [2 /*return*/, response];
                    }
                });
            });
        };
        FormInstance.prototype.initializeInputFields = function (data) {
            var promises = [];
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var fieldMetadata = _a[_i];
                var value = null;
                if (data != null) {
                    for (var prop in data) {
                        if (data.hasOwnProperty(prop) && prop.toLowerCase() === fieldMetadata.metadata.id.toLowerCase()) {
                            value = data[prop];
                            break;
                        }
                    }
                }
                promises.push(fieldMetadata.init(value));
            }
            return Promise.all(promises);
        };
        FormInstance.prototype.setInputFields = function (data) {
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var field = _a[_i];
                field.value = data[field.metadata.id];
            }
        };
        FormInstance.prototype.getSerializedInputValues = function () {
            var data = {};
            var promises = [];
            var _loop_1 = function (input) {
                var promise = input.serialize().then(function (t) {
                    // Don't include inputs without values, because we only
                    // want to serialize "non-default" values.
                    if (t.value != null && t.value !== "") {
                        data[input.metadata.id] = t.value;
                    }
                });
                promises.push(promise);
            };
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var input = _a[_i];
                _loop_1(input);
            }
            return Promise.all(promises).then(function () { return data; });
        };
        FormInstance.prototype.getSerializedInputValuesFromObject = function (value) {
            var data = {};
            var normalizedObject = {};
            for (var prop in value) {
                if (value.hasOwnProperty(prop)) {
                    normalizedObject[prop.toLowerCase()] = value[prop];
                }
            }
            for (var _i = 0, _a = this.inputs; _i < _a.length; _i++) {
                var input = _a[_i];
                var valueAsString = input.serializeValue(normalizedObject[input.metadata.id.toLowerCase()]);
                // Don't include inputs without values, because we only
                // want to serialize "non-default" values.
                if (valueAsString != null && valueAsString !== "") {
                    data[input.metadata.id] = valueAsString;
                }
            }
            return data;
        };
        FormInstance.getOutputFieldValues = function (outputFieldsMetadata, response) {
            var fields = Array();
            var normalizedResponse = FormInstance.getNormalizedObject(response);
            for (var _i = 0, outputFieldsMetadata_1 = outputFieldsMetadata; _i < outputFieldsMetadata_1.length; _i++) {
                var field = outputFieldsMetadata_1[_i];
                var normalizedId = field.id.toLowerCase();
                fields.push({
                    metadata: field,
                    data: normalizedResponse[normalizedId]
                });
            }
            fields.sort(function (a, b) {
                return a.metadata.orderIndex - b.metadata.orderIndex;
            });
            return fields;
        };
        FormInstance.prototype.setOutputFieldValues = function (response) {
            if (response == null) {
                this.outputs = [];
                return;
            }
            var fields = Array();
            var normalizedResponse = FormInstance.getNormalizedObject(response);
            for (var _i = 0, _a = this.metadata.outputFields; _i < _a.length; _i++) {
                var field = _a[_i];
                fields.push({
                    metadata: field,
                    data: normalizedResponse[field.id.toLowerCase()]
                });
            }
            fields.sort(function (a, b) {
                return a.metadata.orderIndex - b.metadata.orderIndex;
            });
            this.outputs = fields;
        };
        FormInstance.prototype.handleEvent = function (eventName, eventMetadata, parameters) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.fire(eventName, parameters)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        FormInstance.prototype.fire = function (eventName, parameters) {
            return __awaiter(this, void 0, void 0, function () {
                var promises, _i, _a, input, _b, _c, eventHandlerMetadata, handler, promise, _d, _e, output, _f, _g, eventHandlerMetadata, handler, promise;
                var _this = this;
                return __generator(this, function (_h) {
                    switch (_h.label) {
                        case 0:
                            promises = [];
                            // Run input event handlers.
                            for (_i = 0, _a = this.inputs; _i < _a.length; _i++) {
                                input = _a[_i];
                                if (input.metadata.eventHandlers != null) {
                                    for (_b = 0, _c = input.metadata.eventHandlers; _b < _c.length; _b++) {
                                        eventHandlerMetadata = _c[_b];
                                        if (eventHandlerMetadata.runAt === eventName) {
                                            handler = parameters.app.controlRegister.inputFieldEventHandlers[eventHandlerMetadata.id];
                                            if (handler == null) {
                                                throw new Error("Could not find input event handler '" + eventHandlerMetadata.id + "'.");
                                            }
                                            promise = handler.run(input, eventHandlerMetadata, parameters);
                                            promises.push(promise);
                                        }
                                    }
                                }
                            }
                            // Run output event handlers.
                            for (_d = 0, _e = this.outputs; _d < _e.length; _d++) {
                                output = _e[_d];
                                if (output.metadata.eventHandlers != null) {
                                    for (_f = 0, _g = output.metadata.eventHandlers; _f < _g.length; _f++) {
                                        eventHandlerMetadata = _g[_f];
                                        if (eventHandlerMetadata.runAt === eventName) {
                                            handler = parameters.app.controlRegister.outputFieldEventHandlers[eventHandlerMetadata.id];
                                            if (handler == null) {
                                                throw new Error("Could not find output event handler '" + eventHandlerMetadata.id + "'.");
                                            }
                                            promise = handler.run(output, eventHandlerMetadata, parameters);
                                            promises.push(promise);
                                        }
                                    }
                                }
                            }
                            // Run form event handlers.
                            this.metadata.eventHandlers
                                .filter(function (t) { return t.runAt === eventName; })
                                .forEach(function (t) {
                                var handler = parameters.app.controlRegister.formEventHandlers[t.id];
                                if (handler == null) {
                                    throw new Error("Could not find form event handler '" + t.id + "'.");
                                }
                                var promise = handler.run(_this, t, parameters);
                                promises.push(promise);
                            });
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _h.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        FormInstance.prototype.getFormData = function (asPostOnLoad) {
            return __awaiter(this, void 0, void 0, function () {
                var data, promises, hasRequiredMissingInput, _loop_2, _i, _a, input, skipValidation;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            data = {};
                            promises = [];
                            hasRequiredMissingInput = false;
                            _loop_2 = function (input) {
                                var promise = input.getValue().then(function (value) {
                                    data[input.metadata.id] = value;
                                    if (input.metadata.required && (value == null || (typeof (value) === "string" && value === ""))) {
                                        hasRequiredMissingInput = true;
                                    }
                                });
                                promises.push(promise);
                            };
                            for (_i = 0, _a = this.inputs; _i < _a.length; _i++) {
                                input = _a[_i];
                                _loop_2(input);
                            }
                            return [4 /*yield*/, Promise.all(promises)];
                        case 1:
                            _b.sent();
                            skipValidation = !this.metadata.postOnLoadValidation &&
                                this.metadata.postOnLoad &&
                                // if initialization of the form, i.e. - first post.
                                asPostOnLoad;
                            // If not all required inputs were entered, then do not post.
                            if (hasRequiredMissingInput &&
                                !skipValidation) {
                                return [2 /*return*/, null];
                            }
                            return [2 /*return*/, data];
                    }
                });
            });
        };
        FormInstance.getNormalizedObject = function (response) {
            var normalizedResponse = {};
            for (var field in response) {
                if (response.hasOwnProperty(field) && field !== "metadata") {
                    normalizedResponse[field.toLowerCase()] = response[field];
                }
            }
            return normalizedResponse;
        };
        return FormInstance;
    }());

    var UmfApp = /** @class */ (function () {
        function UmfApp(server, controlRegister) {
            var _this = this;
            this.formsById = {};
            this.eventHandlers = [];
            this.formResponseHandlers = {};
            this.server = server;
            this.controlRegister = controlRegister;
            var _loop_1 = function (e) {
                this_1.server.on(e, function (params) {
                    _this.fire(e, params);
                });
            };
            var this_1 = this;
            for (var _i = 0, _a = ["request:started", "request:completed"]; _i < _a.length; _i++) {
                var e = _a[_i];
                _loop_1(e);
            }
        }
        UmfApp.prototype.on = function (event, handler) {
            this.eventHandlers[event] = this.eventHandlers[event] || [];
            this.eventHandlers[event].push(handler);
        };
        UmfApp.prototype.fire = function (event, params) {
            var handlersForEvent = this.eventHandlers[event];
            if (handlersForEvent != null && handlersForEvent.length > 0) {
                for (var _i = 0, handlersForEvent_1 = handlersForEvent; _i < handlersForEvent_1.length; _i++) {
                    var handler = handlersForEvent_1[_i];
                    handler(params);
                }
            }
        };
        UmfApp.prototype.useRouter = function (router) {
            this.go = function (form, values) {
                return router.go(form, values);
            };
            this.makeUrl = function (form, values) {
                return router.makeUrl(form, values);
            };
        };
        UmfApp.prototype.registerResponseHandler = function (handler) {
            this.formResponseHandlers[handler.name] = handler;
        };
        UmfApp.prototype.load = function () {
            var _this = this;
            return this.server.getAllMetadata()
                .then(function (response) {
                _this.forms = response.forms;
                _this.menu = response.menu;
                _this.formsById = {};
                for (var _i = 0, _a = _this.forms; _i < _a.length; _i++) {
                    var form = _a[_i];
                    _this.formsById[form.id] = new FormMetadata(form);
                }
            });
        };
        UmfApp.prototype.getForm = function (id) {
            return this.formsById[id];
        };
        UmfApp.prototype.getFormInstance = function (formId, throwError) {
            if (throwError === void 0) { throwError = false; }
            var metadata = this.getForm(formId);
            if (metadata == null) {
                if (throwError) {
                    throw Error("Form " + formId + " not found.");
                }
                return null;
            }
            return new FormInstance(metadata, this.controlRegister);
        };
        UmfApp.prototype.handleResponse = function (response, form, args) {
            var responseMetadata = response.metadata || new FormResponseMetadata();
            var handler = this.formResponseHandlers[responseMetadata.handler || "default"];
            if (handler == null) {
                throw new Error("Cannot find FormResponseHandler \"" + responseMetadata.handler + "\".");
            }
            return handler.handle(response, form, args);
        };
        UmfApp.prototype.runFunctions = function (functionMetadata, eventArgs) {
            if (functionMetadata == null) {
                return Promise.resolve();
            }
            var promises = [];
            for (var _i = 0, functionMetadata_1 = functionMetadata; _i < functionMetadata_1.length; _i++) {
                var f = functionMetadata_1[_i];
                var handler = this.controlRegister.functions[f.id];
                if (handler == null) {
                    throw new Error("Could not find function '" + f.id + "'.");
                }
                var promise = handler.run(f, eventArgs);
                promises.push(promise);
            }
            return Promise.all(promises);
        };
        return UmfApp;
    }());

    var InputController = /** @class */ (function () {
        function InputController(metadata) {
            this.metadata = metadata;
        }
        InputController.prototype.serialize = function () {
            var _this = this;
            return this.getValue().then(function (t) {
                var valueAsString = _this.serializeValue(t);
                return {
                    value: valueAsString,
                    input: _this
                };
            });
        };
        return InputController;
    }());

    var StringInputController = /** @class */ (function (_super) {
        __extends(StringInputController, _super);
        function StringInputController(metadata) {
            return _super.call(this, metadata) || this;
        }
        StringInputController.prototype.serializeValue = function (value) {
            // Ensure we don't return "undefined", but return null instead.
            return value != null ? value.toString() : null;
        };
        StringInputController.prototype.init = function (value) {
            this.value = value;
            return Promise.resolve(this);
        };
        StringInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        return StringInputController;
    }(InputController));

    var ControlRegister = /** @class */ (function () {
        function ControlRegister() {
            this.inputs = {};
            this.outputs = {};
            this.inputFieldEventHandlers = {};
            this.outputFieldEventHandlers = {};
            this.formEventHandlers = {};
            this.functions = {};
        }
        ControlRegister.prototype.createInputControllers = function (fields) {
            var result = [];
            for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
                var field = fields_1[_i];
                // Instantiate new input controller.
                var entry = this.inputs[field.type];
                var ctor = entry != null && entry.controller != null
                    ? entry.controller
                    : StringInputController;
                result.push(new ctor(field));
            }
            result.sort(function (a, b) {
                return a.metadata.orderIndex - b.metadata.orderIndex;
            });
            return result;
        };
        ControlRegister.prototype.getOutput = function (field) {
            return field != null
                ? this.outputs[field.metadata.type] || this.outputs.text
                : this.outputs.text;
        };
        ControlRegister.prototype.getInput = function (type) {
            return type != null
                ? this.inputs[type] || this.inputs.text
                : this.inputs.text;
        };
        ControlRegister.prototype.registerInputFieldControl = function (name, svelteComponent, controller, constants) {
            if (constants === void 0) { constants = null; }
            this.inputs[name] = {
                controller: controller,
                component: svelteComponent,
                constants: constants
            };
        };
        ControlRegister.prototype.registerOutputFieldControl = function (name, svelteComponent, constants) {
            if (constants === void 0) { constants = null; }
            this.outputs[name] = {
                constructor: svelteComponent,
                constants: constants
            };
        };
        ControlRegister.prototype.registerFormEventHandler = function (name, handler) {
            this.formEventHandlers[name] = handler;
        };
        ControlRegister.prototype.registerInputFieldEventHandler = function (name, handler) {
            this.inputFieldEventHandlers[name] = handler;
        };
        ControlRegister.prototype.registerOutputFieldEventHandler = function (name, handler) {
            this.outputFieldEventHandlers[name] = handler;
        };
        ControlRegister.prototype.registerFunction = function (name, fn) {
            this.functions[name] = fn;
        };
        return ControlRegister;
    }());

    var OutputControlConfiguration = /** @class */ (function () {
        function OutputControlConfiguration(alwaysHideLabel, block) {
            if (alwaysHideLabel === void 0) { alwaysHideLabel = false; }
            if (block === void 0) { block = true; }
            this.alwaysHideLabel = false;
            this.block = true;
            this.alwaysHideLabel = alwaysHideLabel;
            this.block = block;
        }
        return OutputControlConfiguration;
    }());

    var OutputFieldValue = /** @class */ (function () {
        function OutputFieldValue() {
        }
        return OutputFieldValue;
    }());

    var FormEventHandler = /** @class */ (function () {
        function FormEventHandler() {
        }
        return FormEventHandler;
    }());

    var InputFieldEventHandler = /** @class */ (function () {
        function InputFieldEventHandler() {
        }
        return InputFieldEventHandler;
    }());

    var OutputFieldEventHandler = /** @class */ (function () {
        function OutputFieldEventHandler() {
        }
        return OutputFieldEventHandler;
    }());

    var InputEventArguments = /** @class */ (function (_super) {
        __extends(InputEventArguments, _super);
        function InputEventArguments(app, input) {
            var _this = _super.call(this, app) || this;
            _this.input = input;
            return _this;
        }
        return InputEventArguments;
    }(FormEventArguments));

    var MessageResponseHandler = /** @class */ (function () {
        function MessageResponseHandler() {
            this.name = "message";
        }
        MessageResponseHandler.prototype.handle = function (response, form) {
            alert(response.message);
        };
        return MessageResponseHandler;
    }());

    var RedirectResponseHandler = /** @class */ (function () {
        function RedirectResponseHandler(goToForm) {
            this.name = "redirect";
            this.goToForm = goToForm;
        }
        RedirectResponseHandler.prototype.handle = function (response, form) {
            this.goToForm(response.form, response.inputFieldValues);
        };
        return RedirectResponseHandler;
    }());

    var ReloadResponseHandler = /** @class */ (function () {
        function ReloadResponseHandler(getFormUrl) {
            this.name = "reload";
            this.getFormUrl = getFormUrl;
        }
        ReloadResponseHandler.prototype.handle = function (response, form) {
            this.getFormUrl(response.form, response.inputFieldValues).then(function (url) {
                window.location.href = url;
            });
        };
        return ReloadResponseHandler;
    }());

    var FormComponentResponseHandler = /** @class */ (function () {
        function FormComponentResponseHandler() {
            this.name = "default";
        }
        FormComponentResponseHandler.prototype.handle = function (response, form, args) {
            if (args != null && args.formComponent != null) {
                args.formComponent.renderResponse(response);
            }
        };
        return FormComponentResponseHandler;
    }());

    var RouteParameterBuilder = /** @class */ (function () {
        function RouteParameterBuilder(parameterName, app) {
            this.defaultParameters = {};
            this.getFormInstance = function (formId, throwError) { return app.getFormInstance(formId, null); };
            this.parameterName = parameterName;
            this.defaultParameters[parameterName] = "";
        }
        RouteParameterBuilder.prototype.buildFormRouteParameters = function (form, values) {
            var formInstance = this.getFormInstance(form, true);
            var base = formInstance.getSerializedInputValuesFromObject(values);
            if (form === this.currentForm) {
                var d = RouteParameterBuilder.parseQueryStringParameters(location.hash)[this.parameterName] || 0;
                var dAsNumber = parseInt(d, 10);
                base[this.parameterName] = isNaN(dAsNumber) ? 0 : dAsNumber + 1;
            }
            return __assign({}, base, { _id: form });
        };
        RouteParameterBuilder.parseQueryStringParameters = function (url) {
            var queryStartsAt = url.indexOf("?");
            var result = {};
            // If there is a query string.
            if (queryStartsAt !== -1 && url.length > queryStartsAt) {
                url.substr(queryStartsAt + 1).split("&").filter(function (t) {
                    var value = t.split("=");
                    result[value[0]] = value[1];
                });
            }
            return result;
        };
        return RouteParameterBuilder;
    }());

    var stateStringParser = function(stateString) {
    	return stateString.split('.').reduce(function(stateNames, latestNameChunk) {
    		if (stateNames.length) {
    			latestNameChunk = stateNames[stateNames.length - 1] + '.' + latestNameChunk;
    		}
    		stateNames.push(latestNameChunk);
    		return stateNames
    	}, [])
    };

    var parse = stateStringParser;

    var stateState = function StateState() {
    	var states = {};

    	function getHierarchy(name) {
    		var names = stateStringParser(name);

    		return names.map(function(name) {
    			if (!states[name]) {
    				throw new Error('State ' + name + ' not found')
    			}
    			return states[name]
    		})
    	}

    	function getParent(name) {
    		var parentName = getParentName(name);

    		return parentName && states[parentName]
    	}

    	function getParentName(name) {
    		var names = stateStringParser(name);

    		if (names.length > 1) {
    			var secondToLast = names.length - 2;

    			return names[secondToLast]
    		} else {
    			return null
    		}
    	}

    	function guaranteeAllStatesExist(newStateName) {
    		var stateNames = parse(newStateName);
    		var statesThatDontExist = stateNames.filter(function(name) {
    			return !states[name]
    		});

    		if (statesThatDontExist.length > 0) {
    			throw new Error('State ' + statesThatDontExist[statesThatDontExist.length - 1] + ' does not exist')
    		}
    	}

    	function buildFullStateRoute(stateName) {
    		return getHierarchy(stateName).map(function(state) {
    			return '/' + (state.route || '')
    		}).join('').replace(/\/{2,}/g, '/')
    	}

    	function applyDefaultChildStates(stateName) {
    		var state = states[stateName];

    		function getDefaultChildStateName() {
    			return state && (typeof state.defaultChild === 'function'
    				? state.defaultChild()
    				: state.defaultChild)
    		}

    		var defaultChildStateName = getDefaultChildStateName();

    		if (!defaultChildStateName) {
    			return stateName
    		}

    		var fullStateName = stateName + '.' + defaultChildStateName;

    		return applyDefaultChildStates(fullStateName)
    	}


    	return {
    		add: function(name, state) {
    			states[name] = state;
    		},
    		get: function(name) {
    			return name && states[name]
    		},
    		getHierarchy: getHierarchy,
    		getParent: getParent,
    		getParentName: getParentName,
    		guaranteeAllStatesExist: guaranteeAllStatesExist,
    		buildFullStateRoute: buildFullStateRoute,
    		applyDefaultChildStates: applyDefaultChildStates
    	}
    };

    var combineArrays = function(obj) {
    	var keys = Object.keys(obj);

    	keys.forEach(function(key) {
    		if (!Array.isArray(obj[key])) {
    			throw new Error(key + ' is not an array')
    		}
    	});

    	var maxIndex = keys.reduce(function(maxSoFar, key) {
    		var len = obj[key].length;
    		return maxSoFar > len ? maxSoFar : len
    	}, 0);

    	var output = [];

    	function getObject(index) {
    		var o = {};
    		keys.forEach(function(key) {
    			o[key] = obj[key][index];
    		});
    		return o
    	}

    	for (var i = 0; i < maxIndex; ++i) {
    		output.push(getObject(i));
    	}

    	return output
    };

    var isarray = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };

    /**
     * Expose `pathToRegexp`.
     */
    var pathToRegexpWithReversibleKeys = pathToRegexp;

    /**
     * The main path matching regexp utility.
     *
     * @type {RegExp}
     */
    var PATH_REGEXP = new RegExp([
      // Match escaped characters that would otherwise appear in future matches.
      // This allows the user to escape special characters that won't transform.
      '(\\\\.)',
      // Match Express-style parameters and un-named parameters with a prefix
      // and optional suffixes. Matches appear as:
      //
      // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
      // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
      '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
      // Match regexp special characters that are always escaped.
      '([.+*?=^!:${}()[\\]|\\/])'
    ].join('|'), 'g');

    /**
     * Escape the capturing group by escaping special characters and meaning.
     *
     * @param  {String} group
     * @return {String}
     */
    function escapeGroup (group) {
      return group.replace(/([=!:$\/()])/g, '\\$1');
    }

    /**
     * Attach the keys as a property of the regexp.
     *
     * @param  {RegExp} re
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function attachKeys (re, keys, allTokens) {
      re.keys = keys;
      re.allTokens = allTokens;
      return re;
    }

    /**
     * Get the flags for a regexp from the options.
     *
     * @param  {Object} options
     * @return {String}
     */
    function flags (options) {
      return options.sensitive ? '' : 'i';
    }

    /**
     * Pull out keys from a regexp.
     *
     * @param  {RegExp} path
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function regexpToRegexp (path, keys, allTokens) {
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g);

      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name:      i,
            delimiter: null,
            optional:  false,
            repeat:    false
          });
        }
      }

      return attachKeys(path, keys, allTokens);
    }

    /**
     * Transform an array into a regexp.
     *
     * @param  {Array}  path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function arrayToRegexp (path, keys, options, allTokens) {
      var parts = [];

      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options, allTokens).source);
      }

      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
      return attachKeys(regexp, keys, allTokens);
    }

    /**
     * Replace the specific tags with regexp strings.
     *
     * @param  {String} path
     * @param  {Array}  keys
     * @return {String}
     */
    function replacePath (path, keys, allTokens) {
      var index = 0;
      var lastEndIndex = 0;

      function addLastToken(lastToken) {
        if (lastEndIndex === 0 && lastToken[0] !== '/') {
          lastToken = '/' + lastToken;
        }
        allTokens.push({
          string: lastToken
        });
      }


      function replace (match, escaped, prefix, key, capture, group, suffix, escape, offset) {
        if (escaped) {
          return escaped;
        }

        if (escape) {
          return '\\' + escape;
        }

        var repeat   = suffix === '+' || suffix === '*';
        var optional = suffix === '?' || suffix === '*';

        if (offset > lastEndIndex) {
          addLastToken(path.substring(lastEndIndex, offset));
        }

        lastEndIndex = offset + match.length;

        var newKey = {
          name:      key || index++,
          delimiter: prefix || '/',
          optional:  optional,
          repeat:    repeat
        };

        keys.push(newKey);
        allTokens.push(newKey);

        prefix = prefix ? ('\\' + prefix) : '';
        capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

        if (repeat) {
          capture = capture + '(?:' + prefix + capture + ')*';
        }

        if (optional) {
          return '(?:' + prefix + '(' + capture + '))?';
        }

        // Basic parameter support.
        return prefix + '(' + capture + ')';
      }

      var newPath = path.replace(PATH_REGEXP, replace);

      if (lastEndIndex < path.length) {
        addLastToken(path.substring(lastEndIndex));
      }

      return newPath;
    }

    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     *
     * @param  {(String|RegExp|Array)} path
     * @param  {Array}                 [keys]
     * @param  {Object}                [options]
     * @return {RegExp}
     */
    function pathToRegexp (path, keys, options, allTokens) {
      keys = keys || [];
      allTokens = allTokens || [];

      if (!isarray(keys)) {
        options = keys;
        keys = [];
      } else if (!options) {
        options = {};
      }

      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys, options, allTokens);
      }

      if (isarray(path)) {
        return arrayToRegexp(path, keys, options, allTokens);
      }

      var strict = options.strict;
      var end = options.end !== false;
      var route = replacePath(path, keys, allTokens);
      var endsWithSlash = path.charAt(path.length - 1) === '/';

      // In non-strict mode we allow a slash at the end of match. If the path to
      // match already ends with a slash, we remove it for consistency. The slash
      // is valid at the end of a path match, not in the middle. This is important
      // in non-ending mode, where "/test/" shouldn't match "/test//route".
      if (!strict) {
        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
      }

      if (end) {
        route += '$';
      } else {
        // In non-ending mode, we need the capturing groups to match as much as
        // possible by using a positive lookahead to the end or next path segment.
        route += strict && endsWithSlash ? '' : '(?=\\/|$)';
      }

      return attachKeys(new RegExp('^' + route, flags(options)), keys, allTokens);
    }

    var stateComparison_1 = function StateComparison(stateState) {
    	var getPathParameters = pathParameters();

    	var parametersChanged = parametersThatMatterWereChanged.bind(null, stateState, getPathParameters);

    	return stateComparison.bind(null, parametersChanged)
    };

    function pathParameters() {
    	var parameters = {};

    	return function getPathParameters(path) {
    		if (!path) {
    			return []
    		}

    		if (!parameters[path]) {
    			parameters[path] = pathToRegexpWithReversibleKeys(path).keys.map(function(key) {
    				return key.name
    			});
    		}

    		return parameters[path]
    	}
    }

    function parametersThatMatterWereChanged(stateState, getPathParameters, stateName, fromParameters, toParameters) {
    	var state = stateState.get(stateName);
    	var querystringParameters = state.querystringParameters || [];
    	var parameters = getPathParameters(state.route).concat(querystringParameters);

    	return Array.isArray(parameters) && parameters.some(function(key) {
    		return fromParameters[key] !== toParameters[key]
    	})
    }

    function stateComparison(parametersChanged, originalState, originalParameters, newState, newParameters) {
    	var states = combineArrays({
    		start: stateStringParser(originalState),
    		end: stateStringParser(newState)
    	});

    	return states.map(function(states) {
    		return {
    			nameBefore: states.start,
    			nameAfter: states.end,
    			stateNameChanged: states.start !== states.end,
    			stateParametersChanged: states.start === states.end && parametersChanged(states.start, originalParameters, newParameters)
    		}
    	})
    }

    var currentState = function CurrentState() {
    	var current = {
    		name: '',
    		parameters: {}
    	};

    	return {
    		get: function() {
    			return current
    		},
    		set: function(name, parameters) {
    			current = {
    				name: name,
    				parameters: parameters
    			};
    		}
    	}
    };

    var stateChangeLogic = function stateChangeLogic(stateComparisonResults) {
    	var hitChangingState = false;
    	var hitDestroyedState = false;

    	var output = {
    		destroy: [],
    		change: [],
    		create: []
    	};

    	stateComparisonResults.forEach(function(state) {
    		hitChangingState = hitChangingState || state.stateParametersChanged;
    		hitDestroyedState = hitDestroyedState || state.stateNameChanged;

    		if (state.nameBefore) {
    			if (hitDestroyedState) {
    				output.destroy.push(state.nameBefore);
    			} else if (hitChangingState) {
    				output.change.push(state.nameBefore);
    			}
    		}

    		if (state.nameAfter && hitDestroyedState) {
    			output.create.push(state.nameAfter);
    		}
    	});

    	return output
    };

    var stateTransitionManager = function (emitter) {
    	var currentTransitionAttempt = null;
    	var nextTransition = null;

    	function doneTransitioning() {
    		currentTransitionAttempt = null;
    		if (nextTransition) {
    			beginNextTransitionAttempt();
    		}
    	}

    	function isTransitioning() {
    		return !!currentTransitionAttempt
    	}

    	function beginNextTransitionAttempt() {
    		currentTransitionAttempt = nextTransition;
    		nextTransition = null;
    		currentTransitionAttempt.beginStateChange();
    	}

    	function cancelCurrentTransition() {
    		currentTransitionAttempt.transition.cancelled = true;
    		var err = new Error('State transition cancelled by the state transition manager');
    		err.wasCancelledBySomeoneElse = true;
    		emitter.emit('stateChangeCancelled', err);
    	}

    	emitter.on('stateChangeAttempt', function(beginStateChange) {
    		nextTransition = createStateTransitionAttempt(beginStateChange);

    		if (isTransitioning() && currentTransitionAttempt.transition.cancellable) {
    			cancelCurrentTransition();
    		} else if (!isTransitioning()) {
    			beginNextTransitionAttempt();
    		}
    	});

    	emitter.on('stateChangeError', doneTransitioning);
    	emitter.on('stateChangeCancelled', doneTransitioning);
    	emitter.on('stateChangeEnd', doneTransitioning);

    	function createStateTransitionAttempt(beginStateChange) {
    		var transition = {
    			cancelled: false,
    			cancellable: true
    		};
    		return {
    			transition: transition,
    			beginStateChange: beginStateChange.bind(null, transition)
    		}
    	}
    };

    var defaultRouterOptions = { reverse: false };

    var npo = createCommonjsModule(function (module) {
    /*! Native Promise Only
        v0.8.1 (c) Kyle Simpson
        MIT License: http://getify.mit-license.org
    */
    !function(t,n,e){n[t]=n[t]||e(),module.exports?module.exports=n[t]:"function"==typeof undefined&&undefined.amd&&undefined(function(){return n[t]});}("Promise","undefined"!=typeof commonjsGlobal?commonjsGlobal:commonjsGlobal,function(){function t(t,n){l.add(t,n),h||(h=y(l.drain));}function n(t){var n,e=typeof t;return null==t||"object"!=e&&"function"!=e||(n=t.then),"function"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0;}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError("Promise-chain cycle")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r));}catch(c){o.reject(c);}}function r(o){var c,u=this;if(!u.triggered){u.triggered=!0,u.def&&(u=u.def);try{(c=n(o))?t(function(){var t=new f(u);try{c.call(o,function(){r.apply(t,arguments);},function(){i.apply(t,arguments);});}catch(n){i.call(t,n);}}):(u.msg=o,u.state=1,u.chain.length>0&&t(e,u));}catch(a){i.call(new f(u),a);}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o));}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t);},o);}(r);}function f(t){this.def=t,this.triggered=!1;}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0;}function a(n){if("function"!=typeof n)throw TypeError("Not a function");if(0!==this.__NPO__)throw TypeError("Not a promise");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:"function"==typeof n?n:!0,failure:"function"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if("function"!=typeof t||"function"!=typeof n)throw TypeError("Not a function");i.resolve=t,i.reject=n;}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this["catch"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t);},function(t){i.call(o,t);});}catch(c){i.call(o,c);}}var s,h,l,p=Object.prototype.toString,y="undefined"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},"x",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})};}catch(d){s=function(t,n,e){return t[n]=e,t};}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0;}var n,e,o;return {add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0;},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next;}}}();var g=s({},"constructor",a,!1);return a.prototype=g,s(g,"__NPO__",0,!1),s(a,"resolve",function(t){var n=this;return t&&"object"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");n(t);})}),s(a,"reject",function(t){return new this(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");e(t);})}),s(a,"all",function(t){var n=this;return "[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):0===t.length?n.resolve([]):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i);},o);})}),s(a,"race",function(t){var n=this;return "[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");c(n,t,function(t,n){e(n);},o);})}),a});
    });

    // Pulled from https://github.com/joliss/promise-map-series and prettied up a bit



    var promiseMapSeries = function sequence(array, iterator, thisArg) {
    	var current = npo.resolve();
    	var cb = arguments.length > 2 ? iterator.bind(thisArg) : iterator;

    	var results = array.map(function(value, i) {
    		return current = current.then(function(j) {
    			return cb(value, j, array)
    		}.bind(null, i))
    	});

    	return npo.all(results)
    };

    var thenDenodeify = function denodeify(fn) {
    	return function() {
    		var self = this;
    		var args = Array.prototype.slice.call(arguments);
    		return new Promise(function(resolve, reject) {
    			args.push(function(err, res) {
    				if (err) {
    					reject(err);
    				} else {
    					resolve(res);
    				}
    			});

    			var res = fn.apply(self, args);

    			var isPromise = res
    				&& (typeof res === 'object' || typeof res === 'function')
    				&& typeof res.then === 'function';

    			if (isPromise) {
    				resolve(res);
    			}
    		})
    	}
    };

    var eventemitter3 = createCommonjsModule(function (module) {

    var has = Object.prototype.hasOwnProperty
      , prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @api private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {Mixed} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @api private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @api public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @api public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = []
        , events
        , name;

      if (this._eventsCount === 0) return names;

      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }

      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }

      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Boolean} exists Only check if there are listeners.
     * @returns {Array|Boolean}
     * @api public
     */
    EventEmitter.prototype.listeners = function listeners(event, exists) {
      var evt = prefix ? prefix + event : event
        , available = this._events[evt];

      if (exists) return !!available;
      if (!available) return [];
      if (available.fn) return [available.fn];

      for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
        ee[i] = available[i].fn;
      }

      return ee;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @api public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return false;

      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;

      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }

        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }

        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;

        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }

              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }

      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      var listener = new EE(fn, context || this)
        , evt = prefix ? prefix + event : event;

      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];

      return this;
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      var listener = new EE(fn, context || this, true)
        , evt = prefix ? prefix + event : event;

      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];

      return this;
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {Mixed} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return this;
      if (!fn) {
        if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
        return this;
      }

      var listeners = this._events[evt];

      if (listeners.fn) {
        if (
             listeners.fn === fn
          && (!once || listeners.once)
          && (!context || listeners.context === context)
        ) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
      }

      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {String|Symbol} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;

      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }

      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // This function doesn't apply anymore.
    //
    EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
      return this;
    };

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    {
      module.exports = EventEmitter;
    }
    });

    var immutable = extend$1;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend$1() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    var strictUriEncode = function (str) {
    	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    	});
    };

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty$1.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    function encoderForArrayFormat(opts) {
    	switch (opts.arrayFormat) {
    		case 'index':
    			return function (key, value, index) {
    				return value === null ? [
    					encode$1(key, opts),
    					'[',
    					index,
    					']'
    				].join('') : [
    					encode$1(key, opts),
    					'[',
    					encode$1(index, opts),
    					']=',
    					encode$1(value, opts)
    				].join('');
    			};

    		case 'bracket':
    			return function (key, value) {
    				return value === null ? encode$1(key, opts) : [
    					encode$1(key, opts),
    					'[]=',
    					encode$1(value, opts)
    				].join('');
    			};

    		default:
    			return function (key, value) {
    				return value === null ? encode$1(key, opts) : [
    					encode$1(key, opts),
    					'=',
    					encode$1(value, opts)
    				].join('');
    			};
    	}
    }

    function parserForArrayFormat(opts) {
    	var result;

    	switch (opts.arrayFormat) {
    		case 'index':
    			return function (key, value, accumulator) {
    				result = /\[(\d*)\]$/.exec(key);

    				key = key.replace(/\[\d*\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				}

    				if (accumulator[key] === undefined) {
    					accumulator[key] = {};
    				}

    				accumulator[key][result[1]] = value;
    			};

    		case 'bracket':
    			return function (key, value, accumulator) {
    				result = /(\[\])$/.exec(key);
    				key = key.replace(/\[\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				} else if (accumulator[key] === undefined) {
    					accumulator[key] = [value];
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};

    		default:
    			return function (key, value, accumulator) {
    				if (accumulator[key] === undefined) {
    					accumulator[key] = value;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};
    	}
    }

    function encode$1(value, opts) {
    	if (opts.encode) {
    		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
    	}

    	return value;
    }

    function keysSorter(input) {
    	if (Array.isArray(input)) {
    		return input.sort();
    	} else if (typeof input === 'object') {
    		return keysSorter(Object.keys(input)).sort(function (a, b) {
    			return Number(a) - Number(b);
    		}).map(function (key) {
    			return input[key];
    		});
    	}

    	return input;
    }

    var extract = function (str) {
    	return str.split('?')[1] || '';
    };

    var parse$1 = function (str, opts) {
    	opts = objectAssign({arrayFormat: 'none'}, opts);

    	var formatter = parserForArrayFormat(opts);

    	// Create an object with no prototype
    	// https://github.com/sindresorhus/query-string/issues/47
    	var ret = Object.create(null);

    	if (typeof str !== 'string') {
    		return ret;
    	}

    	str = str.trim().replace(/^(\?|#|&)/, '');

    	if (!str) {
    		return ret;
    	}

    	str.split('&').forEach(function (param) {
    		var parts = param.replace(/\+/g, ' ').split('=');
    		// Firefox (pre 40) decodes `%3D` to `=`
    		// https://github.com/sindresorhus/query-string/pull/37
    		var key = parts.shift();
    		var val = parts.length > 0 ? parts.join('=') : undefined;

    		// missing `=` should be `null`:
    		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    		val = val === undefined ? null : decodeURIComponent(val);

    		formatter(decodeURIComponent(key), val, ret);
    	});

    	return Object.keys(ret).sort().reduce(function (result, key) {
    		var val = ret[key];
    		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
    			// Sort object keys, not values
    			result[key] = keysSorter(val);
    		} else {
    			result[key] = val;
    		}

    		return result;
    	}, Object.create(null));
    };

    var stringify = function (obj, opts) {
    	var defaults = {
    		encode: true,
    		strict: true,
    		arrayFormat: 'none'
    	};

    	opts = objectAssign(defaults, opts);

    	var formatter = encoderForArrayFormat(opts);

    	return obj ? Object.keys(obj).sort().map(function (key) {
    		var val = obj[key];

    		if (val === undefined) {
    			return '';
    		}

    		if (val === null) {
    			return encode$1(key, opts);
    		}

    		if (Array.isArray(val)) {
    			var result = [];

    			val.slice().forEach(function (val2) {
    				if (val2 === undefined) {
    					return;
    				}

    				result.push(formatter(key, val2, result.length));
    			});

    			return result.join('&');
    		}

    		return encode$1(key, opts) + '=' + encode$1(val, opts);
    	}).filter(function (x) {
    		return x.length > 0;
    	}).join('&') : '';
    };

    var queryString = {
    	extract: extract,
    	parse: parse$1,
    	stringify: stringify
    };

    var hashLocation = function HashLocation(window) {
    	var emitter = new eventemitter3();
    	var last = '';
    	var needToDecode = getNeedToDecode();

    	window.addEventListener('hashchange', function() {
    		if (last !== emitter.get()) {
    			last = emitter.get();
    			emitter.emit('hashchange');
    		}
    	});

    	emitter.go = go.bind(null, window);
    	emitter.replace = replace.bind(null, window);
    	emitter.get = get$1.bind(null, window, needToDecode);

    	return emitter
    };

    function replace(window, newPath) {
    	window.location.replace(everythingBeforeTheSlash(window.location.href) + '#' + newPath);
    }

    function everythingBeforeTheSlash(url) {
    	var hashIndex = url.indexOf('#');
    	return hashIndex === -1 ? url : url.substring(0, hashIndex)
    }

    function go(window, newPath) {
    	window.location.hash = newPath;
    }

    function get$1(window, needToDecode) {
    	var hash = removeHashFromPath(window.location.hash);
    	return needToDecode ? decodeURI(hash) : hash
    }

    function removeHashFromPath(path) {
    	return (path && path[0] === '#') ? path.substr(1) : path
    }

    function getNeedToDecode() {
    	var a = document.createElement('a');
    	a.href = '#x x';
    	return !/x x/.test(a.hash)
    }

    var hashBrownRouter = function Router(opts, hashLocation$$1) {
    	var emitter = new eventemitter3();
    	if (isHashLocation(opts)) {
    		hashLocation$$1 = opts;
    		opts = null;
    	}

    	opts = opts || {};

    	if (!hashLocation$$1) {
    		hashLocation$$1 = hashLocation(window);
    	}

    	function onNotFound(path, queryStringParameters) {
    		emitter.emit('not found', path, queryStringParameters);
    	}

    	var routes = [];

    	var onHashChange = evaluateCurrentPath.bind(null, routes, hashLocation$$1, !!opts.reverse, onNotFound);

    	hashLocation$$1.on('hashchange', onHashChange);

    	function stop() {
    		hashLocation$$1.removeListener('hashchange', onHashChange);
    	}

    	emitter.add = add.bind(null, routes);
    	emitter.stop = stop;
    	emitter.evaluateCurrent = evaluateCurrentPathOrGoToDefault.bind(null, routes, hashLocation$$1, !!opts.reverse, onNotFound);
    	emitter.replace = hashLocation$$1.replace;
    	emitter.go = hashLocation$$1.go;
    	emitter.location = hashLocation$$1;

    	return emitter
    };

    function evaluateCurrentPath(routes, hashLocation$$1, reverse, onNotFound) {
    	evaluatePath(routes, hashLocation$$1.get(), reverse, onNotFound);
    }

    function getPathParts(path) {
    	var chunks = path.split('?');
    	return {
    		path: chunks.shift(),
    		queryString: queryString.parse(chunks.join(''))
    	}
    }

    function evaluatePath(routes, path, reverse, onNotFound) {
    	var pathParts = getPathParts(path);
    	path = pathParts.path;
    	var queryStringParameters = pathParts.queryString;

    	var matchingRoute = find((reverse ? reverseArray(routes) : routes), path);

    	if (matchingRoute) {
    		var regexResult = matchingRoute.exec(path);
    		var routeParameters = makeParametersObjectFromRegexResult(matchingRoute.keys, regexResult);
    		var params = immutable(queryStringParameters, routeParameters);
    		matchingRoute.fn(params);
    	} else {
    		onNotFound(path, queryStringParameters);
    	}
    }

    function reverseArray(ary) {
    	return ary.slice().reverse()
    }

    function makeParametersObjectFromRegexResult(keys, regexResult) {
    	return keys.reduce(function(memo, urlKey, index) {
    		memo[urlKey.name] = regexResult[index + 1];
    		return memo
    	}, {})
    }

    function add(routes, routeString, routeFunction) {
    	if (typeof routeFunction !== 'function') {
    		throw new Error('The router add function must be passed a callback function')
    	}
    	var newRoute = pathToRegexpWithReversibleKeys(routeString);
    	newRoute.fn = routeFunction;
    	routes.push(newRoute);
    }

    function evaluateCurrentPathOrGoToDefault(routes, hashLocation$$1, reverse, onNotFound, defaultPath) {
    	const currentLocation = hashLocation$$1.get();
    	if (currentLocation && currentLocation !== '/') {
    		var routesCopy = routes.slice();

    		evaluateCurrentPath(routesCopy, hashLocation$$1, reverse, onNotFound);
    	} else {
    		hashLocation$$1.go(defaultPath);
    	}
    }

    function isHashLocation(hashLocation$$1) {
    	return hashLocation$$1 && hashLocation$$1.go && hashLocation$$1.replace && hashLocation$$1.on
    }

    function find(aryOfRegexes, str) {
    	for (var i = 0; i < aryOfRegexes.length; ++i) {
    		if (str.match(aryOfRegexes[i])) {
    			return aryOfRegexes[i]
    		}
    	}
    }

    // This file to be replaced with an official implementation maintained by
    // the page.js crew if and when that becomes an option



    var pathParser = function(pathString) {
    	var parseResults = pathToRegexpWithReversibleKeys(pathString);

    	// The only reason I'm returning a new object instead of the results of the pathToRegexp
    	// function is so that if the official implementation ends up returning an
    	// allTokens-style array via some other mechanism, I may be able to change this file
    	// without having to change the rest of the module in index.js
    	return {
    		regex: parseResults,
    		allTokens: parseResults.allTokens
    	}
    };

    var stringifyQuerystring = queryString.stringify;

    var pagePathBuilder = function(pathStr, parameters) {
    	var parsed = typeof pathStr === 'string' ? pathParser(pathStr) : pathStr;
    	var allTokens = parsed.allTokens;
    	var regex = parsed.regex;

    	if (parameters) {
    		var path = allTokens.map(function(bit) {
    			if (bit.string) {
    				return bit.string
    			}

    			var defined = typeof parameters[bit.name] !== 'undefined';
    			if (!bit.optional && !defined) {
    				throw new Error('Must supply argument ' + bit.name + ' for path ' + pathStr)
    			}

    			return defined ? (bit.delimiter + encodeURIComponent(parameters[bit.name])) : ''
    		}).join('');

    		if (!regex.test(path)) {
    			throw new Error('Provided arguments do not match the original arguments')
    		}

    		return buildPathWithQuerystring(path, parameters, allTokens)
    	} else {
    		return parsed
    	}
    };

    function buildPathWithQuerystring(path, parameters, tokenArray) {
    	var parametersInQuerystring = getParametersWithoutMatchingToken(parameters, tokenArray);

    	if (Object.keys(parametersInQuerystring).length === 0) {
    		return path
    	}

    	return path + '?' + stringifyQuerystring(parametersInQuerystring)
    }

    function getParametersWithoutMatchingToken(parameters, tokenArray) {
    	var tokenHash = tokenArray.reduce(function(memo, bit) {
    		if (!bit.string) {
    			memo[bit.name] = bit;
    		}
    		return memo
    	}, {});

    	return Object.keys(parameters).filter(function(param) {
    		return !tokenHash[param]
    	}).reduce(function(newParameters, param) {
    		newParameters[param] = parameters[param];
    		return newParameters
    	}, {})
    }

    var browser$1 = function (fn) {
      typeof setImmediate === 'function' ?
        setImmediate(fn) :
        setTimeout(fn, 0);
    };

    var expectedPropertiesOfAddState = [ 'name', 'route', 'defaultChild', 'data', 'template', 'resolve', 'activate', 'querystringParameters', 'defaultQuerystringParameters', 'defaultParameters' ];

    var abstractStateRouter = function StateProvider(makeRenderer, rootElement, stateRouterOptions) {
    	var prototypalStateHolder = stateState();
    	var lastCompletelyLoadedState = currentState();
    	var lastStateStartedActivating = currentState();
    	var stateProviderEmitter = new eventemitter3();
    	stateTransitionManager(stateProviderEmitter);
    	stateRouterOptions = immutable({
    		throwOnError: true,
    		pathPrefix: '#'
    	}, stateRouterOptions);

    	if (!stateRouterOptions.router) {
    		stateRouterOptions.router = hashBrownRouter(defaultRouterOptions);
    	}

    	stateRouterOptions.router.on('not found', function(route, parameters) {
    		stateProviderEmitter.emit('routeNotFound', route, parameters);
    	});

    	var destroyDom = null;
    	var getDomChild = null;
    	var renderDom = null;
    	var resetDom = null;

    	var activeDomApis = {};
    	var activeStateResolveContent = {};
    	var activeEmitters = {};

    	function handleError(event, err) {
    		browser$1(function() {
    			stateProviderEmitter.emit(event, err);
    			console.error(event + ' - ' + err.message);
    			if (stateRouterOptions.throwOnError) {
    				throw err
    			}
    		});
    	}

    	function destroyStateName(stateName) {
    		var state = prototypalStateHolder.get(stateName);
    		stateProviderEmitter.emit('beforeDestroyState', {
    			state: state,
    			domApi: activeDomApis[stateName]
    		});

    		activeEmitters[stateName].emit('destroy');
    		activeEmitters[stateName].removeAllListeners();
    		delete activeEmitters[stateName];
    		delete activeStateResolveContent[stateName];

    		return destroyDom(activeDomApis[stateName]).then(function() {
    			delete activeDomApis[stateName];
    			stateProviderEmitter.emit('afterDestroyState', {
    				state: state
    			});
    		})
    	}

    	function resetStateName(parameters, stateName) {
    		var domApi = activeDomApis[stateName];
    		var content = getContentObject(activeStateResolveContent, stateName);
    		var state = prototypalStateHolder.get(stateName);

    		stateProviderEmitter.emit('beforeResetState', {
    			domApi: domApi,
    			content: content,
    			state: state,
    			parameters: parameters
    		});

    		activeEmitters[stateName].emit('destroy');
    		delete activeEmitters[stateName];

    		return resetDom({
    			domApi: domApi,
    			content: content,
    			template: state.template,
    			parameters: parameters
    		}).then(function(newDomApi) {
    			if (newDomApi) {
    				activeDomApis[stateName] = newDomApi;
    			}

    			stateProviderEmitter.emit('afterResetState', {
    				domApi: activeDomApis[stateName],
    				content: content,
    				state: state,
    				parameters: parameters
    			});
    		})
    	}

    	function getChildElementForStateName(stateName) {
    		return new Promise(function(resolve) {
    			var parent = prototypalStateHolder.getParent(stateName);
    			if (parent) {
    				var parentDomApi = activeDomApis[parent.name];
    				resolve(getDomChild(parentDomApi));
    			} else {
    				resolve(rootElement);
    			}
    		})
    	}

    	function renderStateName(parameters, stateName) {
    		return getChildElementForStateName(stateName).then(function(childElement) {
    			var state = prototypalStateHolder.get(stateName);
    			var content = getContentObject(activeStateResolveContent, stateName);

    			stateProviderEmitter.emit('beforeCreateState', {
    				state: state,
    				content: content,
    				parameters: parameters
    			});

    			return renderDom({
    				element: childElement,
    				template: state.template,
    				content: content,
    				parameters: parameters
    			}).then(function(domApi) {
    				activeDomApis[stateName] = domApi;
    				stateProviderEmitter.emit('afterCreateState', {
    					state: state,
    					domApi: domApi,
    					content: content,
    					parameters: parameters
    				});
    				return domApi
    			})
    		})
    	}

    	function renderAll(stateNames, parameters) {
    		return promiseMapSeries(stateNames, renderStateName.bind(null, parameters))
    	}

    	function onRouteChange(state, parameters) {
    		try {
    			var finalDestinationStateName = prototypalStateHolder.applyDefaultChildStates(state.name);

    			if (finalDestinationStateName === state.name) {
    				emitEventAndAttemptStateChange(finalDestinationStateName, parameters);
    			} else {
    				// There are default child states that need to be applied

    				var theRouteWeNeedToEndUpAt = makePath(finalDestinationStateName, parameters);
    				var currentRoute = stateRouterOptions.router.location.get();

    				if (theRouteWeNeedToEndUpAt === currentRoute) {
    					// the child state has the same route as the current one, just start navigating there
    					emitEventAndAttemptStateChange(finalDestinationStateName, parameters);
    				} else {
    					// change the url to match the full default child state route
    					stateProviderEmitter.go(finalDestinationStateName, parameters, { replace: true });
    				}
    			}
    		} catch (err) {
    			handleError('stateError', err);
    		}
    	}

    	function addState(state) {
    		if (typeof state === 'undefined') {
    			throw new Error('Expected \'state\' to be passed in.')
    		} else if (typeof state.name === 'undefined') {
    			throw new Error('Expected the \'name\' option to be passed in.')
    		} else if (typeof state.template === 'undefined') {
    			throw new Error('Expected the \'template\' option to be passed in.')
    		}
    		Object.keys(state).filter(function(key) {
    			return expectedPropertiesOfAddState.indexOf(key) === -1
    		}).forEach(function(key) {
    			console.warn('Unexpected property passed to addState:', key);
    		});

    		prototypalStateHolder.add(state.name, state);

    		var route = prototypalStateHolder.buildFullStateRoute(state.name);

    		stateRouterOptions.router.add(route, onRouteChange.bind(null, state));
    	}

    	function getStatesToResolve(stateChanges) {
    		return stateChanges.change.concat(stateChanges.create).map(prototypalStateHolder.get)
    	}

    	function emitEventAndAttemptStateChange(newStateName, parameters) {
    		stateProviderEmitter.emit('stateChangeAttempt', function stateGo(transition) {
    			attemptStateChange(newStateName, parameters, transition);
    		});
    	}

    	function attemptStateChange(newStateName, parameters, transition) {
    		function ifNotCancelled(fn) {
    			return function() {
    				if (transition.cancelled) {
    					var err = new Error('The transition to ' + newStateName + 'was cancelled');
    					err.wasCancelledBySomeoneElse = true;
    					throw err
    				} else {
    					return fn.apply(null, arguments)
    				}
    			}
    		}

    		return promiseMe(prototypalStateHolder.guaranteeAllStatesExist, newStateName)
    		.then(function applyDefaultParameters() {
    			var state = prototypalStateHolder.get(newStateName);
    			var defaultParams = state.defaultParameters || state.defaultQuerystringParameters || {};
    			var needToApplyDefaults = Object.keys(defaultParams).some(function missingParameterValue(param) {
    				return typeof parameters[param] === 'undefined'
    			});

    			if (needToApplyDefaults) {
    				throw redirector(newStateName, immutable(defaultParams, parameters))
    			}
    			return state
    		}).then(ifNotCancelled(function(state) {
    			stateProviderEmitter.emit('stateChangeStart', state, parameters);
    			lastStateStartedActivating.set(state.name, parameters);
    		})).then(function getStateChanges() {
    			var stateComparisonResults = stateComparison_1(prototypalStateHolder)(lastCompletelyLoadedState.get().name, lastCompletelyLoadedState.get().parameters, newStateName, parameters);
    			return stateChangeLogic(stateComparisonResults) // { destroy, change, create }
    		}).then(ifNotCancelled(function resolveDestroyAndActivateStates(stateChanges) {
    			return resolveStates(getStatesToResolve(stateChanges), immutable(parameters)).catch(function onResolveError(e) {
    				e.stateChangeError = true;
    				throw e
    			}).then(ifNotCancelled(function destroyAndActivate(stateResolveResultsObject) {
    				transition.cancellable = false;

    				function activateAll() {
    					var statesToActivate = stateChanges.change.concat(stateChanges.create);

    					return activateStates(statesToActivate)
    				}

    				activeStateResolveContent = immutable(activeStateResolveContent, stateResolveResultsObject);

    				return promiseMapSeries(reverse(stateChanges.destroy), destroyStateName).then(function() {
    					return promiseMapSeries(reverse(stateChanges.change), resetStateName.bind(null, immutable(parameters)))
    				}).then(function() {
    					return renderAll(stateChanges.create, immutable(parameters)).then(activateAll)
    				})
    			}))

    			function activateStates(stateNames) {
    				return stateNames.map(prototypalStateHolder.get).forEach(function(state) {
    					var emitter = new eventemitter3();
    					var context = Object.create(emitter);
    					context.domApi = activeDomApis[state.name];
    					context.data = state.data;
    					context.parameters = parameters;
    					context.content = getContentObject(activeStateResolveContent, state.name);
    					activeEmitters[state.name] = emitter;

    					try {
    						state.activate && state.activate(context);
    					} catch (e) {
    						browser$1(function() {
    							throw e
    						});
    					}
    				})
    			}
    		})).then(function stateChangeComplete() {
    			lastCompletelyLoadedState.set(newStateName, parameters);
    			try {
    				stateProviderEmitter.emit('stateChangeEnd', prototypalStateHolder.get(newStateName), parameters);
    			} catch (e) {
    				handleError('stateError', e);
    			}
    		}).catch(ifNotCancelled(function handleStateChangeError(err) {
    			if (err && err.redirectTo) {
    				stateProviderEmitter.emit('stateChangeCancelled', err);
    				return stateProviderEmitter.go(err.redirectTo.name, err.redirectTo.params, { replace: true })
    			} else if (err) {
    				handleError('stateChangeError', err);
    			}
    		})).catch(function handleCancellation(err) {
    			if (err && err.wasCancelledBySomeoneElse) ; else {
    				throw new Error("This probably shouldn't happen, maybe file an issue or something " + err)
    			}
    		})
    	}

    	function makePath(stateName, parameters, options) {
    		function getGuaranteedPreviousState() {
    			if (!lastStateStartedActivating.get().name) {
    				throw new Error('makePath required a previous state to exist, and none was found')
    			}
    			return lastStateStartedActivating.get()
    		}
    		if (options && options.inherit) {
    			parameters = immutable(getGuaranteedPreviousState().parameters, parameters);
    		}

    		var destinationStateName = stateName === null ? getGuaranteedPreviousState().name : stateName;

    		var destinationState = prototypalStateHolder.get(destinationStateName) || {};
    		var defaultParams = destinationState.defaultParameters || destinationState.defaultQuerystringParameters;

    		parameters = immutable(defaultParams, parameters);

    		prototypalStateHolder.guaranteeAllStatesExist(destinationStateName);
    		var route = prototypalStateHolder.buildFullStateRoute(destinationStateName);
    		return pagePathBuilder(route, parameters || {})
    	}

    	var defaultOptions = {
    		replace: false
    	};

    	stateProviderEmitter.addState = addState;
    	stateProviderEmitter.go = function go(newStateName, parameters, options) {
    		options = immutable(defaultOptions, options);
    		var goFunction = options.replace ? stateRouterOptions.router.replace : stateRouterOptions.router.go;

    		return promiseMe(makePath, newStateName, parameters, options).then(goFunction, handleError.bind(null, 'stateChangeError'))
    	};
    	stateProviderEmitter.evaluateCurrentRoute = function evaluateCurrentRoute(defaultState, defaultParams) {
    		return promiseMe(makePath, defaultState, defaultParams).then(function(defaultPath) {
    			stateRouterOptions.router.evaluateCurrent(defaultPath);
    		}).catch(function(err) {
    			handleError('stateError', err);
    		})
    	};
    	stateProviderEmitter.makePath = function makePathAndPrependHash(stateName, parameters, options) {
    		return stateRouterOptions.pathPrefix + makePath(stateName, parameters, options)
    	};
    	stateProviderEmitter.stateIsActive = function stateIsActive(stateName, opts) {
    		var currentState$$1 = lastCompletelyLoadedState.get();
    		return (currentState$$1.name === stateName || currentState$$1.name.indexOf(stateName + '.') === 0) && (typeof opts === 'undefined' || Object.keys(opts).every(function matches(key) {
    			return opts[key] === currentState$$1.parameters[key]
    		}))
    	};

    	var renderer = makeRenderer(stateProviderEmitter);

    	destroyDom = thenDenodeify(renderer.destroy);
    	getDomChild = thenDenodeify(renderer.getChildElement);
    	renderDom = thenDenodeify(renderer.render);
    	resetDom = thenDenodeify(renderer.reset);

    	return stateProviderEmitter
    };

    function getContentObject(stateResolveResultsObject, stateName) {
    	var allPossibleResolvedStateNames = stateStringParser(stateName);

    	return allPossibleResolvedStateNames.filter(function(stateName) {
    		return stateResolveResultsObject[stateName]
    	}).reduce(function(obj, stateName) {
    		return immutable(obj, stateResolveResultsObject[stateName])
    	}, {})
    }

    function redirector(newStateName, parameters) {
    	return {
    		redirectTo: {
    			name: newStateName,
    			params: parameters
    		}
    	}
    }

    // { [stateName]: resolveResult }
    function resolveStates(states, parameters) {
    	var statesWithResolveFunctions = states.filter(isFunction$1('resolve'));
    	var stateNamesWithResolveFunctions = statesWithResolveFunctions.map(property('name'));
    	var resolves = Promise.all(statesWithResolveFunctions.map(function(state) {
    		return new Promise(function(resolve, reject) {
    			function resolveCb(err, content) {
    				err ? reject(err) : resolve(content);
    			}

    			resolveCb.redirect = function redirect(newStateName, parameters) {
    				reject(redirector(newStateName, parameters));
    			};

    			var res = state.resolve(state.data, parameters, resolveCb);
    			if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
    				resolve(res);
    			}
    		})
    	}));

    	return resolves.then(function(resolveResults) {
    		return combineArrays({
    			stateName: stateNamesWithResolveFunctions,
    			resolveResult: resolveResults
    		}).reduce(function(obj, result) {
    			obj[result.stateName] = result.resolveResult;
    			return obj
    		}, {})
    	})
    }

    function property(name) {
    	return function(obj) {
    		return obj[name]
    	}
    }

    function reverse(ary) {
    	return ary.slice().reverse()
    }

    function isFunction$1(property) {
    	return function(obj) {
    		return typeof obj[property] === 'function'
    	}
    }

    function promiseMe() {
    	var fn = Array.prototype.shift.apply(arguments);
    	var args = arguments;
    	return new Promise(function(resolve) {
    		resolve(fn.apply(null, args));
    	})
    }

    var deepmerge = createCommonjsModule(function (module, exports) {
    (function (root, factory) {
        {
            module.exports = factory();
        }
    }(commonjsGlobal, function () {

    function isMergeableObject(val) {
        var nonNullObject = val && typeof val === 'object';

        return nonNullObject
            && Object.prototype.toString.call(val) !== '[object RegExp]'
            && Object.prototype.toString.call(val) !== '[object Date]'
    }

    function emptyTarget(val) {
        return Array.isArray(val) ? [] : {}
    }

    function cloneIfNecessary(value, optionsArgument) {
        var clone = optionsArgument && optionsArgument.clone === true;
        return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
    }

    function defaultArrayMerge(target, source, optionsArgument) {
        var destination = target.slice();
        source.forEach(function(e, i) {
            if (typeof destination[i] === 'undefined') {
                destination[i] = cloneIfNecessary(e, optionsArgument);
            } else if (isMergeableObject(e)) {
                destination[i] = deepmerge(target[i], e, optionsArgument);
            } else if (target.indexOf(e) === -1) {
                destination.push(cloneIfNecessary(e, optionsArgument));
            }
        });
        return destination
    }

    function mergeObject(target, source, optionsArgument) {
        var destination = {};
        if (isMergeableObject(target)) {
            Object.keys(target).forEach(function (key) {
                destination[key] = cloneIfNecessary(target[key], optionsArgument);
            });
        }
        Object.keys(source).forEach(function (key) {
            if (!isMergeableObject(source[key]) || !target[key]) {
                destination[key] = cloneIfNecessary(source[key], optionsArgument);
            } else {
                destination[key] = deepmerge(target[key], source[key], optionsArgument);
            }
        });
        return destination
    }

    function deepmerge(target, source, optionsArgument) {
        var array = Array.isArray(source);
        var options = optionsArgument || { arrayMerge: defaultArrayMerge };
        var arrayMerge = options.arrayMerge || defaultArrayMerge;

        if (array) {
            return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)
        } else {
            return mergeObject(target, source, optionsArgument)
        }
    }

    deepmerge.all = function deepmergeAll(array, optionsArgument) {
        if (!Array.isArray(array) || array.length < 2) {
            throw new Error('first argument should be an array with at least two elements')
        }

        // we are sure there are at least 2 values, so it is safe to have no initial value
        return array.reduce(function(prev, next) {
            return deepmerge(prev, next, optionsArgument)
        })
    };

    return deepmerge

    }));
    });

    var svelteStateRenderer = function SvelteStateRendererFactory(defaultOptions = {}) {
    	return function makeRenderer(stateRouter) {
    		const asr = {
    			makePath: stateRouter.makePath,
    			stateIsActive: stateRouter.stateIsActive,
    		};

    		function render(context, cb) {
    			const { element: target, template, content } = context;

    			const rendererSuppliedOptions = deepmerge(defaultOptions, {
    				target,
    				data: Object.assign(content, defaultOptions.data, { asr }),
    			});

    			function construct(component, options) {
    				return options.methods
    					? instantiateWithMethods(component, options, options.methods)
    					: new component(options)
    			}

    			let svelte;

    			try {
    				if (typeof template === `function`) {
    					svelte = construct(template, rendererSuppliedOptions);
    				} else {
    					const options = deepmerge(rendererSuppliedOptions, template.options);

    					svelte = construct(template.component, options);
    				}
    			} catch (e) {
    				cb(e);
    				return
    			}

    			function onRouteChange() {
    				svelte.set({
    					asr,
    				});
    			}

    			stateRouter.on(`stateChangeEnd`, onRouteChange);

    			svelte.on(`destroy`, () => {
    				stateRouter.removeListener(`stateChangeEnd`, onRouteChange);
    			});

    			svelte.mountedToTarget = target;
    			cb(null, svelte);
    		}

    		return {
    			render,
    			reset: function reset(context, cb) {
    				const svelte = context.domApi;
    				const element = svelte.mountedToTarget;

    				svelte.destroy();

    				const renderContext = Object.assign({ element }, context);

    				render(renderContext, cb);
    			},
    			destroy: function destroy(svelte, cb) {
    				svelte.destroy();
    				cb();
    			},
    			getChildElement: function getChildElement(svelte, cb) {
    				try {
    					const element = svelte.mountedToTarget;
    					const child = element.querySelector(`uiView`);
    					cb(null, child);
    				} catch (e) {
    					cb(e);
    				}
    			},
    		}
    	}
    };

    function instantiateWithMethods(Component, options, methods) {
    	// const coolPrototype = Object.assign(Object.create(Component.prototype), methods)
    	// return Component.call(coolPrototype, options)
    	return Object.assign(new Component(options), methods)
    }

    /* src\components\Home.html generated by Svelte v2.9.5 */

    function data$2() {
    	return {
    		canViewHelpFiles: false
    	};
    }
    function oncreate$2() {
    	const { app } = this.get();
    	this.set({
    		canViewHelpFiles: app.getForm("help") != null
    	});
    }
    const file$3 = "src\\components\\Home.html";

    function add_css() {
    	var style = createElement("style");
    	style.id = 'svelte-7vrtj0-style';
    	style.textContent = "p.svelte-7vrtj0{margin-top:20px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSG9tZS5odG1sIiwic291cmNlcyI6WyJIb21lLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBjYW5WaWV3SGVscEZpbGVzID09PSB0cnVlfVxyXG48cD5cclxuXHRXZWxjb21lIHRvIHRoZSBVaW1mQXBwLiBUbyBoZWxwIHlvdSBnZXQgc3RhcnRlZCwgcGxlYXNlIDxhIGhyZWY9XCIvIy9mb3JtL2hlbHA/RmlsZUlkPWludHJvLm1kXCI+cmVhZCB0aGUgZG9jdW1lbnRhdGlvbjwvYT4uXHJcbjwvcD5cclxuezplbHNlfVxyXG48cD5XZWxjb21lIHRvIFVpbWZBcHAuPC9wPlxyXG57L2lmfVxyXG5cclxuPHNjcmlwdD5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgeyBhcHAgfSA9IHRoaXMuZ2V0KCk7XHJcblx0XHRcdHRoaXMuc2V0KHtcclxuXHRcdFx0XHRjYW5WaWV3SGVscEZpbGVzOiBhcHAuZ2V0Rm9ybShcImhlbHBcIikgIT0gbnVsbFxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblx0XHRkYXRhKCkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNhblZpZXdIZWxwRmlsZXM6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0cCB7XHJcblx0XHRtYXJnaW4tdG9wOiAyMHB4O1xyXG5cdH1cclxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBeUJDLENBQUMsY0FBQyxDQUFDLEFBQ0YsVUFBVSxDQUFFLElBQUksQUFDakIsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$3(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.canViewHelpFiles === true) return create_if_block$3;
    		return create_if_block_1$2;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if canViewHelpFiles === true}
    function create_if_block$3(component, ctx) {
    	var p, text, a, text_1, text_2;

    	return {
    		c: function create() {
    			p = createElement("p");
    			text = createText("Welcome to the UimfApp. To help you get started, please ");
    			a = createElement("a");
    			text_1 = createText("read the documentation");
    			text_2 = createText(".");
    			a.href = "/#/form/help?FileId=intro.md";
    			addLoc(a, file$3, 2, 57, 95);
    			p.className = "svelte-7vrtj0";
    			addLoc(p, file$3, 1, 0, 33);
    		},

    		m: function mount(target, anchor) {
    			insertNode(p, target, anchor);
    			appendNode(text, p);
    			appendNode(a, p);
    			appendNode(text_1, a);
    			appendNode(text_2, p);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(p);
    			}
    		}
    	};
    }

    // (5:0) {:else}
    function create_if_block_1$2(component, ctx) {
    	var p, text;

    	return {
    		c: function create() {
    			p = createElement("p");
    			text = createText("Welcome to UimfApp.");
    			p.className = "svelte-7vrtj0";
    			addLoc(p, file$3, 5, 0, 178);
    		},

    		m: function mount(target, anchor) {
    			insertNode(p, target, anchor);
    			appendNode(text, p);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(p);
    			}
    		}
    	};
    }

    function SvelteComponent$3(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign(data$2(), options.data);
    	if (!('canViewHelpFiles' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'canViewHelpFiles'");
    	this._intro = true;

    	if (!document.getElementById("svelte-7vrtj0-style")) add_css();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$3(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$2.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$3.prototype, protoDev);

    SvelteComponent$3.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\help\Tooltip.html generated by Svelte v2.9.5 */

    const file$4 = "src\\core\\ui\\help\\Tooltip.html";

    function create_main_fragment$4(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.data) && create_if_block$4(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.data) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$4(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if data }
    function create_if_block$4(component, ctx) {
    	var span, raw_value = ctx.data.content;

    	return {
    		c: function create() {
    			span = createElement("span");
    			span.className = "tooltiptext";
    			addLoc(span, file$4, 1, 1, 14);
    		},

    		m: function mount(target, anchor) {
    			insertNode(span, target, anchor);
    			span.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.data) && raw_value !== (raw_value = ctx.data.content)) {
    				span.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    function SvelteComponent$4(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('data' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'data'");
    	this._intro = true;

    	this._fragment = create_main_fragment$4(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$4.prototype, protoDev);

    SvelteComponent$4.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\Input.html generated by Svelte v2.9.5 */

    let inputId = 0;

    function data$3() {
    	inputId += 1;
    	return {
    		id: `i${inputId}`,
    		visible: false
    	};
    }
    var methods = {
    	show(visible) {
    		const { field } = this.get();
    		const currentlyVisible = !!this.get().visible;

    		this.set({ visible: !!visible });

    		if (currentlyVisible === false && visible === true) {
    			const { app } = this.get();
    			const input = app.controlRegister.getInput(field.metadata.type);

    			// eslint-disable-next-line
    			new input.component({
    				target: this.refs.container,
    				data: {
    					field,
    					tabindex: this.get().tabindex,
    					id: this.get().id,
    					app,
    					form: this.get().form,
    					wrapper: this
    				}
    			});
    		}

    		if (!visible) {
    			field.value = null;
    		}
    	}
    };

    function oncreate$3() {
    	const { field, app } = this.get();

    	const input = app.controlRegister.getInput(field.metadata.type);

    	// Set correct css class based on the field type.
    	const inputDisplayConfig = field.constants || input.constants || {};

    	const cssClass = field.metadata.customProperties != null ? field.metadata.customProperties.cssClass : null;

    	// Set correct css class based on the field type.
    	if (inputDisplayConfig.block) {
    		this.set({ class: `block ${cssClass}` });
    	}
    	else {
    		this.set({ class: `inline ${cssClass}` });
    	}

    	this.set({
    		class: cssClass,
    		alwaysHideLabel: inputDisplayConfig.alwaysHideLabel
    	});

    	const { inputs } = this.get().form.get();
    	// If `inputs` is null, then it means our parent form has been closed
    	// and "destroyed". In such cases we should just return.
    	// TODO: find a better way to implement "parent form null check".
    	if (inputs != null) {
    		// Register input in the parent form.
    		inputs.push(this);
    	}

    	const isVisible = !field.metadata.eventHandlers.length ||
    		field.metadata.eventHandlers.find(t => t.id === "depend-on") == null;

    	this.show(isVisible);
    }
    const file$5 = "src\\core\\ui\\Input.html";

    function add_css$1() {
    	var style = createElement("style");
    	style.id = 'svelte-1izjarg-style';
    	style.textContent = ".inline.svelte-1izjarg{display:inline-block}.col-form-label.svelte-1izjarg{padding-left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXQuaHRtbCIsInNvdXJjZXMiOlsiSW5wdXQuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHZpc2libGV9XHJcbiAgICB7I2lmICFhbHdheXNIaWRlTGFiZWwgJiYgZmllbGQubWV0YWRhdGEubGFiZWwgIT09IFwiXCIgfVxyXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAge2NsYXNzfVwiPlxyXG4gICAgICAgIDxsYWJlbCBmb3I9XCJ7aWR9XCIgY2xhc3M9XCJjb2wtZm9ybS1sYWJlbFwiPlxyXG4gICAgICAgICAgICB7I2lmIGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCAmJiBmaWVsZC5tZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzW1wiZG9jdW1lbnRhdGlvblwiXSAhPSBudWxsfVxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaGVscC10b29sdGlwXCI+e2ZpZWxkLm1ldGFkYXRhLmxhYmVsfTpcclxuICAgICAgICAgICAgICAgIDxUb29sdGlwIGRhdGE9XCJ7ZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5kb2N1bWVudGF0aW9uWzBdfVwiPjwvVG9vbHRpcD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHs6ZWxzZX1cclxuICAgICAgICAgICAge2ZpZWxkLm1ldGFkYXRhLmxhYmVsfTpcclxuICAgICAgICAgICAgey9pZn1cclxuICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgIDxkaXYgcmVmOmNvbnRhaW5lciBjbGFzcz1cImlucHV0LWNvbnRhaW5lclwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICB7OmVsc2V9XHJcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCB7Y2xhc3N9XCI+XHJcbiAgICAgICAgPGRpdiByZWY6Y29udGFpbmVyIGNsYXNzPVwiaW5wdXQtY29udGFpbmVyXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIHsvaWZ9XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGltcG9ydCBUb29sdGlwIGZyb20gXCIuL2hlbHAvVG9vbHRpcFwiO1xyXG5cclxuXHRsZXQgaW5wdXRJZCA9IDA7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCB7IGZpZWxkLCBhcHAgfSA9IHRoaXMuZ2V0KCk7XHJcblxyXG5cdFx0XHRjb25zdCBpbnB1dCA9IGFwcC5jb250cm9sUmVnaXN0ZXIuZ2V0SW5wdXQoZmllbGQubWV0YWRhdGEudHlwZSk7XHJcblxyXG5cdFx0XHQvLyBTZXQgY29ycmVjdCBjc3MgY2xhc3MgYmFzZWQgb24gdGhlIGZpZWxkIHR5cGUuXHJcblx0XHRcdGNvbnN0IGlucHV0RGlzcGxheUNvbmZpZyA9IGZpZWxkLmNvbnN0YW50cyB8fCBpbnB1dC5jb25zdGFudHMgfHwge307XHJcblxyXG5cdFx0XHRjb25zdCBjc3NDbGFzcyA9IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMgIT0gbnVsbCA/IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMuY3NzQ2xhc3MgOiBudWxsO1xyXG5cclxuXHRcdFx0Ly8gU2V0IGNvcnJlY3QgY3NzIGNsYXNzIGJhc2VkIG9uIHRoZSBmaWVsZCB0eXBlLlxyXG5cdFx0XHRpZiAoaW5wdXREaXNwbGF5Q29uZmlnLmJsb2NrKSB7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBjbGFzczogYGJsb2NrICR7Y3NzQ2xhc3N9YCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IGNsYXNzOiBgaW5saW5lICR7Y3NzQ2xhc3N9YCB9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdGNsYXNzOiBjc3NDbGFzcyxcclxuXHRcdFx0XHRhbHdheXNIaWRlTGFiZWw6IGlucHV0RGlzcGxheUNvbmZpZy5hbHdheXNIaWRlTGFiZWxcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCB7IGlucHV0cyB9ID0gdGhpcy5nZXQoKS5mb3JtLmdldCgpO1xyXG5cdFx0XHQvLyBJZiBgaW5wdXRzYCBpcyBudWxsLCB0aGVuIGl0IG1lYW5zIG91ciBwYXJlbnQgZm9ybSBoYXMgYmVlbiBjbG9zZWRcclxuXHRcdFx0Ly8gYW5kIFwiZGVzdHJveWVkXCIuIEluIHN1Y2ggY2FzZXMgd2Ugc2hvdWxkIGp1c3QgcmV0dXJuLlxyXG5cdFx0XHQvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSB0byBpbXBsZW1lbnQgXCJwYXJlbnQgZm9ybSBudWxsIGNoZWNrXCIuXHJcblx0XHRcdGlmIChpbnB1dHMgIT0gbnVsbCkge1xyXG5cdFx0XHRcdC8vIFJlZ2lzdGVyIGlucHV0IGluIHRoZSBwYXJlbnQgZm9ybS5cclxuXHRcdFx0XHRpbnB1dHMucHVzaCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgaXNWaXNpYmxlID0gIWZpZWxkLm1ldGFkYXRhLmV2ZW50SGFuZGxlcnMubGVuZ3RoIHx8XHJcblx0XHRcdFx0ZmllbGQubWV0YWRhdGEuZXZlbnRIYW5kbGVycy5maW5kKHQgPT4gdC5pZCA9PT0gXCJkZXBlbmQtb25cIikgPT0gbnVsbDtcclxuXHJcblx0XHRcdHRoaXMuc2hvdyhpc1Zpc2libGUpO1xyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdGlucHV0SWQgKz0gMTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRpZDogYGkke2lucHV0SWR9YCxcclxuXHRcdFx0XHR2aXNpYmxlOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0c2hvdyh2aXNpYmxlKSB7XHJcblx0XHRcdFx0Y29uc3QgeyBmaWVsZCB9ID0gdGhpcy5nZXQoKTtcclxuXHRcdFx0XHRjb25zdCBjdXJyZW50bHlWaXNpYmxlID0gISF0aGlzLmdldCgpLnZpc2libGU7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0KHsgdmlzaWJsZTogISF2aXNpYmxlIH0pO1xyXG5cclxuXHRcdFx0XHRpZiAoY3VycmVudGx5VmlzaWJsZSA9PT0gZmFsc2UgJiYgdmlzaWJsZSA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgeyBhcHAgfSA9IHRoaXMuZ2V0KCk7XHJcblx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGFwcC5jb250cm9sUmVnaXN0ZXIuZ2V0SW5wdXQoZmllbGQubWV0YWRhdGEudHlwZSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcblx0XHRcdFx0XHRuZXcgaW5wdXQuY29tcG9uZW50KHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLnJlZnMuY29udGFpbmVyLFxyXG5cdFx0XHRcdFx0XHRkYXRhOiB7XHJcblx0XHRcdFx0XHRcdFx0ZmllbGQsXHJcblx0XHRcdFx0XHRcdFx0dGFiaW5kZXg6IHRoaXMuZ2V0KCkudGFiaW5kZXgsXHJcblx0XHRcdFx0XHRcdFx0aWQ6IHRoaXMuZ2V0KCkuaWQsXHJcblx0XHRcdFx0XHRcdFx0YXBwLFxyXG5cdFx0XHRcdFx0XHRcdGZvcm06IHRoaXMuZ2V0KCkuZm9ybSxcclxuXHRcdFx0XHRcdFx0XHR3cmFwcGVyOiB0aGlzXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCF2aXNpYmxlKSB7XHJcblx0XHRcdFx0XHRmaWVsZC52YWx1ZSA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Y29tcG9uZW50czoge1xyXG5cdFx0XHRUb29sdGlwXHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LmlubGluZSB7XHJcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0fVxyXG5cclxuXHQuY29sLWZvcm0tbGFiZWwge1xyXG5cdFx0cGFkZGluZy1sZWZ0OiAwO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTRHQyxPQUFPLGVBQUMsQ0FBQyxBQUNSLE9BQU8sQ0FBRSxZQUFZLEFBQ3RCLENBQUMsQUFFRCxlQUFlLGVBQUMsQ0FBQyxBQUNoQixZQUFZLENBQUUsQ0FBQyxBQUNoQixDQUFDIn0= */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$5(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.visible) && create_if_block$5(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.visible) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$5(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (5:12) {#if field.metadata.customProperties != null && field.metadata.customProperties["documentation"] != null}
    function create_if_block_2$2(component, ctx) {
    	var div, text_value = ctx.field.metadata.label, text, text_1;

    	var tooltip_initial_data = { data: ctx.field.metadata.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText(text_value);
    			text_1 = createText(":\r\n                ");
    			tooltip._fragment.c();
    			div.className = "help-tooltip";
    			addLoc(div, file$5, 5, 12, 295);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(text, div);
    			appendNode(text_1, div);
    			tooltip._mount(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.metadata.label)) {
    				text.data = text_value;
    			}

    			var tooltip_changes = {};
    			if (changed.field) tooltip_changes.data = ctx.field.metadata.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    // (9:12) {:else}
    function create_if_block_3$1(component, ctx) {
    	var text_value = ctx.field.metadata.label, text, text_1;

    	return {
    		c: function create() {
    			text = createText(text_value);
    			text_1 = createText(":");
    		},

    		m: function mount(target, anchor) {
    			insertNode(text, target, anchor);
    			insertNode(text_1, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.metadata.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    				detachNode(text_1);
    			}
    		}
    	};
    }

    // (2:4) {#if !alwaysHideLabel && field.metadata.label !== "" }
    function create_if_block_1$3(component, ctx) {
    	var div, label, text_1, div_1, div_class_value;

    	function select_block_type(ctx) {
    		if (ctx.field.metadata.customProperties != null && ctx.field.metadata.customProperties["documentation"] != null) return create_if_block_2$2;
    		return create_if_block_3$1;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			label = createElement("label");
    			if_block.c();
    			text_1 = createText("\r\n        ");
    			div_1 = createElement("div");
    			label.htmlFor = ctx.id;
    			label.className = "col-form-label svelte-1izjarg";
    			addLoc(label, file$5, 3, 8, 121);
    			div_1.className = "input-container";
    			addLoc(div_1, file$5, 12, 8, 564);
    			div.className = div_class_value = "form-group " + ctx.class + " svelte-1izjarg";
    			addLoc(div, file$5, 2, 4, 79);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(label, div);
    			if_block.m(label, null);
    			appendNode(text_1, div);
    			appendNode(div_1, div);
    			component.refs.container = div_1;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(label, null);
    			}

    			if (changed.id) {
    				label.htmlFor = ctx.id;
    			}

    			if ((changed.class) && div_class_value !== (div_class_value = "form-group " + ctx.class + " svelte-1izjarg")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if_block.d();
    			if (component.refs.container === div_1) component.refs.container = null;
    		}
    	};
    }

    // (15:4) {:else}
    function create_if_block_4$1(component, ctx) {
    	var div, div_1, div_class_value;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div_1 = createElement("div");
    			div_1.className = "input-container";
    			addLoc(div_1, file$5, 16, 8, 686);
    			div.className = div_class_value = "form-group " + ctx.class + " svelte-1izjarg";
    			addLoc(div, file$5, 15, 4, 644);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(div_1, div);
    			component.refs.container = div_1;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.class) && div_class_value !== (div_class_value = "form-group " + ctx.class + " svelte-1izjarg")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (component.refs.container === div_1) component.refs.container = null;
    		}
    	};
    }

    // (1:0) {#if visible}
    function create_if_block$5(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_1(ctx) {
    		if (!ctx.alwaysHideLabel && ctx.field.metadata.label !== "") return create_if_block_1$3;
    		return create_if_block_4$1;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    function SvelteComponent$5(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$3(), options.data);
    	if (!('visible' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visible'");
    	if (!('alwaysHideLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'alwaysHideLabel'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('class' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'class'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1izjarg-style")) add_css$1();

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$5(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$3.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$5.prototype, protoDev);
    assign(SvelteComponent$5.prototype, methods);

    SvelteComponent$5.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\Output.html generated by Svelte v2.9.5 */

    function data$4() {
    	return {
    		showLabel: true
    	};
    }
    function oncreate$4() {
    	const field = this.get().field;
    	const app = this.get().app;
    	const parent = this.get().parent;
    	const form = this.get().form;

    	const output = app.controlRegister.getOutput(field);

    	// Never show label if `alwaysHideLabel` is set to true.
    	const outputDisplayConfig = output.constants || {};
    	this.set({
    		alwaysHideLabel: outputDisplayConfig.alwaysHideLabel
    	});

    	// eslint-disable-next-line
    	new output.constructor({
    		target: this.refs.container,
    		data: {
    			field,
    			app,
    			form,
    			parent
    		}
    	});

    	const cssClass = field.metadata.customProperties != null ? field.metadata.customProperties.cssClass : null;

    	// Set correct css class based on the field type.
    	if (outputDisplayConfig.block) {
    		this.set({ class: `block ${cssClass}` });
    	}
    	else {
    		this.set({ class: `inline ${cssClass}` });
    	}
    }
    const file$6 = "src\\core\\ui\\Output.html";

    function add_css$2() {
    	var style = createElement("style");
    	style.id = 'svelte-ss8wac-style';
    	style.textContent = ".inline.svelte-ss8wac{display:inline-block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT3V0cHV0Lmh0bWwiLCJzb3VyY2VzIjpbIk91dHB1dC5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbInsjaWYgc2hvd0xhYmVsID09PSB0cnVlICYmICFhbHdheXNIaWRlTGFiZWwgJiYgZmllbGQubWV0YWRhdGEubGFiZWwgIT09IFwiXCJ9XHJcbjxkaXY+XHJcbiAgICAgICAgeyNpZiBmaWVsZC5tZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzICE9IG51bGwgJiYgZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllc1tcImRvY3VtZW50YXRpb25cIl0gIT0gbnVsbH1cclxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJoZWxwLXRvb2x0aXAgb3V0cHV0LWxhYmVsXCI+e2ZpZWxkLm1ldGFkYXRhLmxhYmVsfTpcclxuICAgICAgICAgICAgPFRvb2x0aXAgZGF0YT1cIntmaWVsZC5tZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzLmRvY3VtZW50YXRpb25bMF19XCI+PC9Ub29sdGlwPlxyXG4gICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgezplbHNlfVxyXG5cdFx0PGxhYmVsIGNsYXNzPVwib3V0cHV0LWxhYmVsXCI+XHJcbiAgICAgICAge2ZpZWxkLm1ldGFkYXRhLmxhYmVsfTpcclxuXHRcdDwvbGFiZWw+XHJcbiAgICAgICAgey9pZn1cclxuICAgIDxkaXYgcmVmOmNvbnRhaW5lciBjbGFzcz1cIm91dHB1dC1jb250YWluZXIge2NsYXNzfVwiPjwvZGl2PlxyXG48L2Rpdj5cclxuezplbHNlfVxyXG48ZGl2IHJlZjpjb250YWluZXIgY2xhc3M9XCJvdXRwdXQtY29udGFpbmVyIHtjbGFzc31cIj48L2Rpdj5cclxuey9pZn1cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4vaGVscC9Ub29sdGlwXCI7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCBmaWVsZCA9IHRoaXMuZ2V0KCkuZmllbGQ7XHJcblx0XHRcdGNvbnN0IGFwcCA9IHRoaXMuZ2V0KCkuYXBwO1xyXG5cdFx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHRcdFx0Y29uc3QgZm9ybSA9IHRoaXMuZ2V0KCkuZm9ybTtcclxuXHJcblx0XHRcdGNvbnN0IG91dHB1dCA9IGFwcC5jb250cm9sUmVnaXN0ZXIuZ2V0T3V0cHV0KGZpZWxkKTtcclxuXHJcblx0XHRcdC8vIE5ldmVyIHNob3cgbGFiZWwgaWYgYGFsd2F5c0hpZGVMYWJlbGAgaXMgc2V0IHRvIHRydWUuXHJcblx0XHRcdGNvbnN0IG91dHB1dERpc3BsYXlDb25maWcgPSBvdXRwdXQuY29uc3RhbnRzIHx8IHt9O1xyXG5cdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0YWx3YXlzSGlkZUxhYmVsOiBvdXRwdXREaXNwbGF5Q29uZmlnLmFsd2F5c0hpZGVMYWJlbFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0XHRuZXcgb3V0cHV0LmNvbnN0cnVjdG9yKHtcclxuXHRcdFx0XHR0YXJnZXQ6IHRoaXMucmVmcy5jb250YWluZXIsXHJcblx0XHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFx0ZmllbGQsXHJcblx0XHRcdFx0XHRhcHAsXHJcblx0XHRcdFx0XHRmb3JtLFxyXG5cdFx0XHRcdFx0cGFyZW50XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IGNzc0NsYXNzID0gZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyAhPSBudWxsID8gZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5jc3NDbGFzcyA6IG51bGw7XHJcblxyXG5cdFx0XHQvLyBTZXQgY29ycmVjdCBjc3MgY2xhc3MgYmFzZWQgb24gdGhlIGZpZWxkIHR5cGUuXHJcblx0XHRcdGlmIChvdXRwdXREaXNwbGF5Q29uZmlnLmJsb2NrKSB7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBjbGFzczogYGJsb2NrICR7Y3NzQ2xhc3N9YCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IGNsYXNzOiBgaW5saW5lICR7Y3NzQ2xhc3N9YCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0c2hvd0xhYmVsOiB0cnVlXHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cdFx0Y29tcG9uZW50czoge1xyXG5cdFx0XHRUb29sdGlwXHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LmlubGluZSB7XHJcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBb0VDLE9BQU8sY0FBQyxDQUFDLEFBQ1IsT0FBTyxDQUFFLFlBQVksQUFDdEIsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$6(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_1(ctx) {
    		if (ctx.showLabel === true && !ctx.alwaysHideLabel && ctx.field.metadata.label !== "") return create_if_block$6;
    		return create_if_block_3$2;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (3:8) {#if field.metadata.customProperties != null && field.metadata.customProperties["documentation"] != null}
    function create_if_block_1$4(component, ctx) {
    	var label, text_value = ctx.field.metadata.label, text, text_1;

    	var tooltip_initial_data = { data: ctx.field.metadata.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			label = createElement("label");
    			text = createText(text_value);
    			text_1 = createText(":\r\n            ");
    			tooltip._fragment.c();
    			label.className = "help-tooltip output-label";
    			addLoc(label, file$6, 3, 8, 207);
    		},

    		m: function mount(target, anchor) {
    			insertNode(label, target, anchor);
    			appendNode(text, label);
    			appendNode(text_1, label);
    			tooltip._mount(label, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.metadata.label)) {
    				text.data = text_value;
    			}

    			var tooltip_changes = {};
    			if (changed.field) tooltip_changes.data = ctx.field.metadata.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(label);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    // (7:8) {:else}
    function create_if_block_2$3(component, ctx) {
    	var label, text_value = ctx.field.metadata.label, text, text_1;

    	return {
    		c: function create() {
    			label = createElement("label");
    			text = createText(text_value);
    			text_1 = createText(":");
    			label.className = "output-label";
    			addLoc(label, file$6, 7, 2, 401);
    		},

    		m: function mount(target, anchor) {
    			insertNode(label, target, anchor);
    			appendNode(text, label);
    			appendNode(text_1, label);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.metadata.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(label);
    			}
    		}
    	};
    }

    // (1:0) {#if showLabel === true && !alwaysHideLabel && field.metadata.label !== ""}
    function create_if_block$6(component, ctx) {
    	var div, text, div_1, div_1_class_value;

    	function select_block_type(ctx) {
    		if (ctx.field.metadata.customProperties != null && ctx.field.metadata.customProperties["documentation"] != null) return create_if_block_1$4;
    		return create_if_block_2$3;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if_block.c();
    			text = createText("\r\n    ");
    			div_1 = createElement("div");
    			div_1.className = div_1_class_value = "output-container " + ctx.class + " svelte-ss8wac";
    			addLoc(div_1, file$6, 11, 4, 495);
    			addLoc(div, file$6, 1, 0, 77);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			if_block.m(div, null);
    			appendNode(text, div);
    			appendNode(div_1, div);
    			component.refs.container = div_1;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(div, text);
    			}

    			if ((changed.class) && div_1_class_value !== (div_1_class_value = "output-container " + ctx.class + " svelte-ss8wac")) {
    				div_1.className = div_1_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if_block.d();
    			if (component.refs.container === div_1) component.refs.container = null;
    		}
    	};
    }

    // (14:0) {:else}
    function create_if_block_3$2(component, ctx) {
    	var div, div_class_value;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = div_class_value = "output-container " + ctx.class + " svelte-ss8wac";
    			addLoc(div, file$6, 14, 0, 572);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			component.refs.container = div;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.class) && div_class_value !== (div_class_value = "output-container " + ctx.class + " svelte-ss8wac")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (component.refs.container === div) component.refs.container = null;
    		}
    	};
    }

    function SvelteComponent$6(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$4(), options.data);
    	if (!('showLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'showLabel'");
    	if (!('alwaysHideLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'alwaysHideLabel'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('class' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'class'");
    	this._intro = true;

    	if (!document.getElementById("svelte-ss8wac-style")) add_css$2();

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$6(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$4.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$6.prototype, protoDev);

    SvelteComponent$6.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\help\Help.html generated by Svelte v2.9.5 */

    function humanize(e) {
    	return e.replace(/\.[^/.]+$/, "")
    		.split(/(?=[A-Z])/)
    		.join(" ");
    }

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    let currentlyOpenHelpModal = null;
    document.addEventListener("keydown", evt => {
    	const theEvent = evt || window.event;
    	let isEscape = false;
    	if ("key" in theEvent) {
    		isEscape = (theEvent.key === "Escape" || theEvent.key === "Esc");
    	}
    	else {
    		isEscape = (theEvent.keyCode === 27);
    	}
    	if (isEscape && currentlyOpenHelpModal != null) {
    		currentlyOpenHelpModal.close();
    	}
    });

    function data$5() {
    	return {
    		files: [],
    		open: false,
    		modalId: ""
    	};
    }
    var methods$1 = {
    	open() {
    		this.set({ open: true });
    		currentlyOpenHelpModal = this;
    	},
    	close() {
    		this.set({ open: false });
    		currentlyOpenHelpModal = null;
    	}
    };

    function oncreate$5() {
    	const files = this.get().data.files.map(i => ({ file: i, name: humanize(i) }));

    	this.set({
    		files,
    		modalId: this.constructor.name
    	});
    }
    const file$7 = "src\\core\\ui\\help\\Help.html";

    function add_css$3() {
    	var style = createElement("style");
    	style.id = 'svelte-17ly25h-style';
    	style.textContent = ".inline-help.svelte-17ly25h{background:#ecf8fb;padding:10px}.modal-help.svelte-17ly25h>i.svelte-17ly25h{font-size:15pt;color:#5b7b9b}.modal-help.svelte-17ly25h{display:block;margin-left:-10px;position:absolute;right:10px;top:30px}.help-files.svelte-17ly25h{border-top:1px solid #d8d8d8;padding:10px;margin:10px;background:#ecf8fb}.help-files.svelte-17ly25h ul.svelte-17ly25h{list-style:circle}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVscC5odG1sIiwic291cmNlcyI6WyJIZWxwLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBkYXRhIH1cclxuXHR7I2lmIGRhdGEucGxhY2VtZW50ID09ICdIaW50JyB9XHJcblx0PGRpdiBjbGFzcz1cImhlbHAtY29udGVudCBtb2RhbC1oZWxwXCI+XHJcblx0XHQ8aSBvbjpjbGljaz1cIm9wZW4oKVwiIGNsYXNzPVwiZmFyIGZhLXF1ZXN0aW9uLWNpcmNsZVwiIHRpdGxlPVwiQ2xpY2sgdG8gb3BlbiBoZWxwIGZvciB0aGlzIGZvcm1cIj48L2k+XHJcblx0XHQ8aW5wdXQgaWQ9XCJtb2RhbC17bW9kYWxJZH1cIiB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9XCJvcGVuXCIgY2xhc3M9XCJoaWRkZW5cIiAvPlxyXG5cdFx0PGRpdiBjbGFzcz1cIm1vZGFsXCI+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJjYXJkXCI+XHJcblx0XHRcdFx0PGxhYmVsIGNsYXNzPVwiY2xvc2VcIiBvbjpjbGljaz1cImNsb3NlKClcIj48L2xhYmVsPlxyXG5cdFx0XHRcdDxkaXYgcmVmOmNvbnRhaW5lcj5cclxuXHRcdFx0XHRcdHtAaHRtbCBkYXRhLmNvbnRlbnR9XHJcblxyXG5cdFx0XHRcdFx0eyAjaWYgZmlsZXMgJiYgZmlsZXMubGVuZ3RoID4wIH1cclxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJoZWxwLWZpbGVzXCI+XHJcblx0XHRcdFx0XHRcdDxzcGFuPkZvciBtb3JlIGluZm9ybWF0aW9uOjwvc3Bhbj5cclxuXHRcdFx0XHRcdFx0XHQ8dWw+XHJcblx0XHRcdFx0XHRcdFx0XHR7I2VhY2ggZmlsZXMgYXMgZmlsZX1cclxuXHRcdFx0XHRcdFx0XHRcdDxsaT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGEgaHJlZj1cIi8jL2Zvcm0vaGVscD9GaWxlSWQ9e2ZpbGUuZmlsZX1cIj57IGZpbGUubmFtZSB9PC9hPlxyXG5cdFx0XHRcdFx0XHRcdFx0PC9saT5cclxuXHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cclxuXHRcdFx0XHRcdFx0XHQ8L3VsPlxyXG5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0ey9pZn1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L2Rpdj5cclxuXHQ8L2Rpdj5cclxuXHR7OmVsc2VpZiBkYXRhLnBsYWNlbWVudCA9PSAnSW5saW5lJyB9XHJcblx0PGRpdiBjbGFzcz1cImhlbHAtY29udGVudCBpbmxpbmUtaGVscFwiPlxyXG5cdFx0e0BodG1sIGRhdGEuY29udGVudH1cclxuXHRcdHsjaWYgZmlsZXMgJiYgZmlsZXMubGVuZ3RoID4wIH1cclxuXHRcdDxkaXYgY2xhc3M9XCJoZWxwLWZpbGVzXCI+XHJcblx0XHRcdDxzcGFuPkZvciBtb3JlIGluZm9ybWF0aW9uPC9zcGFuPlxyXG5cdFx0XHQ8dWw+XHJcblx0XHRcdFx0eyNlYWNoIGZpbGVzIGFzIGZpbGV9XHJcblx0XHRcdFx0PGxpPlxyXG5cdFx0XHRcdFx0PGEgaHJlZj1cIi8jL2Zvcm0vaGVscD9GaWxlSWQ9e2ZpbGUuZmlsZX1cIj57IGZpbGUubmFtZSB9PC9hPlxyXG5cdFx0XHRcdDwvbGk+XHJcblx0XHRcdFx0ey9lYWNofVxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0PC9kaXY+XHJcblx0XHR7L2lmfVxyXG5cdDwvZGl2PlxyXG5cdHsvaWZ9XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGZ1bmN0aW9uIGh1bWFuaXplKGUpIHtcclxuXHRcdHJldHVybiBlLnJlcGxhY2UoL1xcLlteLy5dKyQvLCBcIlwiKVxyXG5cdFx0XHQuc3BsaXQoLyg/PVtBLVpdKS8pXHJcblx0XHRcdC5qb2luKFwiIFwiKTtcclxuXHR9XHJcblxyXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzY5NzQzLzExMTQzOFxyXG5cdC8vIENsb3NlIHRvcG1vc3QgbW9kYWwgd2hlbiB1c2VyIHByZXNzZXMgZXNjYXBlIGtleS5cclxuXHRsZXQgY3VycmVudGx5T3BlbkhlbHBNb2RhbCA9IG51bGw7XHJcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcclxuXHRcdGNvbnN0IHRoZUV2ZW50ID0gZXZ0IHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdGxldCBpc0VzY2FwZSA9IGZhbHNlO1xyXG5cdFx0aWYgKFwia2V5XCIgaW4gdGhlRXZlbnQpIHtcclxuXHRcdFx0aXNFc2NhcGUgPSAodGhlRXZlbnQua2V5ID09PSBcIkVzY2FwZVwiIHx8IHRoZUV2ZW50LmtleSA9PT0gXCJFc2NcIik7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aXNFc2NhcGUgPSAodGhlRXZlbnQua2V5Q29kZSA9PT0gMjcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzRXNjYXBlICYmIGN1cnJlbnRseU9wZW5IZWxwTW9kYWwgIT0gbnVsbCkge1xyXG5cdFx0XHRjdXJyZW50bHlPcGVuSGVscE1vZGFsLmNsb3NlKCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCBmaWxlcyA9IHRoaXMuZ2V0KCkuZGF0YS5maWxlcy5tYXAoaSA9PiAoeyBmaWxlOiBpLCBuYW1lOiBodW1hbml6ZShpKSB9KSk7XHJcblxyXG5cdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0ZmlsZXMsXHJcblx0XHRcdFx0bW9kYWxJZDogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZmlsZXM6IFtdLFxyXG5cdFx0XHRcdG9wZW46IGZhbHNlLFxyXG5cdFx0XHRcdG1vZGFsSWQ6IFwiXCJcclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOiB7XHJcblx0XHRcdG9wZW4oKSB7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBvcGVuOiB0cnVlIH0pO1xyXG5cdFx0XHRcdGN1cnJlbnRseU9wZW5IZWxwTW9kYWwgPSB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbG9zZSgpIHtcclxuXHRcdFx0XHR0aGlzLnNldCh7IG9wZW46IGZhbHNlIH0pO1xyXG5cdFx0XHRcdGN1cnJlbnRseU9wZW5IZWxwTW9kYWwgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LmlubGluZS1oZWxwIHtcclxuXHRcdGJhY2tncm91bmQ6ICNlY2Y4ZmI7XHJcblx0XHRwYWRkaW5nOiAxMHB4O1xyXG5cdH1cclxuXHJcblx0Lm1vZGFsLWhlbHAgPiBpIHtcclxuXHRcdGZvbnQtc2l6ZTogMTVwdDtcclxuXHRcdGNvbG9yOiAjNWI3YjliO1xyXG5cdH1cclxuXHJcblx0Lm1vZGFsLWhlbHAge1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHRtYXJnaW4tbGVmdDogLTEwcHg7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHRyaWdodDogMTBweDtcclxuXHRcdHRvcDogMzBweDtcclxuXHR9XHJcblxyXG5cdC5oZWxwLWZpbGVzIHtcclxuXHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjZDhkOGQ4O1xyXG5cdFx0cGFkZGluZzogMTBweDtcclxuXHRcdG1hcmdpbjogMTBweDtcclxuXHRcdGJhY2tncm91bmQ6ICNlY2Y4ZmI7XHJcblx0fVxyXG5cclxuXHQuaGVscC1maWxlcyB1bCB7XHJcblx0XHRsaXN0LXN0eWxlOiBjaXJjbGU7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBcUdDLFlBQVksZUFBQyxDQUFDLEFBQ2IsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsT0FBTyxDQUFFLElBQUksQUFDZCxDQUFDLEFBRUQsMEJBQVcsQ0FBRyxDQUFDLGVBQUMsQ0FBQyxBQUNoQixTQUFTLENBQUUsSUFBSSxDQUNmLEtBQUssQ0FBRSxPQUFPLEFBQ2YsQ0FBQyxBQUVELFdBQVcsZUFBQyxDQUFDLEFBQ1osT0FBTyxDQUFFLEtBQUssQ0FDZCxXQUFXLENBQUUsS0FBSyxDQUNsQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLEdBQUcsQ0FBRSxJQUFJLEFBQ1YsQ0FBQyxBQUVELFdBQVcsZUFBQyxDQUFDLEFBQ1osVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUM3QixPQUFPLENBQUUsSUFBSSxDQUNiLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQyxBQUVELDBCQUFXLENBQUMsRUFBRSxlQUFDLENBQUMsQUFDZixVQUFVLENBQUUsTUFBTSxBQUNuQixDQUFDIn0= */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$7(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.data) && create_if_block$7(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.data) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$7(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (16:8) {#each files as file}
    function create_each_block$2(component, ctx) {
    	var li, a, text_value = ctx.file.name, text, a_href_value;

    	return {
    		c: function create() {
    			li = createElement("li");
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = "/#/form/help?FileId=" + ctx.file.file;
    			addLoc(a, file$7, 17, 9, 606);
    			addLoc(li, file$7, 16, 8, 591);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			appendNode(a, li);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.files) && text_value !== (text_value = ctx.file.name)) {
    				text.data = text_value;
    			}

    			if ((changed.files) && a_href_value !== (a_href_value = "/#/form/help?FileId=" + ctx.file.file)) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}
    		}
    	};
    }

    // (12:5) { #if files && files.length >0 }
    function create_if_block_2$4(component, ctx) {
    	var div, span, text, text_1, ul;

    	var each_value = ctx.files;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(component, get_each_context$2(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span = createElement("span");
    			text = createText("For more information:");
    			text_1 = createText("\r\n\t\t\t\t\t\t\t");
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			addLoc(span, file$7, 13, 6, 503);
    			ul.className = "svelte-17ly25h";
    			addLoc(ul, file$7, 14, 7, 546);
    			div.className = "help-files svelte-17ly25h";
    			addLoc(div, file$7, 12, 5, 471);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(span, div);
    			appendNode(text, span);
    			appendNode(text_1, div);
    			appendNode(ul, div);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.files) {
    				each_value = ctx.files;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (36:4) {#each files as file}
    function create_each_block_1(component, ctx) {
    	var li, a, text_value = ctx.file.name, text, a_href_value;

    	return {
    		c: function create() {
    			li = createElement("li");
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = "/#/form/help?FileId=" + ctx.file.file;
    			addLoc(a, file$7, 37, 5, 1039);
    			addLoc(li, file$7, 36, 4, 1028);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			appendNode(a, li);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.files) && text_value !== (text_value = ctx.file.name)) {
    				text.data = text_value;
    			}

    			if ((changed.files) && a_href_value !== (a_href_value = "/#/form/help?FileId=" + ctx.file.file)) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}
    		}
    	};
    }

    // (32:2) {#if files && files.length >0 }
    function create_if_block_4$2(component, ctx) {
    	var div, span, text, text_1, ul;

    	var each_value_1 = ctx.files;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(component, get_each_context_1(ctx, each_value_1, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span = createElement("span");
    			text = createText("For more information");
    			text_1 = createText("\r\n\t\t\t");
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			addLoc(span, file$7, 33, 3, 953);
    			ul.className = "svelte-17ly25h";
    			addLoc(ul, file$7, 34, 3, 991);
    			div.className = "help-files svelte-17ly25h";
    			addLoc(div, file$7, 32, 2, 924);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(span, div);
    			appendNode(text, span);
    			appendNode(text_1, div);
    			appendNode(ul, div);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.files) {
    				each_value_1 = ctx.files;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (2:1) {#if data.placement == 'Hint' }
    function create_if_block_1$5(component, ctx) {
    	var div, i, text, input, input_id_value, text_1, div_1, div_2, label, text_2, div_3, raw_value = ctx.data.content, raw_after, text_3;

    	function click_handler(event) {
    		component.open();
    	}

    	function input_change_handler() {
    		component.set({ open: input.checked });
    	}

    	function click_handler_1(event) {
    		component.close();
    	}

    	var if_block = (ctx.files && ctx.files.length >0) && create_if_block_2$4(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			i = createElement("i");
    			text = createText("\r\n\t\t");
    			input = createElement("input");
    			text_1 = createText("\r\n\t\t");
    			div_1 = createElement("div");
    			div_2 = createElement("div");
    			label = createElement("label");
    			text_2 = createText("\r\n\t\t\t\t");
    			div_3 = createElement("div");
    			raw_after = createElement('noscript');
    			text_3 = createText("\r\n\r\n\t\t\t\t\t");
    			if (if_block) if_block.c();
    			addListener(i, "click", click_handler);
    			i.className = "far fa-question-circle svelte-17ly25h";
    			i.title = "Click to open help for this form";
    			addLoc(i, file$7, 3, 2, 89);
    			addListener(input, "change", input_change_handler);
    			input.id = input_id_value = "modal-" + ctx.modalId;
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden";
    			addLoc(input, file$7, 4, 2, 190);
    			addListener(label, "click", click_handler_1);
    			label.className = "close";
    			addLoc(label, file$7, 7, 4, 323);
    			addLoc(div_3, file$7, 8, 4, 377);
    			div_2.className = "card";
    			addLoc(div_2, file$7, 6, 3, 299);
    			div_1.className = "modal";
    			addLoc(div_1, file$7, 5, 2, 275);
    			div.className = "help-content modal-help svelte-17ly25h";
    			addLoc(div, file$7, 2, 1, 48);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(i, div);
    			appendNode(text, div);
    			appendNode(input, div);

    			input.checked = ctx.open;

    			appendNode(text_1, div);
    			appendNode(div_1, div);
    			appendNode(div_2, div_1);
    			appendNode(label, div_2);
    			appendNode(text_2, div_2);
    			appendNode(div_3, div_2);
    			appendNode(raw_after, div_3);
    			raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			appendNode(text_3, div_3);
    			if (if_block) if_block.m(div_3, null);
    			component.refs.container = div_3;
    		},

    		p: function update(changed, ctx) {
    			input.checked = ctx.open;
    			if ((changed.modalId) && input_id_value !== (input_id_value = "modal-" + ctx.modalId)) {
    				input.id = input_id_value;
    			}

    			if ((changed.data) && raw_value !== (raw_value = ctx.data.content)) {
    				detachBefore(raw_after);
    				raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			}

    			if (ctx.files && ctx.files.length >0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2$4(component, ctx);
    					if_block.c();
    					if_block.m(div_3, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(i, "click", click_handler);
    			removeListener(input, "change", input_change_handler);
    			removeListener(label, "click", click_handler_1);
    			if (if_block) if_block.d();
    			if (component.refs.container === div_3) component.refs.container = null;
    		}
    	};
    }

    // (29:38) 
    function create_if_block_3$3(component, ctx) {
    	var div, raw_value = ctx.data.content, raw_after, text;

    	var if_block = (ctx.files && ctx.files.length >0) && create_if_block_4$2(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			raw_after = createElement('noscript');
    			text = createText("\r\n\t\t");
    			if (if_block) if_block.c();
    			div.className = "help-content inline-help svelte-17ly25h";
    			addLoc(div, file$7, 29, 1, 823);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(raw_after, div);
    			raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			appendNode(text, div);
    			if (if_block) if_block.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.data) && raw_value !== (raw_value = ctx.data.content)) {
    				detachBefore(raw_after);
    				raw_after.insertAdjacentHTML("beforebegin", raw_value);
    			}

    			if (ctx.files && ctx.files.length >0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_4$2(component, ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (1:0) {#if data }
    function create_if_block$7(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.data.placement == 'Hint') return create_if_block_1$5;
    		if (ctx.data.placement == 'Inline') return create_if_block_3$3;
    		return null;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type && current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(component, ctx);
    				if (if_block) if_block.c();
    				if (if_block) if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.file = list[i];
    	child_ctx.each_value = list;
    	child_ctx.file_index = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.file = list[i];
    	child_ctx.each_value_1 = list;
    	child_ctx.file_index_1 = i;
    	return child_ctx;
    }

    function SvelteComponent$7(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$5(), options.data);
    	if (!('data' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'data'");
    	if (!('modalId' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'modalId'");
    	if (!('open' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'open'");
    	if (!('files' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'files'");
    	this._intro = true;

    	if (!document.getElementById("svelte-17ly25h-style")) add_css$3();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$7(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$5.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$7.prototype, protoDev);
    assign(SvelteComponent$7.prototype, methods$1);

    SvelteComponent$7.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\Form.html generated by Svelte v2.9.5 */

    let tabindex = 1;
    let openForms = [];

    function bindEventHandlersToCustomEvents(formComponent, eventHandlers) {
    	const formInstance = formComponent.get().form;

    	for (const eventHandler of eventHandlers) {
    		// Don't bind default event handlers, because they are already auto-bound inside FormInstance.
    		if (eventHandler.runAt.indexOf("form:") === 0) {
    			continue;
    		}

    		formComponent.on(eventHandler.runAt, e => {
    			// Augment event args with form which is firing the event. This is needed,
    			// so that event handler can know from which particular form this event is coming.
    			e.form = formComponent;

    			formInstance.handleEvent(eventHandler.runAt, eventHandler, e);
    		});
    	}
    }

    function data$6() {
    	return {
    		disabled: false,
    		tabindex,
    		urlData: null,
    		initialized: false,
    		responseMetadata: {},
    		useUrl: true,
    		parent: null, // Can be set if this is a nested form within another form (i.e. - InlineForm.html)
    		inputs: []
    	};
    }
    var methods$2 = {
    	async init() {
    		if (!this.get().initialized) {
    			const form = this.get().form;

    			this.set({
    				self: this,
    				initialized: true,
    				visibleInputFields: form.inputs.filter(t => t.metadata.hidden === false),
    				submitButtonLabel: form.metadata.getCustomProperty("submitButtonLabel") || "Submit",
    				cssClass: form.metadata.getCustomProperty("cssClass") || "",
    				documentation: form.metadata.getCustomProperty("documentation")
    			});

    			tabindex += 1;

    			const app = this.get().app;

    			// Subscribe all event handlers (form, inputs, outputs).
    			const formMetadata = form.metadata;
    			const handlers = [];
    			formMetadata.inputFields.forEach(t => t.eventHandlers.forEach(h => handlers.push(h)));
    			formMetadata.outputFields.forEach(t => t.eventHandlers.forEach(h => handlers.push(h)));
    			formMetadata.eventHandlers.forEach(h => handlers.push(h));
    			bindEventHandlersToCustomEvents(this, handlers);

    			form.fire("form:loaded", { app });

    			// Auto-submit form if necessary.
    			if (form.metadata.postOnLoad) {
    				await this.submit();
    			}

    			openForms.push(this);

    			if (this.get().parent == null) {
    				if (this.get().responseMetadata.title == null) {
    					document.title = form.metadata.label;
    				}
    			}
    		}
    	},
    	fireAndBubbleUp(eventName, eventArgs) {
    		this.fire(eventName, eventArgs);
    		const parentFormComponent = this.get().parent;

    		if (parentFormComponent != null) {
    			parentFormComponent.fireAndBubbleUp(eventName, eventArgs);
    		}
    	},
    	enableForm() {
    		const formInstance = this.get().form;

    		// Hide all inputs, to re-render them. This is needed due to the way that
    		// Svelte *seems* to work - it doesn't re-render nested components, unless they are recreated.
    		this.set({ visibleInputFields: [] });

    		this.set({
    		// Show inputs again.
    			visibleInputFields: formInstance.inputs.filter(t => t.metadata.hidden === false),

    			disabled: false
    		});
    	},
    	renderResponse(response) {
    		const formInstance = this.get().form;

    		// Force Svelte to re-render outputs.
    		this.set({
    			outputFieldValues: null
    		});

    		this.set({
    			outputFieldValues: formInstance.outputs,
    			responseMetadata: response.metadata
    		});

    		if (this.get().parent == null) {
    			document.title = response.metadata.title;
    		}
    	},
    	async submit(event, redirect) {
    		const self = this;
    		const formInstance = this.get().form;
    		const app = this.get().app;

    		if (event != null) {
    			event.preventDefault();
    		}

    		// If not all required inputs are filled.
    		const allRequiredInputsHaveValues = await formInstance.allRequiredInputsHaveData(redirect == null);
    		if (!allRequiredInputsHaveValues) {
    			return;
    		}

    		// Disable double-posts.
    		self.set({ disabled: true });

    		// If postOnLoad == true, then the input field values should appear in the url.
    		// Reason is that postOnLoad == true is used by "report" pages, which need
    		// their filters to be saved in the url. This does not apply to forms
    		// with postOnLoad == false, because those forms are usually for creating new data
    		// and hence should not be tracked in browser's history based on parameters.
    		if (formInstance.metadata.postOnLoad && redirect && this.get().useUrl) {
    			const urlParams = await formInstance.getSerializedInputValues();

    			// Update url in the browser.
    			app.go(formInstance.metadata.id, urlParams);

    			return;
    		}

    		try {
    			const response = await formInstance.submit(app, redirect == null, { formComponent: self });

    			self.enableForm();

    			// Signal event to child controls.
    			self.fire("form:responseHandled", {
    				form: self,
    				invokedByUser: event != null,
    				response
    			});
    		}
    		catch (e) {
    			self.enableForm();
    		}
    	},
    	reloadTopForm() {
    		const parentFormComponent = this.get().parent;

    		if (parentFormComponent != null) {
    			parentFormComponent.reloadTopForm();
    		}
    		else {
    			this.submit(null, true);
    		}
    	},
    	reloadAllForms() {
    		for (const f of openForms) {
    			f.reloadTopForm();
    		}
    	},
    	getInputComponent(inputId) {
    		return this.get().inputs.find(t => t.get().field.metadata.id === inputId);
    	}
    };

    function ondestroy() {
    	openForms = openForms.filter(f => f !== this);
    }
    const file$8 = "src\\core\\ui\\Form.html";

    function add_css$4() {
    	var style = createElement("style");
    	style.id = 'svelte-1djvwan-style';
    	style.textContent = ".response.svelte-1djvwan{margin-top:15px;padding-left:10px;padding-right:10px}.form-header.svelte-1djvwan{text-align:center;padding-top:20px;border-bottom:1px solid #bbd2d6;background-color:#fff;position:relative}.form-header.svelte-1djvwan h2.svelte-1djvwan{display:inline-block}.help-content.svelte-1djvwan{text-align:left}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybS5odG1sIiwic291cmNlcyI6WyJGb3JtLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBpbml0aWFsaXplZH1cclxuPGRpdiBjbGFzcz1cImlucHV0cy1ob3Jpem9udGFsLW9uZS1jb2x1bW4ge2Nzc0NsYXNzfVwiPlxyXG5cdCB7I2lmIChyZXNwb25zZU1ldGFkYXRhLnRpdGxlICE9IG51bGwgJiYgcmVzcG9uc2VNZXRhZGF0YS50aXRsZSAhPSBcIlwiKSB8fCAobWV0YWRhdGEubGFiZWwgIT0gbnVsbCAmJiBtZXRhZGF0YS5sYWJlbCAhPSBcIlwiKX1cclxuXHQgIDxkaXYgY2xhc3M9XCJmb3JtLWhlYWRlclwiPlxyXG5cdFx0PGgyPntyZXNwb25zZU1ldGFkYXRhLnRpdGxlIHx8IG1ldGFkYXRhLmxhYmVsfTwvaDI+XHJcblxyXG5cdFx0eyNpZiBkb2N1bWVudGF0aW9uIH1cclxuXHRcdFx0eyNlYWNoIGRvY3VtZW50YXRpb24gYXMgZG9jdW1lbnQgfVxyXG5cdFx0XHRcdDxIZWxwIGRhdGE9e2RvY3VtZW50fS8+XHJcblx0XHRcdHsvZWFjaH1cclxuXHRcdHsvaWZ9XHJcblx0ICA8L2Rpdj5cclxuXHR7L2lmfVxyXG5cclxuXHR7I2lmIGluaXRpYWxpemVkICYmIHZpc2libGVJbnB1dEZpZWxkcy5sZW5ndGggPiAwfVxyXG5cdDxkaXYgY2xhc3M9XCJmb3JtLWJvZHlcIj5cclxuXHQ8Zm9ybSBvbjpzdWJtaXQ9XCJzdWJtaXQoZXZlbnQsIHRydWUpXCI+XHJcblx0XHR7I2VhY2ggdmlzaWJsZUlucHV0RmllbGRzIGFzIGlucHV0RmllbGR9XHJcblx0XHQ8Rm9ybUlucHV0IGZpZWxkPVwie2lucHV0RmllbGR9XCIgYXBwPVwie2FwcH1cIiB0YWJpbmRleD1cInt0YWJpbmRleCAqIDEwMCArIGlucHV0RmllbGQubWV0YWRhdGEub3JkZXJJbmRleH1cIiBmb3JtPVwie3NlbGZ9XCIgLz5cclxuXHRcdHsvZWFjaH1cclxuXHRcdDxkaXYgY2xhc3M9XCJmdWxsLXdpZHRoXCI+XHJcblx0XHRcdDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGRpc2FibGVkPVwie2Rpc2FibGVkfVwiIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cImJ0biBidG4taW5mb1wiPntAaHRtbCBzdWJtaXRCdXR0b25MYWJlbH08L2J1dHRvbj5cclxuXHRcdDwvZGl2PlxyXG5cdDwvZm9ybT5cclxuXHQ8L2Rpdj5cclxuXHR7L2lmfVxyXG5cclxuXHR7I2lmIG91dHB1dEZpZWxkVmFsdWVzICE9IG51bGx9XHJcblx0PGRpdiBjbGFzcz1cInJlc3BvbnNlXCI+XHJcblx0XHR7I2VhY2ggb3V0cHV0RmllbGRWYWx1ZXMgYXMgb3V0cHV0RmllbGQgfVxyXG5cdFx0eyNpZiBvdXRwdXRGaWVsZC5tZXRhZGF0YS5oaWRkZW4gPT0gZmFsc2UgJiYgIShvdXRwdXRGaWVsZC5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImhpZGVJZk51bGxcIikgPT09IHRydWUgJiYgb3V0cHV0RmllbGQuZGF0YSA9PT0gbnVsbCl9XHJcblx0XHQ8Rm9ybU91dHB1dCBmaWVsZD1cIntvdXRwdXRGaWVsZH1cIiBhcHA9XCJ7YXBwfVwiIGZvcm09XCJ7Zm9ybX1cIiBwYXJlbnQ9XCJ7c2VsZn1cIiAvPlxyXG5cdFx0ey9pZn1cclxuXHRcdHsvZWFjaH1cclxuXHQ8L2Rpdj5cclxuXHR7L2lmfVxyXG48L2Rpdj5cclxuey9pZn1cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IEZvcm1JbnB1dCBmcm9tIFwiLi9JbnB1dFwiO1xyXG5cdGltcG9ydCBGb3JtT3V0cHV0IGZyb20gXCIuL091dHB1dFwiO1xyXG5cdGltcG9ydCBIZWxwIGZyb20gXCIuL2hlbHAvSGVscFwiO1xyXG5cclxuXHRsZXQgdGFiaW5kZXggPSAxO1xyXG5cdGxldCBvcGVuRm9ybXMgPSBbXTtcclxuXHJcblx0ZnVuY3Rpb24gYmluZEV2ZW50SGFuZGxlcnNUb0N1c3RvbUV2ZW50cyhmb3JtQ29tcG9uZW50LCBldmVudEhhbmRsZXJzKSB7XHJcblx0XHRjb25zdCBmb3JtSW5zdGFuY2UgPSBmb3JtQ29tcG9uZW50LmdldCgpLmZvcm07XHJcblxyXG5cdFx0Zm9yIChjb25zdCBldmVudEhhbmRsZXIgb2YgZXZlbnRIYW5kbGVycykge1xyXG5cdFx0XHQvLyBEb24ndCBiaW5kIGRlZmF1bHQgZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgdGhleSBhcmUgYWxyZWFkeSBhdXRvLWJvdW5kIGluc2lkZSBGb3JtSW5zdGFuY2UuXHJcblx0XHRcdGlmIChldmVudEhhbmRsZXIucnVuQXQuaW5kZXhPZihcImZvcm06XCIpID09PSAwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvcm1Db21wb25lbnQub24oZXZlbnRIYW5kbGVyLnJ1bkF0LCBlID0+IHtcclxuXHRcdFx0XHQvLyBBdWdtZW50IGV2ZW50IGFyZ3Mgd2l0aCBmb3JtIHdoaWNoIGlzIGZpcmluZyB0aGUgZXZlbnQuIFRoaXMgaXMgbmVlZGVkLFxyXG5cdFx0XHRcdC8vIHNvIHRoYXQgZXZlbnQgaGFuZGxlciBjYW4ga25vdyBmcm9tIHdoaWNoIHBhcnRpY3VsYXIgZm9ybSB0aGlzIGV2ZW50IGlzIGNvbWluZy5cclxuXHRcdFx0XHRlLmZvcm0gPSBmb3JtQ29tcG9uZW50O1xyXG5cclxuXHRcdFx0XHRmb3JtSW5zdGFuY2UuaGFuZGxlRXZlbnQoZXZlbnRIYW5kbGVyLnJ1bkF0LCBldmVudEhhbmRsZXIsIGUpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uZGVzdHJveSgpIHtcclxuXHRcdFx0b3BlbkZvcm1zID0gb3BlbkZvcm1zLmZpbHRlcihmID0+IGYgIT09IHRoaXMpO1xyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0YXN5bmMgaW5pdCgpIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuZ2V0KCkuaW5pdGlhbGl6ZWQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGZvcm0gPSB0aGlzLmdldCgpLmZvcm07XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0XHRzZWxmOiB0aGlzLFxyXG5cdFx0XHRcdFx0XHRpbml0aWFsaXplZDogdHJ1ZSxcclxuXHRcdFx0XHRcdFx0dmlzaWJsZUlucHV0RmllbGRzOiBmb3JtLmlucHV0cy5maWx0ZXIodCA9PiB0Lm1ldGFkYXRhLmhpZGRlbiA9PT0gZmFsc2UpLFxyXG5cdFx0XHRcdFx0XHRzdWJtaXRCdXR0b25MYWJlbDogZm9ybS5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcInN1Ym1pdEJ1dHRvbkxhYmVsXCIpIHx8IFwiU3VibWl0XCIsXHJcblx0XHRcdFx0XHRcdGNzc0NsYXNzOiBmb3JtLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiY3NzQ2xhc3NcIikgfHwgXCJcIixcclxuXHRcdFx0XHRcdFx0ZG9jdW1lbnRhdGlvbjogZm9ybS5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImRvY3VtZW50YXRpb25cIilcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdHRhYmluZGV4ICs9IDE7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYXBwID0gdGhpcy5nZXQoKS5hcHA7XHJcblxyXG5cdFx0XHRcdFx0Ly8gU3Vic2NyaWJlIGFsbCBldmVudCBoYW5kbGVycyAoZm9ybSwgaW5wdXRzLCBvdXRwdXRzKS5cclxuXHRcdFx0XHRcdGNvbnN0IGZvcm1NZXRhZGF0YSA9IGZvcm0ubWV0YWRhdGE7XHJcblx0XHRcdFx0XHRjb25zdCBoYW5kbGVycyA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9ybU1ldGFkYXRhLmlucHV0RmllbGRzLmZvckVhY2godCA9PiB0LmV2ZW50SGFuZGxlcnMuZm9yRWFjaChoID0+IGhhbmRsZXJzLnB1c2goaCkpKTtcclxuXHRcdFx0XHRcdGZvcm1NZXRhZGF0YS5vdXRwdXRGaWVsZHMuZm9yRWFjaCh0ID0+IHQuZXZlbnRIYW5kbGVycy5mb3JFYWNoKGggPT4gaGFuZGxlcnMucHVzaChoKSkpO1xyXG5cdFx0XHRcdFx0Zm9ybU1ldGFkYXRhLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChoID0+IGhhbmRsZXJzLnB1c2goaCkpO1xyXG5cdFx0XHRcdFx0YmluZEV2ZW50SGFuZGxlcnNUb0N1c3RvbUV2ZW50cyh0aGlzLCBoYW5kbGVycyk7XHJcblxyXG5cdFx0XHRcdFx0Zm9ybS5maXJlKFwiZm9ybTpsb2FkZWRcIiwgeyBhcHAgfSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQXV0by1zdWJtaXQgZm9ybSBpZiBuZWNlc3NhcnkuXHJcblx0XHRcdFx0XHRpZiAoZm9ybS5tZXRhZGF0YS5wb3N0T25Mb2FkKSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3VibWl0KCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b3BlbkZvcm1zLnB1c2godGhpcyk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuZ2V0KCkucGFyZW50ID09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZ2V0KCkucmVzcG9uc2VNZXRhZGF0YS50aXRsZSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQudGl0bGUgPSBmb3JtLm1ldGFkYXRhLmxhYmVsO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRmaXJlQW5kQnViYmxlVXAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoZXZlbnROYW1lLCBldmVudEFyZ3MpO1xyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm1Db21wb25lbnQgPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKHBhcmVudEZvcm1Db21wb25lbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cGFyZW50Rm9ybUNvbXBvbmVudC5maXJlQW5kQnViYmxlVXAoZXZlbnROYW1lLCBldmVudEFyZ3MpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZW5hYmxlRm9ybSgpIHtcclxuXHRcdFx0XHRjb25zdCBmb3JtSW5zdGFuY2UgPSB0aGlzLmdldCgpLmZvcm07XHJcblxyXG5cdFx0XHRcdC8vIEhpZGUgYWxsIGlucHV0cywgdG8gcmUtcmVuZGVyIHRoZW0uIFRoaXMgaXMgbmVlZGVkIGR1ZSB0byB0aGUgd2F5IHRoYXRcclxuXHRcdFx0XHQvLyBTdmVsdGUgKnNlZW1zKiB0byB3b3JrIC0gaXQgZG9lc24ndCByZS1yZW5kZXIgbmVzdGVkIGNvbXBvbmVudHMsIHVubGVzcyB0aGV5IGFyZSByZWNyZWF0ZWQuXHJcblx0XHRcdFx0dGhpcy5zZXQoeyB2aXNpYmxlSW5wdXRGaWVsZHM6IFtdIH0pO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0Ly8gU2hvdyBpbnB1dHMgYWdhaW4uXHJcblx0XHRcdFx0XHR2aXNpYmxlSW5wdXRGaWVsZHM6IGZvcm1JbnN0YW5jZS5pbnB1dHMuZmlsdGVyKHQgPT4gdC5tZXRhZGF0YS5oaWRkZW4gPT09IGZhbHNlKSxcclxuXHJcblx0XHRcdFx0XHRkaXNhYmxlZDogZmFsc2VcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0cmVuZGVyUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuXHRcdFx0XHRjb25zdCBmb3JtSW5zdGFuY2UgPSB0aGlzLmdldCgpLmZvcm07XHJcblxyXG5cdFx0XHRcdC8vIEZvcmNlIFN2ZWx0ZSB0byByZS1yZW5kZXIgb3V0cHV0cy5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRvdXRwdXRGaWVsZFZhbHVlczogbnVsbFxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRvdXRwdXRGaWVsZFZhbHVlczogZm9ybUluc3RhbmNlLm91dHB1dHMsXHJcblx0XHRcdFx0XHRyZXNwb25zZU1ldGFkYXRhOiByZXNwb25zZS5tZXRhZGF0YVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5nZXQoKS5wYXJlbnQgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0ZG9jdW1lbnQudGl0bGUgPSByZXNwb25zZS5tZXRhZGF0YS50aXRsZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGFzeW5jIHN1Ym1pdChldmVudCwgcmVkaXJlY3QpIHtcclxuXHRcdFx0XHRjb25zdCBzZWxmID0gdGhpcztcclxuXHRcdFx0XHRjb25zdCBmb3JtSW5zdGFuY2UgPSB0aGlzLmdldCgpLmZvcm07XHJcblx0XHRcdFx0Y29uc3QgYXBwID0gdGhpcy5nZXQoKS5hcHA7XHJcblxyXG5cdFx0XHRcdGlmIChldmVudCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gSWYgbm90IGFsbCByZXF1aXJlZCBpbnB1dHMgYXJlIGZpbGxlZC5cclxuXHRcdFx0XHRjb25zdCBhbGxSZXF1aXJlZElucHV0c0hhdmVWYWx1ZXMgPSBhd2FpdCBmb3JtSW5zdGFuY2UuYWxsUmVxdWlyZWRJbnB1dHNIYXZlRGF0YShyZWRpcmVjdCA9PSBudWxsKTtcclxuXHRcdFx0XHRpZiAoIWFsbFJlcXVpcmVkSW5wdXRzSGF2ZVZhbHVlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gRGlzYWJsZSBkb3VibGUtcG9zdHMuXHJcblx0XHRcdFx0c2VsZi5zZXQoeyBkaXNhYmxlZDogdHJ1ZSB9KTtcclxuXHJcblx0XHRcdFx0Ly8gSWYgcG9zdE9uTG9hZCA9PSB0cnVlLCB0aGVuIHRoZSBpbnB1dCBmaWVsZCB2YWx1ZXMgc2hvdWxkIGFwcGVhciBpbiB0aGUgdXJsLlxyXG5cdFx0XHRcdC8vIFJlYXNvbiBpcyB0aGF0IHBvc3RPbkxvYWQgPT0gdHJ1ZSBpcyB1c2VkIGJ5IFwicmVwb3J0XCIgcGFnZXMsIHdoaWNoIG5lZWRcclxuXHRcdFx0XHQvLyB0aGVpciBmaWx0ZXJzIHRvIGJlIHNhdmVkIGluIHRoZSB1cmwuIFRoaXMgZG9lcyBub3QgYXBwbHkgdG8gZm9ybXNcclxuXHRcdFx0XHQvLyB3aXRoIHBvc3RPbkxvYWQgPT0gZmFsc2UsIGJlY2F1c2UgdGhvc2UgZm9ybXMgYXJlIHVzdWFsbHkgZm9yIGNyZWF0aW5nIG5ldyBkYXRhXHJcblx0XHRcdFx0Ly8gYW5kIGhlbmNlIHNob3VsZCBub3QgYmUgdHJhY2tlZCBpbiBicm93c2VyJ3MgaGlzdG9yeSBiYXNlZCBvbiBwYXJhbWV0ZXJzLlxyXG5cdFx0XHRcdGlmIChmb3JtSW5zdGFuY2UubWV0YWRhdGEucG9zdE9uTG9hZCAmJiByZWRpcmVjdCAmJiB0aGlzLmdldCgpLnVzZVVybCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXJsUGFyYW1zID0gYXdhaXQgZm9ybUluc3RhbmNlLmdldFNlcmlhbGl6ZWRJbnB1dFZhbHVlcygpO1xyXG5cclxuXHRcdFx0XHRcdC8vIFVwZGF0ZSB1cmwgaW4gdGhlIGJyb3dzZXIuXHJcblx0XHRcdFx0XHRhcHAuZ28oZm9ybUluc3RhbmNlLm1ldGFkYXRhLmlkLCB1cmxQYXJhbXMpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZvcm1JbnN0YW5jZS5zdWJtaXQoYXBwLCByZWRpcmVjdCA9PSBudWxsLCB7IGZvcm1Db21wb25lbnQ6IHNlbGYgfSk7XHJcblxyXG5cdFx0XHRcdFx0c2VsZi5lbmFibGVGb3JtKCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gU2lnbmFsIGV2ZW50IHRvIGNoaWxkIGNvbnRyb2xzLlxyXG5cdFx0XHRcdFx0c2VsZi5maXJlKFwiZm9ybTpyZXNwb25zZUhhbmRsZWRcIiwge1xyXG5cdFx0XHRcdFx0XHRmb3JtOiBzZWxmLFxyXG5cdFx0XHRcdFx0XHRpbnZva2VkQnlVc2VyOiBldmVudCAhPSBudWxsLFxyXG5cdFx0XHRcdFx0XHRyZXNwb25zZVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRzZWxmLmVuYWJsZUZvcm0oKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHJlbG9hZFRvcEZvcm0oKSB7XHJcblx0XHRcdFx0Y29uc3QgcGFyZW50Rm9ybUNvbXBvbmVudCA9IHRoaXMuZ2V0KCkucGFyZW50O1xyXG5cclxuXHRcdFx0XHRpZiAocGFyZW50Rm9ybUNvbXBvbmVudCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRwYXJlbnRGb3JtQ29tcG9uZW50LnJlbG9hZFRvcEZvcm0oKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnN1Ym1pdChudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHJlbG9hZEFsbEZvcm1zKCkge1xyXG5cdFx0XHRcdGZvciAoY29uc3QgZiBvZiBvcGVuRm9ybXMpIHtcclxuXHRcdFx0XHRcdGYucmVsb2FkVG9wRm9ybSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Z2V0SW5wdXRDb21wb25lbnQoaW5wdXRJZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmdldCgpLmlucHV0cy5maW5kKHQgPT4gdC5nZXQoKS5maWVsZC5tZXRhZGF0YS5pZCA9PT0gaW5wdXRJZCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRkYXRhKCkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGRpc2FibGVkOiBmYWxzZSxcclxuXHRcdFx0XHR0YWJpbmRleCxcclxuXHRcdFx0XHR1cmxEYXRhOiBudWxsLFxyXG5cdFx0XHRcdGluaXRpYWxpemVkOiBmYWxzZSxcclxuXHRcdFx0XHRyZXNwb25zZU1ldGFkYXRhOiB7fSxcclxuXHRcdFx0XHR1c2VVcmw6IHRydWUsXHJcblx0XHRcdFx0cGFyZW50OiBudWxsLCAvLyBDYW4gYmUgc2V0IGlmIHRoaXMgaXMgYSBuZXN0ZWQgZm9ybSB3aXRoaW4gYW5vdGhlciBmb3JtIChpLmUuIC0gSW5saW5lRm9ybS5odG1sKVxyXG5cdFx0XHRcdGlucHV0czogW11cclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblx0XHRjb21wb25lbnRzOiB7XHJcblx0XHRcdEZvcm1JbnB1dCxcclxuXHRcdFx0Rm9ybU91dHB1dCxcclxuXHRcdFx0SGVscFxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5yZXNwb25zZSB7XHJcblx0XHRtYXJnaW4tdG9wOiAxNXB4O1xyXG5cdFx0cGFkZGluZy1sZWZ0OiAxMHB4O1xyXG5cdFx0cGFkZGluZy1yaWdodDogMTBweDtcclxuXHR9XHJcblxyXG5cdC5mb3JtLWhlYWRlciB7XHJcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XHJcblx0XHRwYWRkaW5nLXRvcDogMjBweDtcclxuXHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjYmJkMmQ2O1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHR9XHJcblxyXG5cdC5mb3JtLWhlYWRlciBoMiB7XHJcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0fVxyXG5cclxuXHQuaGVscC1jb250ZW50IHtcclxuXHRcdHRleHQtYWxpZ246IGxlZnQ7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBK09DLFNBQVMsZUFBQyxDQUFDLEFBQ1YsVUFBVSxDQUFFLElBQUksQ0FDaEIsWUFBWSxDQUFFLElBQUksQ0FDbEIsYUFBYSxDQUFFLElBQUksQUFDcEIsQ0FBQyxBQUVELFlBQVksZUFBQyxDQUFDLEFBQ2IsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxDQUFFLElBQUksQ0FDakIsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUNoQyxnQkFBZ0IsQ0FBRSxJQUFJLENBQ3RCLFFBQVEsQ0FBRSxRQUFRLEFBQ25CLENBQUMsQUFFRCwyQkFBWSxDQUFDLEVBQUUsZUFBQyxDQUFDLEFBQ2hCLE9BQU8sQ0FBRSxZQUFZLEFBQ3RCLENBQUMsQUFFRCxhQUFhLGVBQUMsQ0FBQyxBQUNkLFVBQVUsQ0FBRSxJQUFJLEFBQ2pCLENBQUMifQ== */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$8(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.initialized) && create_if_block$8(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.initialized) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$8(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (8:3) {#each documentation as document }
    function create_each_block$3(component, ctx) {

    	var help_initial_data = { data: ctx.document };
    	var help = new SvelteComponent$7({
    		root: component.root,
    		store: component.store,
    		data: help_initial_data
    	});

    	return {
    		c: function create() {
    			help._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			help._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var help_changes = {};
    			if (changed.documentation) help_changes.data = ctx.document;
    			help._set(help_changes);
    		},

    		d: function destroy$$1(detach) {
    			help.destroy(detach);
    		}
    	};
    }

    // (7:2) {#if documentation }
    function create_if_block_2$5(component, ctx) {
    	var each_anchor;

    	var each_value = ctx.documentation;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(component, get_each_context$3(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insertNode(each_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.documentation) {
    				each_value = ctx.documentation;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$3(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    // (3:2) {#if (responseMetadata.title != null && responseMetadata.title != "") || (metadata.label != null && metadata.label != "")}
    function create_if_block_1$6(component, ctx) {
    	var div, h2, text_value = ctx.responseMetadata.title || ctx.metadata.label, text, text_1;

    	var if_block = (ctx.documentation) && create_if_block_2$5(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			h2 = createElement("h2");
    			text = createText(text_value);
    			text_1 = createText("\r\n\r\n\t\t");
    			if (if_block) if_block.c();
    			h2.className = "svelte-1djvwan";
    			addLoc(h2, file$8, 4, 2, 232);
    			div.className = "form-header svelte-1djvwan";
    			addLoc(div, file$8, 3, 3, 203);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(h2, div);
    			appendNode(text, h2);
    			appendNode(text_1, div);
    			if (if_block) if_block.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.responseMetadata || changed.metadata) && text_value !== (text_value = ctx.responseMetadata.title || ctx.metadata.label)) {
    				text.data = text_value;
    			}

    			if (ctx.documentation) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2$5(component, ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (18:2) {#each visibleInputFields as inputField}
    function create_each_block_1$1(component, ctx) {

    	var forminput_initial_data = {
    	 	field: ctx.inputField,
    	 	app: ctx.app,
    	 	tabindex: ctx.tabindex * 100 + ctx.inputField.metadata.orderIndex,
    	 	form: ctx.self
    	 };
    	var forminput = new SvelteComponent$5({
    		root: component.root,
    		store: component.store,
    		data: forminput_initial_data
    	});

    	return {
    		c: function create() {
    			forminput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			forminput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var forminput_changes = {};
    			if (changed.visibleInputFields) forminput_changes.field = ctx.inputField;
    			if (changed.app) forminput_changes.app = ctx.app;
    			if (changed.tabindex || changed.visibleInputFields) forminput_changes.tabindex = ctx.tabindex * 100 + ctx.inputField.metadata.orderIndex;
    			if (changed.self) forminput_changes.form = ctx.self;
    			forminput._set(forminput_changes);
    		},

    		d: function destroy$$1(detach) {
    			forminput.destroy(detach);
    		}
    	};
    }

    // (15:1) {#if initialized && visibleInputFields.length > 0}
    function create_if_block_3$4(component, ctx) {
    	var div, form, text, div_1, button;

    	var each_value_1 = ctx.visibleInputFields;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(component, get_each_context_1$1(ctx, each_value_1, i));
    	}

    	function submit_handler(event) {
    		component.submit(event, true);
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			form = createElement("form");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text = createText("\r\n\t\t");
    			div_1 = createElement("div");
    			button = createElement("button");
    			button.type = "submit";
    			button.disabled = ctx.disabled;
    			button.tabIndex = "-1";
    			button.className = "btn btn-info";
    			addLoc(button, file$8, 21, 3, 752);
    			div_1.className = "full-width";
    			addLoc(div_1, file$8, 20, 2, 723);
    			addListener(form, "submit", submit_handler);
    			addLoc(form, file$8, 16, 1, 501);
    			div.className = "form-body";
    			addLoc(div, file$8, 15, 1, 475);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(form, div);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(form, null);
    			}

    			appendNode(text, form);
    			appendNode(div_1, form);
    			appendNode(button, div_1);
    			button.innerHTML = ctx.submitButtonLabel;
    		},

    		p: function update(changed, ctx) {
    			if (changed.visibleInputFields || changed.app || changed.tabindex || changed.self) {
    				each_value_1 = ctx.visibleInputFields;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(form, text);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (changed.submitButtonLabel) {
    				button.innerHTML = ctx.submitButtonLabel;
    			}

    			if (changed.disabled) {
    				button.disabled = ctx.disabled;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);

    			removeListener(form, "submit", submit_handler);
    		}
    	};
    }

    // (30:2) {#each outputFieldValues as outputField }
    function create_each_block_2(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.outputField.metadata.hidden == false && !(ctx.outputField.metadata.getCustomProperty("hideIfNull") === true && ctx.outputField.data === null)) && create_if_block_5$1(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.outputField.metadata.hidden == false && !(ctx.outputField.metadata.getCustomProperty("hideIfNull") === true && ctx.outputField.data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_5$1(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (31:2) {#if outputField.metadata.hidden == false && !(outputField.metadata.getCustomProperty("hideIfNull") === true && outputField.data === null)}
    function create_if_block_5$1(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.outputField,
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.self
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.outputFieldValues) formoutput_changes.field = ctx.outputField;
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.self) formoutput_changes.parent = ctx.self;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (28:1) {#if outputFieldValues != null}
    function create_if_block_4$3(component, ctx) {
    	var div;

    	var each_value_2 = ctx.outputFieldValues;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(component, get_each_context_2(ctx, each_value_2, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			div.className = "response svelte-1djvwan";
    			addLoc(div, file$8, 28, 1, 941);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.outputFieldValues || changed.app || changed.form || changed.self) {
    				each_value_2 = ctx.outputFieldValues;

    				for (var i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_2.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (1:0) {#if initialized}
    function create_if_block$8(component, ctx) {
    	var div, text, text_1, div_class_value;

    	var if_block = ((ctx.responseMetadata.title != null && ctx.responseMetadata.title != "") || (ctx.metadata.label != null && ctx.metadata.label != "")) && create_if_block_1$6(component, ctx);

    	var if_block_1 = (ctx.initialized && ctx.visibleInputFields.length > 0) && create_if_block_3$4(component, ctx);

    	var if_block_2 = (ctx.outputFieldValues != null) && create_if_block_4$3(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n\t");
    			if (if_block_1) if_block_1.c();
    			text_1 = createText("\r\n\r\n\t");
    			if (if_block_2) if_block_2.c();
    			div.className = div_class_value = "inputs-horizontal-one-column " + ctx.cssClass + " svelte-1djvwan";
    			addLoc(div, file$8, 1, 0, 19);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			if (if_block) if_block.m(div, null);
    			appendNode(text, div);
    			if (if_block_1) if_block_1.m(div, null);
    			appendNode(text_1, div);
    			if (if_block_2) if_block_2.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((ctx.responseMetadata.title != null && ctx.responseMetadata.title != "") || (ctx.metadata.label != null && ctx.metadata.label != "")) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$6(component, ctx);
    					if_block.c();
    					if_block.m(div, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (ctx.initialized && ctx.visibleInputFields.length > 0) {
    				if (if_block_1) {
    					if_block_1.p(changed, ctx);
    				} else {
    					if_block_1 = create_if_block_3$4(component, ctx);
    					if_block_1.c();
    					if_block_1.m(div, text_1);
    				}
    			} else if (if_block_1) {
    				if_block_1.d(1);
    				if_block_1 = null;
    			}

    			if (ctx.outputFieldValues != null) {
    				if (if_block_2) {
    					if_block_2.p(changed, ctx);
    				} else {
    					if_block_2 = create_if_block_4$3(component, ctx);
    					if_block_2.c();
    					if_block_2.m(div, null);
    				}
    			} else if (if_block_2) {
    				if_block_2.d(1);
    				if_block_2 = null;
    			}

    			if ((changed.cssClass) && div_class_value !== (div_class_value = "inputs-horizontal-one-column " + ctx.cssClass + " svelte-1djvwan")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    			if (if_block_1) if_block_1.d();
    			if (if_block_2) if_block_2.d();
    		}
    	};
    }

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.document = list[i];
    	child_ctx.each_value = list;
    	child_ctx.document_index = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.inputField = list[i];
    	child_ctx.each_value_1 = list;
    	child_ctx.inputField_index = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.outputField = list[i];
    	child_ctx.each_value_2 = list;
    	child_ctx.outputField_index = i;
    	return child_ctx;
    }

    function SvelteComponent$8(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign(data$6(), options.data);
    	if (!('initialized' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'initialized'");
    	if (!('cssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'cssClass'");
    	if (!('responseMetadata' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'responseMetadata'");
    	if (!('metadata' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'metadata'");
    	if (!('documentation' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'documentation'");
    	if (!('visibleInputFields' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visibleInputFields'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	if (!('self' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'self'");
    	if (!('disabled' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'disabled'");
    	if (!('submitButtonLabel' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'submitButtonLabel'");
    	if (!('outputFieldValues' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'outputFieldValues'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	this._intro = true;

    	this._handlers.destroy = [ondestroy];

    	if (!document.getElementById("svelte-1djvwan-style")) add_css$4();

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$8(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$8.prototype, protoDev);
    assign(SvelteComponent$8.prototype, methods$2);

    SvelteComponent$8.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var AppRouter = /** @class */ (function () {
        function AppRouter(element, app) {
            this.element = element;
            this.stateRenderer = svelteStateRenderer({});
            this.stateRouter = abstractStateRouter(this.stateRenderer, this.element);
            var rpb = this.rpb = new RouteParameterBuilder("_", app);
            this.stateRouter.addState({
                name: "home",
                route: "/home",
                template: SvelteComponent$3,
                resolve: function (data, parameters, cb) {
                    cb(false, {
                        app: app,
                        parent: SvelteComponent$8
                    });
                }
            });
            var self = this;
            this.stateRouter.addState({
                name: "menu",
                route: "/menu",
                template: SvelteComponent$2,
                resolve: function (data, parameters, cb) {
                    cb(false, {
                        forms: app.forms,
                        makeUrl: function (formId) { return self.makeUrl(formId, null); }
                    });
                }
            });
            this.stateRouter.addState({
                name: "form",
                data: {},
                route: "/form/:_id",
                template: SvelteComponent$8,
                // Force route reload when value of _d parameter changes. This is
                // needed because by default the router will not reload route even if
                // any of the parameters change, unless they are specified in "querystringParameters".
                // This means that if we are trying to reload same form, but with different parameters,
                // nothing will happen, unless _d changes too.
                querystringParameters: [rpb.parameterName],
                defaultParameters: rpb.defaultParameters,
                activate: function (context) {
                    context.domApi.init();
                    rpb.currentForm = context.parameters._id;
                    context.on("destroy", function () { return rpb.currentForm = null; });
                    self.fire("router:activated", null);
                },
                resolve: function (data, parameters, cb) {
                    var formInstance = app.getFormInstance(parameters._id, true);
                    formInstance.initializeInputFields(parameters).then(function () {
                        cb(false, {
                            metadata: formInstance.metadata,
                            form: formInstance,
                            app: app
                        });
                    });
                }
            });
            this.stateRouter.evaluateCurrentRoute("home");
        }
        AppRouter.prototype.fire = function (eventName, params) {
            var event = new Event(eventName, params);
            this.element.dispatchEvent(event);
        };
        AppRouter.prototype.on = function (eventName, fn) {
            this.element.addEventListener(eventName, function () {
                fn();
            });
        };
        AppRouter.prototype.go = function (form, values) {
            this.stateRouter.go("form", this.rpb.buildFormRouteParameters(form, values));
        };
        AppRouter.prototype.makeUrl = function (form, values) {
            return this.stateRouter.makePath("form", this.rpb.buildFormRouteParameters(form, values));
        };
        return AppRouter;
    }());

    var BooleanInputController = /** @class */ (function (_super) {
        __extends(BooleanInputController, _super);
        function BooleanInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BooleanInputController.prototype.serializeValue = function (value) {
            var parsed = this.parse(value);
            return parsed != null ? parsed.toString() : null;
        };
        BooleanInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        BooleanInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.value));
        };
        BooleanInputController.prototype.parse = function (value) {
            return value != null && value.toString() !== ""
                ? value.toString() === "true"
                : this.metadata.required ? false : null;
        };
        return BooleanInputController;
    }(InputController));

    var DateInputController = /** @class */ (function (_super) {
        __extends(DateInputController, _super);
        function DateInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.valueAsText = null;
            return _this;
        }
        DateInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = DateInputController.parseDate(value);
                _this.valueAsText = _this.serializeValue(_this.value);
                resolve(_this);
            });
        };
        DateInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        DateInputController.prototype.serializeValue = function (date) {
            return DateInputController.serialize(date);
        };
        DateInputController.serialize = function (date) {
            var asDate = typeof (date) === "string"
                ? DateInputController.parseDate(date)
                : date;
            return asDate != null
                ? asDate.getFullYear() + "-" + DateInputController.format2DecimalPlaces(asDate.getMonth() + 1) + "-" + DateInputController.format2DecimalPlaces(asDate.getDate())
                : null;
        };
        DateInputController.parseDate = function (value) {
            var selectedDate = this.asUtcTime(value, 7, 0, 0);
            if (selectedDate) {
                var dateAsNumber = Date.parse(selectedDate.toString());
                return isNaN(dateAsNumber) ? null : new Date(dateAsNumber);
            }
        };
        DateInputController.asUtcTime = function (date, hour, min, second) {
            /// <summary>Returns provided date as if it was UTC date.</summary>
            /// <param name="date">Local date/time.</param>
            /// <returns type="Date">Date object.</returns>
            if (date == null) {
                return null;
            }
            // If string but not UTC.
            if (typeof (date) === "string" && date[date.length - 1] !== "Z") {
                var year = parseInt(date.substr(0, 4), 10);
                var month = parseInt(date.substr(5, 2), 10);
                var day = parseInt(date.substr(8, 2), 10);
                // Assume UTC.
                return this.getIsoDate(year, month, day, hour, min, second);
            }
            var datepart = new Date(new Date(date).toISOString());
            return this.getIsoDate(datepart.getFullYear(), datepart.getMonth() + 1, datepart.getDate(), hour, min, second);
        };
        DateInputController.getIsoDate = function (year, month, day, hour, min, second) {
            var iso = year +
                "-" + // year
                this.format2DecimalPlaces(month) +
                "-" + // month
                this.format2DecimalPlaces(day) + // day
                "T" +
                this.format2DecimalPlaces(hour) +
                ":" +
                this.format2DecimalPlaces(min) +
                ":" +
                this.format2DecimalPlaces(second) +
                ".000Z";
            return new Date(iso);
        };
        DateInputController.format2DecimalPlaces = function (n) {
            return ("0" + n).slice(-2);
        };
        return DateInputController;
    }(InputController));

    var DateRangeInputController = /** @class */ (function (_super) {
        __extends(DateRangeInputController, _super);
        function DateRangeInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.minValueAsText = null;
            _this.maxValueAsText = null;
            return _this;
        }
        DateRangeInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                if (_this.value != null && _this.value.min != null) {
                    _this.minValueAsText = DateInputController.serialize(_this.value.min);
                }
                if (_this.value != null && _this.value.max != null) {
                    _this.maxValueAsText = DateInputController.serialize(_this.value.max);
                }
                resolve(_this);
            });
        };
        DateRangeInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        DateRangeInputController.prototype.serializeValue = function (date) {
            var parsed = this.parse(date);
            return parsed != null ? parsed.serialize() : "";
        };
        DateRangeInputController.prototype.parse = function (value) {
            if (value == null) {
                return new DateRange();
            }
            return typeof (value) === "string"
                ? DateRange.parse(value)
                : value;
        };
        return DateRangeInputController;
    }(InputController));
    var DateRange = /** @class */ (function () {
        function DateRange(min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            this.min = min;
            this.max = max;
        }
        DateRange.parse = function (date) {
            var split = date.split("|");
            var minPart = DateInputController.parseDate(split[0]), maxPart = DateInputController.parseDate(split[1]);
            return new DateRange(minPart, maxPart);
        };
        DateRange.prototype.serialize = function () {
            return DateInputController.serialize(this.min) + "|" + DateInputController.serialize(this.max);
        };
        return DateRange;
    }());

    var DropdownInputController = /** @class */ (function (_super) {
        __extends(DropdownInputController, _super);
        function DropdownInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DropdownInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        DropdownInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value != null ? value.toString() : null;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        DropdownInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        DropdownInputController.prototype.initFromSelected = function () {
            this.value = this.parse(this.selected);
        };
        DropdownInputController.prototype.parse = function (value) {
            return value == null || value == "" ? null : { value: value };
        };
        return DropdownInputController;
    }(InputController));

    var EmailInputController = /** @class */ (function (_super) {
        __extends(EmailInputController, _super);
        function EmailInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EmailInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        EmailInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        EmailInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        EmailInputController.prototype.parse = function (value) {
            return value == null || value == "" ? null : Email.parse(value);
        };
        return EmailInputController;
    }(InputController));
    var Email = /** @class */ (function () {
        function Email(value) {
            if (value === void 0) { value = null; }
            this.value = value;
        }
        Email.parse = function (value) {
            return new Email(value);
        };
        return Email;
    }());

    var axios$3 = axios$1;
    var FileUploaderController = /** @class */ (function (_super) {
        __extends(FileUploaderController, _super);
        function FileUploaderController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.filesIds = [];
            return _this;
        }
        FileUploaderController.prototype.serializeValue = function (value) {
            return value != null ? JSON.stringify(value) : null;
        };
        FileUploaderController.prototype.init = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                // Don't do anything. File uploader doesn't allow initialization
                // from pre-existing value.
                resolve(_this);
            });
        };
        FileUploaderController.prototype.getValue = function () {
            var self = this;
            if (self.selected == null ||
                self.selected.length === 0) {
                return Promise.resolve(new FileUploaderValue());
            }
            var promises = [];
            var result = new FileUploaderValue();
            var files = self.selected;
            if (self.filesIds.length > 0) {
                for (var _i = 0, _a = self.filesIds; _i < _a.length; _i++) {
                    var fileId = _a[_i];
                    result.files.push(fileId);
                }
                self.filesIds = [];
                self.selected = null;
            }
            else {
                var p = new Promise(function (resolve, reject) {
                    var formData = new FormData();
                    for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                        var f = files_1[_i];
                        formData.append("file", f);
                    }
                    // Make http request to upload the files.
                    axios$3.post("/file/upload", formData, {
                        headers: {
                            "Content-Type": "multipart/form-data"
                        }
                    }).then(function (response) {
                        if (response.data.fileIds != null && response.data.fileIds.length > 0) {
                            for (var _i = 0, _a = response.data.fileIds; _i < _a.length; _i++) {
                                var fileId = _a[_i];
                                result.files.push(fileId);
                                self.filesIds.push(fileId);
                            }
                        }
                        resolve();
                    }).catch(function (error) {
                        alert(error.response.data.error);
                        reject(error);
                    });
                });
                promises.push(p);
            }
            return Promise.all(promises).then(function (t) {
                return result;
            });
        };
        return FileUploaderController;
    }(InputController));
    var FileUploaderValue = /** @class */ (function () {
        function FileUploaderValue() {
            this.files = [];
        }
        return FileUploaderValue;
    }());

    var MultiSelectInputController = /** @class */ (function (_super) {
        __extends(MultiSelectInputController, _super);
        function MultiSelectInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxItemCount = -1;
            return _this;
        }
        MultiSelectInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? (value.items || []).join(",") : null;
        };
        MultiSelectInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        MultiSelectInputController.prototype.getValue = function () {
            var valueToSubmit = this.value == null || this.value.items == null || this.value.items.length === 0
                ? null
                : this.value;
            return Promise.resolve(valueToSubmit);
        };
        MultiSelectInputController.prototype.parse = function (value) {
            return value == null || value === ""
                ? new MultiSelectValue()
                : new MultiSelectValue(value.split(","));
        };
        return MultiSelectInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var MultiSelectValue = /** @class */ (function () {
        function MultiSelectValue(items) {
            this.items = [];
            this.items = items;
        }
        return MultiSelectValue;
    }());

    var NumberInputController = /** @class */ (function (_super) {
        __extends(NumberInputController, _super);
        function NumberInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NumberInputController.prototype.serializeValue = function (value) {
            return NumberInputController.serialize(value);
        };
        NumberInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var v = parseFloat(value);
                _this.value = isNaN(v) ? null : v;
                resolve(_this);
            });
        };
        NumberInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        NumberInputController.serialize = function (value) {
            return value != null ? value.toString() : null;
        };
        return NumberInputController;
    }(InputController));

    var NumberRangeInputController = /** @class */ (function (_super) {
        __extends(NumberRangeInputController, _super);
        function NumberRangeInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.min = null;
            _this.max = null;
            return _this;
        }
        NumberRangeInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        NumberRangeInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        NumberRangeInputController.prototype.serializeValue = function (num) {
            var parsed = this.parse(num);
            return parsed != null ? parsed.serialize() : "";
        };
        NumberRangeInputController.prototype.parse = function (value) {
            if (value == null) {
                return new NumberRange();
            }
            return typeof (value) === "string"
                ? NumberRange.parse(value)
                : value;
        };
        return NumberRangeInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var NumberRange = /** @class */ (function () {
        function NumberRange(min, max) {
            if (min === void 0) { min = null; }
            if (max === void 0) { max = null; }
            this.min = min;
            this.max = max;
        }
        NumberRange.parse = function (range) {
            var split = range.split("|");
            var minValue = parseFloat(split[0]);
            var maxValue = parseFloat(split[1]);
            return new NumberRange(minValue, maxValue);
        };
        NumberRange.prototype.serialize = function () {
            return NumberInputController.serialize(this.min) + "|" + NumberInputController.serialize(this.max);
        };
        return NumberRange;
    }());

    var PaginationParameters = /** @class */ (function () {
        function PaginationParameters(pageIndex, pageSize, orderBy, ascending) {
            this.pageIndex = PaginationParameters.asInt(pageIndex, 1);
            this.pageSize = PaginationParameters.asInt(pageSize, 10);
            this.orderBy = orderBy || null;
            this.ascending = PaginationParameters.asBool(ascending, null);
        }
        PaginationParameters.asInt = function (value, defaultValue) {
            if (typeof (value) === "string") {
                var result = parseInt(value, 10);
                return isNaN(result) ? defaultValue : result;
            }
            if (value == null) {
                return defaultValue;
            }
            return value;
        };
        PaginationParameters.asBool = function (value, defaultValue) {
            if (typeof (value) === "string" || value == null) {
                return value != null
                    ? value.toString() === "true"
                    : defaultValue;
            }
            return value;
        };
        return PaginationParameters;
    }());
    // tslint:disable-next-line:max-classes-per-file
    var PaginatorInputController = /** @class */ (function (_super) {
        __extends(PaginatorInputController, _super);
        function PaginatorInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PaginatorInputController.prototype.serializeValue = function (value) {
            var p = typeof (value) === "string" || value == null
                ? this.parse(value)
                : value;
            if (p.pageIndex === 1 &&
                p.pageSize === 10 &&
                p.ascending == null &&
                p.orderBy == null) {
                return "";
            }
            var result = p.pageIndex + "-" + p.pageSize;
            if (p.orderBy != null) {
                result += "-" + p.orderBy + "-" + p.ascending + "}";
            }
            return result;
        };
        PaginatorInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        PaginatorInputController.prototype.getValue = function () {
            return Promise.resolve(this.value);
        };
        PaginatorInputController.prototype.parse = function (value) {
            // 1-10-firstname-asc
            // 1-10
            if (value == null || value.length === 0) {
                return new PaginationParameters();
            }
            var components = value.split("-");
            return new PaginationParameters(components[0], components[1], components[2], components[3]);
        };
        return PaginatorInputController;
    }(InputController));

    var PasswordInputController = /** @class */ (function (_super) {
        __extends(PasswordInputController, _super);
        function PasswordInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PasswordInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        PasswordInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        PasswordInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        PasswordInputController.prototype.parse = function (value) {
            return value == null || value === "" ? null : { value: value };
        };
        return PasswordInputController;
    }(InputController));

    var TextareaInputController = /** @class */ (function (_super) {
        __extends(TextareaInputController, _super);
        function TextareaInputController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextareaInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        TextareaInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.selected = value;
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        TextareaInputController.prototype.getValue = function () {
            return Promise.resolve(this.parse(this.selected));
        };
        TextareaInputController.prototype.parse = function (value) {
            return value == null || value === "" ? null : { value: value };
        };
        return TextareaInputController;
    }(InputController));

    var TypeaheadInputController = /** @class */ (function (_super) {
        __extends(TypeaheadInputController, _super);
        function TypeaheadInputController() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxItemCount = 1;
            return _this;
        }
        TypeaheadInputController.prototype.serializeValue = function (value) {
            if (typeof (value) === "string") {
                return value;
            }
            return value != null ? value.value : null;
        };
        TypeaheadInputController.prototype.init = function (value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.value = _this.parse(value);
                resolve(_this);
            });
        };
        TypeaheadInputController.prototype.getValue = function () {
            var valueToSubmit = this.value == null || this.value.value == null
                ? null
                : this.value;
            return Promise.resolve(valueToSubmit);
        };
        TypeaheadInputController.prototype.parse = function (value) {
            return value == null || value === ""
                ? new TypeaheadValue()
                : new TypeaheadValue(value);
        };
        return TypeaheadInputController;
    }(InputController));
    // tslint:disable-next-line:max-classes-per-file
    var TypeaheadValue = /** @class */ (function () {
        function TypeaheadValue(value) {
            this.value = value;
        }
        return TypeaheadValue;
    }());

    /* src\core\ui\inputs\Boolean.html generated by Svelte v2.9.5 */

    const file$9 = "src\\core\\ui\\inputs\\Boolean.html";

    function add_css$5() {
    	var style = createElement("style");
    	style.id = 'svelte-1h5tf6j-style';
    	style.textContent = ".checkbox.svelte-1h5tf6j{height:20px;width:20px;margin:0.6rem 0.5rem 1.1rem 0.5rem;overflow:initial;position:relative;clip:initial;-webkit-clip-path:initial;clip-path:initial;top:3px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQm9vbGVhbi5odG1sIiwic291cmNlcyI6WyJCb29sZWFuLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cclxuPGlucHV0IHR5cGU9XCJjaGVja2JveFwiXHJcblx0aWQ9XCJ7aWR9XCJcclxuXHRjbGFzcz1cImNoZWNrYm94IGZvcm0tY29udHJvbFwiXHJcblx0YmluZDpjaGVja2VkPVwiZmllbGQudmFsdWVcIlxyXG5cdHRhYmluZGV4PVwie3RhYmluZGV4fVwiPlxyXG57OmVsc2V9XHJcbjxzZWxlY3QgYmluZDp2YWx1ZT1cImZpZWxkLnZhbHVlXCJcclxuXHRpZD1cIntpZH1cIlxyXG5cdGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XHJcblx0PG9wdGlvbj48L29wdGlvbj5cclxuXHQ8b3B0aW9uIHZhbHVlPVwie3RydWV9XCI+WWVzPC9vcHRpb24+XHJcblx0PG9wdGlvbiB2YWx1ZT1cIntmYWxzZX1cIj5Obzwvb3B0aW9uPlxyXG48L3NlbGVjdD5cclxuey9pZn1cclxuXHJcbjxzdHlsZT5cclxuXHQuY2hlY2tib3gge1xyXG5cdFx0aGVpZ2h0OiAyMHB4O1xyXG5cdFx0d2lkdGg6IDIwcHg7XHJcblx0XHRtYXJnaW46IDAuNnJlbSAwLjVyZW0gMS4xcmVtIDAuNXJlbTtcclxuXHRcdG92ZXJmbG93OiBpbml0aWFsO1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0Y2xpcDogaW5pdGlhbDtcclxuXHRcdC13ZWJraXQtY2xpcC1wYXRoOiBpbml0aWFsO1xyXG5cdFx0Y2xpcC1wYXRoOiBpbml0aWFsO1xyXG5cdFx0dG9wOiAzcHg7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJDLFNBQVMsZUFBQyxDQUFDLEFBQ1YsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQ25DLFFBQVEsQ0FBRSxPQUFPLENBQ2pCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxPQUFPLENBQ2IsaUJBQWlCLENBQUUsT0FBTyxDQUMxQixTQUFTLENBQUUsT0FBTyxDQUNsQixHQUFHLENBQUUsR0FBRyxBQUNULENBQUMifQ== */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$9(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.field.metadata.required) return create_if_block$9;
    		return create_if_block_1$7;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.metadata.required}
    function create_if_block$9(component, ctx) {
    	var input;

    	function input_change_handler() {
    		ctx.field.value = input.checked;
    		component.set({ field: ctx.field });
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "change", input_change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.id = ctx.id;
    			input.className = "checkbox form-control svelte-1h5tf6j";
    			input.tabIndex = ctx.tabindex;
    			addLoc(input, file$9, 1, 0, 31);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);

    			input.checked = ctx.field.value;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			input.checked = ctx.field.value;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    		}
    	};
    }

    // (7:0) {:else}
    function create_if_block_1$7(component, ctx) {
    	var select, option, option_1, text, option_2, text_1, select_updating = false;

    	function select_change_handler() {
    		select_updating = true;
    		ctx.field.value = selectValue(select);
    		component.set({ field: ctx.field });
    		select_updating = false;
    	}

    	return {
    		c: function create() {
    			select = createElement("select");
    			option = createElement("option");
    			option_1 = createElement("option");
    			text = createText("Yes");
    			option_2 = createElement("option");
    			text_1 = createText("No");
    			option.__value = "";
    			option.value = option.__value;
    			addLoc(option, file$9, 10, 1, 233);
    			option_1.__value = true;
    			option_1.value = option_1.__value;
    			addLoc(option_1, file$9, 11, 1, 253);
    			option_2.__value = false;
    			option_2.value = option_2.__value;
    			addLoc(option_2, file$9, 12, 1, 291);
    			addListener(select, "change", select_change_handler);
    			if (!('field' in ctx)) component.root._beforecreate.push(select_change_handler);
    			select.id = ctx.id;
    			select.className = "form-control";
    			addLoc(select, file$9, 7, 0, 162);
    		},

    		m: function mount(target, anchor) {
    			insertNode(select, target, anchor);
    			appendNode(option, select);
    			appendNode(option_1, select);
    			appendNode(text, option_1);
    			appendNode(option_2, select);
    			appendNode(text_1, option_2);

    			selectOption(select, ctx.field.value);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!select_updating) selectOption(select, ctx.field.value);
    			if (changed.id) {
    				select.id = ctx.id;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(select);
    			}

    			removeListener(select, "change", select_change_handler);
    		}
    	};
    }

    function SvelteComponent$9(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1h5tf6j-style")) add_css$5();

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    	}

    	this._fragment = create_main_fragment$9(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._beforecreate);
    	}
    }

    assign(SvelteComponent$9.prototype, protoDev);

    SvelteComponent$9.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray$1(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject$1(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined$1(input) {
        return input === void 0;
    }

    function isNumber$1(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate$1(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend$2(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend$2(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined$1(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined$1(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined$1(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined$1(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined$1(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined$1(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined$1(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined$1(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined$1(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined$1(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined$1(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend$2(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction$2(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set$1 (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction$2(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend$2({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject$1(parentConfig[prop]) && isObject$1(childConfig[prop])) {
                    res[prop] = {};
                    extend$2(res[prop], parentConfig[prop]);
                    extend$2(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject$1(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend$2({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction$2(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction$2(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction$2(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction$2(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction$2(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber$1(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$2(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get$2(this, unit);
            }
        };
    }

    function get$2 (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$2 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction$2(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction$2(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray$1(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray$1(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray$1(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray$1(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber$1(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get$2(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y, m, d, h, M, s, ms);

        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return isArray$1(this._weekdays) ? this._weekdays :
                this._weekdays['standalone'];
        }
        return isArray$1(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined$1(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray$1(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults$1(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults$1(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults$1(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults$1(w.W, 1);
            weekday = defaults$1(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults$1(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults$1(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend$2(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate$1(input)) {
            config._d = input;
        } else if (isArray$1(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined$1(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate$1(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray$1(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject$1(input)) {
            configFromObject(config);
        } else if (isNumber$1(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject$1(input) && isObjectEmpty(input)) ||
                (isArray$1(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray$1(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate$1(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined$1(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber$1(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get$2(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$2(mom, 'Date', get$2(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add$1      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction$2(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined$1(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined$1(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString$1 () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction$2(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject$1 () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend$2({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto$1 = Moment.prototype;

    proto$1.add               = add$1;
    proto$1.calendar          = calendar$1;
    proto$1.clone             = clone;
    proto$1.diff              = diff;
    proto$1.endOf             = endOf;
    proto$1.format            = format;
    proto$1.from              = from;
    proto$1.fromNow           = fromNow;
    proto$1.to                = to;
    proto$1.toNow             = toNow;
    proto$1.get               = stringGet;
    proto$1.invalidAt         = invalidAt;
    proto$1.isAfter           = isAfter;
    proto$1.isBefore          = isBefore;
    proto$1.isBetween         = isBetween;
    proto$1.isSame            = isSame;
    proto$1.isSameOrAfter     = isSameOrAfter;
    proto$1.isSameOrBefore    = isSameOrBefore;
    proto$1.isValid           = isValid$2;
    proto$1.lang              = lang;
    proto$1.locale            = locale;
    proto$1.localeData        = localeData;
    proto$1.max               = prototypeMax;
    proto$1.min               = prototypeMin;
    proto$1.parsingFlags      = parsingFlags;
    proto$1.set               = stringSet;
    proto$1.startOf           = startOf;
    proto$1.subtract          = subtract;
    proto$1.toArray           = toArray;
    proto$1.toObject          = toObject$1;
    proto$1.toDate            = toDate;
    proto$1.toISOString       = toISOString;
    proto$1.inspect           = inspect;
    proto$1.toJSON            = toJSON;
    proto$1.toString          = toString$1;
    proto$1.unix              = unix;
    proto$1.valueOf           = valueOf;
    proto$1.creationData      = creationData;
    proto$1.year       = getSetYear;
    proto$1.isLeapYear = getIsLeapYear;
    proto$1.weekYear    = getSetWeekYear;
    proto$1.isoWeekYear = getSetISOWeekYear;
    proto$1.quarter = proto$1.quarters = getSetQuarter;
    proto$1.month       = getSetMonth;
    proto$1.daysInMonth = getDaysInMonth;
    proto$1.week           = proto$1.weeks        = getSetWeek;
    proto$1.isoWeek        = proto$1.isoWeeks     = getSetISOWeek;
    proto$1.weeksInYear    = getWeeksInYear;
    proto$1.isoWeeksInYear = getISOWeeksInYear;
    proto$1.date       = getSetDayOfMonth;
    proto$1.day        = proto$1.days             = getSetDayOfWeek;
    proto$1.weekday    = getSetLocaleDayOfWeek;
    proto$1.isoWeekday = getSetISODayOfWeek;
    proto$1.dayOfYear  = getSetDayOfYear;
    proto$1.hour = proto$1.hours = getSetHour;
    proto$1.minute = proto$1.minutes = getSetMinute;
    proto$1.second = proto$1.seconds = getSetSecond;
    proto$1.millisecond = proto$1.milliseconds = getSetMillisecond;
    proto$1.utcOffset            = getSetOffset;
    proto$1.utc                  = setOffsetToUTC;
    proto$1.local                = setOffsetToLocal;
    proto$1.parseZone            = setOffsetToParsedOffset;
    proto$1.hasAlignedHourOffset = hasAlignedHourOffset;
    proto$1.isDST                = isDaylightSavingTime;
    proto$1.isLocal              = isLocal;
    proto$1.isUtcOffset          = isUtcOffset;
    proto$1.isUtc                = isUtc;
    proto$1.isUTC                = isUtc;
    proto$1.zoneAbbr = getZoneAbbr;
    proto$1.zoneName = getZoneName;
    proto$1.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto$1.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto$1.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto$1.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto$1.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$2 = Locale.prototype;

    proto$2.calendar        = calendar;
    proto$2.longDateFormat  = longDateFormat;
    proto$2.invalidDate     = invalidDate;
    proto$2.ordinal         = ordinal;
    proto$2.preparse        = preParsePostFormat;
    proto$2.postformat      = preParsePostFormat;
    proto$2.relativeTime    = relativeTime;
    proto$2.pastFuture      = pastFuture;
    proto$2.set             = set$1;

    proto$2.months            =        localeMonths;
    proto$2.monthsShort       =        localeMonthsShort;
    proto$2.monthsParse       =        localeMonthsParse;
    proto$2.monthsRegex       = monthsRegex;
    proto$2.monthsShortRegex  = monthsShortRegex;
    proto$2.week = localeWeek;
    proto$2.firstDayOfYear = localeFirstDayOfYear;
    proto$2.firstDayOfWeek = localeFirstDayOfWeek;

    proto$2.weekdays       =        localeWeekdays;
    proto$2.weekdaysMin    =        localeWeekdaysMin;
    proto$2.weekdaysShort  =        localeWeekdaysShort;
    proto$2.weekdaysParse  =        localeWeekdaysParse;

    proto$2.weekdaysRegex       =        weekdaysRegex;
    proto$2.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$2.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$2.isPM = localeIsPM;
    proto$2.meridiem = localeMeridiem;

    function get$3 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber$1(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$3(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$3(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber$1(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber$1(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$3(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$3(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$2 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$4 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize$1 (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$3 = Duration.prototype;

    proto$3.isValid        = isValid$1;
    proto$3.abs            = abs;
    proto$3.add            = add$2;
    proto$3.subtract       = subtract$1;
    proto$3.as             = as;
    proto$3.asMilliseconds = asMilliseconds;
    proto$3.asSeconds      = asSeconds;
    proto$3.asMinutes      = asMinutes;
    proto$3.asHours        = asHours;
    proto$3.asDays         = asDays;
    proto$3.asWeeks        = asWeeks;
    proto$3.asMonths       = asMonths;
    proto$3.asYears        = asYears;
    proto$3.valueOf        = valueOf$1;
    proto$3._bubble        = bubble;
    proto$3.clone          = clone$1;
    proto$3.get            = get$4;
    proto$3.milliseconds   = milliseconds;
    proto$3.seconds        = seconds;
    proto$3.minutes        = minutes;
    proto$3.hours          = hours;
    proto$3.days           = days;
    proto$3.weeks          = weeks;
    proto$3.months         = months;
    proto$3.years          = years;
    proto$3.humanize       = humanize$1;
    proto$3.toISOString    = toISOString$1;
    proto$3.toString       = toISOString$1;
    proto$3.toJSON         = toISOString$1;
    proto$3.locale         = locale;
    proto$3.localeData     = localeData;

    proto$3.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$3.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports

    //! moment.js

    hooks.version = '2.22.2';

    setHookCallback(createLocal);

    hooks.fn                    = proto$1;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate$1;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto$1;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'YYYY-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    var moment = /*#__PURE__*/Object.freeze({
        default: hooks
    });

    var require$$0 = ( moment && hooks ) || moment;

    var pikaday = createCommonjsModule(function (module, exports) {
    /*!
     * Pikaday
     *
     * Copyright  2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
     */

    (function (root, factory)
    {

        var moment;
        {
            // CommonJS module
            // Load moment.js as an optional dependency
            try { moment = require$$0; } catch (e) {}
            module.exports = factory(moment);
        }
    }(commonjsGlobal, function (moment)
    {

        /**
         * feature detection and helper functions
         */
        var hasMoment = typeof moment === 'function',

        hasEventListeners = !!window.addEventListener,

        document = window.document,

        sto = window.setTimeout,

        addEvent = function(el, e, callback, capture)
        {
            if (hasEventListeners) {
                el.addEventListener(e, callback, !!capture);
            } else {
                el.attachEvent('on' + e, callback);
            }
        },

        removeEvent = function(el, e, callback, capture)
        {
            if (hasEventListeners) {
                el.removeEventListener(e, callback, !!capture);
            } else {
                el.detachEvent('on' + e, callback);
            }
        },

        trim = function(str)
        {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
        },

        hasClass = function(el, cn)
        {
            return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
        },

        addClass = function(el, cn)
        {
            if (!hasClass(el, cn)) {
                el.className = (el.className === '') ? cn : el.className + ' ' + cn;
            }
        },

        removeClass = function(el, cn)
        {
            el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
        },

        isArray = function(obj)
        {
            return (/Array/).test(Object.prototype.toString.call(obj));
        },

        isDate = function(obj)
        {
            return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
        },

        isWeekend = function(date)
        {
            var day = date.getDay();
            return day === 0 || day === 6;
        },

        isLeapYear = function(year)
        {
            // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },

        getDaysInMonth = function(year, month)
        {
            return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
        },

        setToStartOfDay = function(date)
        {
            if (isDate(date)) date.setHours(0,0,0,0);
        },

        compareDates = function(a,b)
        {
            // weak date comparison (use setToStartOfDay(date) to ensure correct result)
            return a.getTime() === b.getTime();
        },

        extend = function(to, from, overwrite)
        {
            var prop, hasProp;
            for (prop in from) {
                hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                    if (isDate(from[prop])) {
                        if (overwrite) {
                            to[prop] = new Date(from[prop].getTime());
                        }
                    }
                    else if (isArray(from[prop])) {
                        if (overwrite) {
                            to[prop] = from[prop].slice(0);
                        }
                    } else {
                        to[prop] = extend({}, from[prop], overwrite);
                    }
                } else if (overwrite || !hasProp) {
                    to[prop] = from[prop];
                }
            }
            return to;
        },

        fireEvent = function(el, eventName, data)
        {
            var ev;

            if (document.createEvent) {
                ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, true, false);
                ev = extend(ev, data);
                el.dispatchEvent(ev);
            } else if (document.createEventObject) {
                ev = document.createEventObject();
                ev = extend(ev, data);
                el.fireEvent('on' + eventName, ev);
            }
        },

        adjustCalendar = function(calendar) {
            if (calendar.month < 0) {
                calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
                calendar.month += 12;
            }
            if (calendar.month > 11) {
                calendar.year += Math.floor(Math.abs(calendar.month)/12);
                calendar.month -= 12;
            }
            return calendar;
        },

        /**
         * defaults and localisation
         */
        defaults = {

            // bind the picker to a form field
            field: null,

            // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
            bound: undefined,

            // position of the datepicker, relative to the field (default to bottom & left)
            // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
            position: 'bottom left',

            // automatically fit in the viewport even if it means repositioning from the position option
            reposition: true,

            // the default output format for `.toString()` and `field` value
            format: 'YYYY-MM-DD',

            // the toString function which gets passed a current date object and format
            // and returns a string
            toString: null,

            // used to create date object from current input string
            parse: null,

            // the initial date to view when first opened
            defaultDate: null,

            // make the `defaultDate` the initial selected value
            setDefaultDate: false,

            // first day of week (0: Sunday, 1: Monday etc)
            firstDay: 0,

            // the default flag for moment's strict date parsing
            formatStrict: false,

            // the minimum/earliest date that can be selected
            minDate: null,
            // the maximum/latest date that can be selected
            maxDate: null,

            // number of years either side, or array of upper/lower range
            yearRange: 10,

            // show week numbers at head of row
            showWeekNumber: false,

            // Week picker mode
            pickWholeWeek: false,

            // used internally (don't config outside)
            minYear: 0,
            maxYear: 9999,
            minMonth: undefined,
            maxMonth: undefined,

            startRange: null,
            endRange: null,

            isRTL: false,

            // Additional text to append to the year in the calendar title
            yearSuffix: '',

            // Render the month after year in the calendar title
            showMonthAfterYear: false,

            // Render days of the calendar grid that fall in the next or previous month
            showDaysInNextAndPreviousMonths: false,

            // Allows user to select days that fall in the next or previous month
            enableSelectionDaysInNextAndPreviousMonths: false,

            // how many months are visible
            numberOfMonths: 1,

            // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
            // only used for the first display or when a selected date is not visible
            mainCalendar: 'left',

            // Specify a DOM element to render the calendar in
            container: undefined,

            // Blur field when date is selected
            blurFieldOnSelect : true,

            // internationalization
            i18n: {
                previousMonth : 'Previous Month',
                nextMonth     : 'Next Month',
                months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
                weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
            },

            // Theme Classname
            theme: null,

            // events array
            events: [],

            // callback function
            onSelect: null,
            onOpen: null,
            onClose: null,
            onDraw: null,

            // Enable keyboard input
            keyboardInput: true
        },


        /**
         * templating functions to abstract HTML rendering
         */
        renderDayName = function(opts, day, abbr)
        {
            day += opts.firstDay;
            while (day >= 7) {
                day -= 7;
            }
            return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
        },

        renderDay = function(opts)
        {
            var arr = [];
            var ariaSelected = 'false';
            if (opts.isEmpty) {
                if (opts.showDaysInNextAndPreviousMonths) {
                    arr.push('is-outside-current-month');

                    if(!opts.enableSelectionDaysInNextAndPreviousMonths) {
                        arr.push('is-selection-disabled');
                    }

                } else {
                    return '<td class="is-empty"></td>';
                }
            }
            if (opts.isDisabled) {
                arr.push('is-disabled');
            }
            if (opts.isToday) {
                arr.push('is-today');
            }
            if (opts.isSelected) {
                arr.push('is-selected');
                ariaSelected = 'true';
            }
            if (opts.hasEvent) {
                arr.push('has-event');
            }
            if (opts.isInRange) {
                arr.push('is-inrange');
            }
            if (opts.isStartRange) {
                arr.push('is-startrange');
            }
            if (opts.isEndRange) {
                arr.push('is-endrange');
            }
            return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                     '<button class="pika-button pika-day" type="button" ' +
                        'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                            opts.day +
                     '</button>' +
                   '</td>';
        },

        renderWeek = function (d, m, y) {
            // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
            var onejan = new Date(y, 0, 1),
                weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
            return '<td class="pika-week">' + weekNum + '</td>';
        },

        renderRow = function(days, isRTL, pickWholeWeek, isRowSelected)
        {
            return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
        },

        renderBody = function(rows)
        {
            return '<tbody>' + rows.join('') + '</tbody>';
        },

        renderHead = function(opts)
        {
            var i, arr = [];
            if (opts.showWeekNumber) {
                arr.push('<th></th>');
            }
            for (i = 0; i < 7; i++) {
                arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
            }
            return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
        },

        renderTitle = function(instance, c, year, month, refYear, randId)
        {
            var i, j, arr,
                opts = instance._o,
                isMinYear = year === opts.minYear,
                isMaxYear = year === opts.maxYear,
                html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
                monthHtml,
                yearHtml,
                prev = true,
                next = true;

            for (arr = [], i = 0; i < 12; i++) {
                arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                    (i === month ? ' selected="selected"': '') +
                    ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' +
                    opts.i18n.months[i] + '</option>');
            }

            monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

            if (isArray(opts.yearRange)) {
                i = opts.yearRange[0];
                j = opts.yearRange[1] + 1;
            } else {
                i = year - opts.yearRange;
                j = 1 + year + opts.yearRange;
            }

            for (arr = []; i < j && i <= opts.maxYear; i++) {
                if (i >= opts.minYear) {
                    arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"': '') + '>' + (i) + '</option>');
                }
            }
            yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

            if (opts.showMonthAfterYear) {
                html += yearHtml + monthHtml;
            } else {
                html += monthHtml + yearHtml;
            }

            if (isMinYear && (month === 0 || opts.minMonth >= month)) {
                prev = false;
            }

            if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
                next = false;
            }

            if (c === 0) {
                html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
            }
            if (c === (instance._o.numberOfMonths - 1) ) {
                html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
            }

            return html += '</div>';
        },

        renderTable = function(opts, data, randId)
        {
            return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
        },


        /**
         * Pikaday constructor
         */
        Pikaday = function(options)
        {
            var self = this,
                opts = self.config(options);

            self._onMouseDown = function(e)
            {
                if (!self._v) {
                    return;
                }
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }

                if (!hasClass(target, 'is-disabled')) {
                    if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                        self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                        if (opts.bound) {
                            sto(function() {
                                self.hide();
                                if (opts.blurFieldOnSelect && opts.field) {
                                    opts.field.blur();
                                }
                            }, 100);
                        }
                    }
                    else if (hasClass(target, 'pika-prev')) {
                        self.prevMonth();
                    }
                    else if (hasClass(target, 'pika-next')) {
                        self.nextMonth();
                    }
                }
                if (!hasClass(target, 'pika-select')) {
                    // if this is touch event prevent mouse events emulation
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                        return false;
                    }
                } else {
                    self._c = true;
                }
            };

            self._onChange = function(e)
            {
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }
                if (hasClass(target, 'pika-select-month')) {
                    self.gotoMonth(target.value);
                }
                else if (hasClass(target, 'pika-select-year')) {
                    self.gotoYear(target.value);
                }
            };

            self._onKeyChange = function(e)
            {
                e = e || window.event;

                if (self.isVisible()) {

                    switch(e.keyCode){
                        case 13:
                        case 27:
                            if (opts.field) {
                                opts.field.blur();
                            }
                            break;
                        case 37:
                            e.preventDefault();
                            self.adjustDate('subtract', 1);
                            break;
                        case 38:
                            self.adjustDate('subtract', 7);
                            break;
                        case 39:
                            self.adjustDate('add', 1);
                            break;
                        case 40:
                            self.adjustDate('add', 7);
                            break;
                    }
                }
            };

            self._onInputChange = function(e)
            {
                var date;

                if (e.firedBy === self) {
                    return;
                }
                if (opts.parse) {
                    date = opts.parse(opts.field.value, opts.format);
                } else if (hasMoment) {
                    date = moment(opts.field.value, opts.format, opts.formatStrict);
                    date = (date && date.isValid()) ? date.toDate() : null;
                }
                else {
                    date = new Date(Date.parse(opts.field.value));
                }
                if (isDate(date)) {
                  self.setDate(date);
                }
                if (!self._v) {
                    self.show();
                }
            };

            self._onInputFocus = function()
            {
                self.show();
            };

            self._onInputClick = function()
            {
                self.show();
            };

            self._onInputBlur = function()
            {
                // IE allows pika div to gain focus; catch blur the input field
                var pEl = document.activeElement;
                do {
                    if (hasClass(pEl, 'pika-single')) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));

                if (!self._c) {
                    self._b = sto(function() {
                        self.hide();
                    }, 50);
                }
                self._c = false;
            };

            self._onClick = function(e)
            {
                e = e || window.event;
                var target = e.target || e.srcElement,
                    pEl = target;
                if (!target) {
                    return;
                }
                if (!hasEventListeners && hasClass(target, 'pika-select')) {
                    if (!target.onchange) {
                        target.setAttribute('onchange', 'return;');
                        addEvent(target, 'change', self._onChange);
                    }
                }
                do {
                    if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));
                if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                    self.hide();
                }
            };

            self.el = document.createElement('div');
            self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

            addEvent(self.el, 'mousedown', self._onMouseDown, true);
            addEvent(self.el, 'touchend', self._onMouseDown, true);
            addEvent(self.el, 'change', self._onChange);

            if (opts.keyboardInput) {
                addEvent(document, 'keydown', self._onKeyChange);
            }

            if (opts.field) {
                if (opts.container) {
                    opts.container.appendChild(self.el);
                } else if (opts.bound) {
                    document.body.appendChild(self.el);
                } else {
                    opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
                }
                addEvent(opts.field, 'change', self._onInputChange);

                if (!opts.defaultDate) {
                    if (hasMoment && opts.field.value) {
                        opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                    } else {
                        opts.defaultDate = new Date(Date.parse(opts.field.value));
                    }
                    opts.setDefaultDate = true;
                }
            }

            var defDate = opts.defaultDate;

            if (isDate(defDate)) {
                if (opts.setDefaultDate) {
                    self.setDate(defDate, true);
                } else {
                    self.gotoDate(defDate);
                }
            } else {
                self.gotoDate(new Date());
            }

            if (opts.bound) {
                this.hide();
                self.el.className += ' is-bound';
                addEvent(opts.trigger, 'click', self._onInputClick);
                addEvent(opts.trigger, 'focus', self._onInputFocus);
                addEvent(opts.trigger, 'blur', self._onInputBlur);
            } else {
                this.show();
            }
        };


        /**
         * public Pikaday API
         */
        Pikaday.prototype = {


            /**
             * configure functionality
             */
            config: function(options)
            {
                if (!this._o) {
                    this._o = extend({}, defaults, true);
                }

                var opts = extend(this._o, options, true);

                opts.isRTL = !!opts.isRTL;

                opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

                opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

                opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

                opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

                opts.disableWeekends = !!opts.disableWeekends;

                opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

                var nom = parseInt(opts.numberOfMonths, 10) || 1;
                opts.numberOfMonths = nom > 4 ? 4 : nom;

                if (!isDate(opts.minDate)) {
                    opts.minDate = false;
                }
                if (!isDate(opts.maxDate)) {
                    opts.maxDate = false;
                }
                if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                    opts.maxDate = opts.minDate = false;
                }
                if (opts.minDate) {
                    this.setMinDate(opts.minDate);
                }
                if (opts.maxDate) {
                    this.setMaxDate(opts.maxDate);
                }

                if (isArray(opts.yearRange)) {
                    var fallback = new Date().getFullYear() - 10;
                    opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                    opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
                } else {
                    opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                    if (opts.yearRange > 100) {
                        opts.yearRange = 100;
                    }
                }

                return opts;
            },

            /**
             * return a formatted string of the current selection (using Moment.js if available)
             */
            toString: function(format)
            {
                format = format || this._o.format;
                if (!isDate(this._d)) {
                    return '';
                }
                if (this._o.toString) {
                  return this._o.toString(this._d, format);
                }
                if (hasMoment) {
                  return moment(this._d).format(format);
                }
                return this._d.toDateString();
            },

            /**
             * return a Moment.js object of the current selection (if available)
             */
            getMoment: function()
            {
                return hasMoment ? moment(this._d) : null;
            },

            /**
             * set the current selection from a Moment.js object (if available)
             */
            setMoment: function(date, preventOnSelect)
            {
                if (hasMoment && moment.isMoment(date)) {
                    this.setDate(date.toDate(), preventOnSelect);
                }
            },

            /**
             * return a Date object of the current selection
             */
            getDate: function()
            {
                return isDate(this._d) ? new Date(this._d.getTime()) : null;
            },

            /**
             * set the current selection
             */
            setDate: function(date, preventOnSelect)
            {
                if (!date) {
                    this._d = null;

                    if (this._o.field) {
                        this._o.field.value = '';
                        fireEvent(this._o.field, 'change', { firedBy: this });
                    }

                    return this.draw();
                }
                if (typeof date === 'string') {
                    date = new Date(Date.parse(date));
                }
                if (!isDate(date)) {
                    return;
                }

                var min = this._o.minDate,
                    max = this._o.maxDate;

                if (isDate(min) && date < min) {
                    date = min;
                } else if (isDate(max) && date > max) {
                    date = max;
                }

                this._d = new Date(date.getTime());
                setToStartOfDay(this._d);
                this.gotoDate(this._d);

                if (this._o.field) {
                    this._o.field.value = this.toString();
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }
                if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                    this._o.onSelect.call(this, this.getDate());
                }
            },

            /**
             * change view to a specific date
             */
            gotoDate: function(date)
            {
                var newCalendar = true;

                if (!isDate(date)) {
                    return;
                }

                if (this.calendars) {
                    var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                        lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                        visibleDate = date.getTime();
                    // get the end of the month
                    lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                    lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                    newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
                }

                if (newCalendar) {
                    this.calendars = [{
                        month: date.getMonth(),
                        year: date.getFullYear()
                    }];
                    if (this._o.mainCalendar === 'right') {
                        this.calendars[0].month += 1 - this._o.numberOfMonths;
                    }
                }

                this.adjustCalendars();
            },

            adjustDate: function(sign, days) {

                var day = this.getDate() || new Date();
                var difference = parseInt(days)*24*60*60*1000;

                var newDay;

                if (sign === 'add') {
                    newDay = new Date(day.valueOf() + difference);
                } else if (sign === 'subtract') {
                    newDay = new Date(day.valueOf() - difference);
                }

                this.setDate(newDay);
            },

            adjustCalendars: function() {
                this.calendars[0] = adjustCalendar(this.calendars[0]);
                for (var c = 1; c < this._o.numberOfMonths; c++) {
                    this.calendars[c] = adjustCalendar({
                        month: this.calendars[0].month + c,
                        year: this.calendars[0].year
                    });
                }
                this.draw();
            },

            gotoToday: function()
            {
                this.gotoDate(new Date());
            },

            /**
             * change view to a specific month (zero-index, e.g. 0: January)
             */
            gotoMonth: function(month)
            {
                if (!isNaN(month)) {
                    this.calendars[0].month = parseInt(month, 10);
                    this.adjustCalendars();
                }
            },

            nextMonth: function()
            {
                this.calendars[0].month++;
                this.adjustCalendars();
            },

            prevMonth: function()
            {
                this.calendars[0].month--;
                this.adjustCalendars();
            },

            /**
             * change view to a specific full year (e.g. "2012")
             */
            gotoYear: function(year)
            {
                if (!isNaN(year)) {
                    this.calendars[0].year = parseInt(year, 10);
                    this.adjustCalendars();
                }
            },

            /**
             * change the minDate
             */
            setMinDate: function(value)
            {
                if(value instanceof Date) {
                    setToStartOfDay(value);
                    this._o.minDate = value;
                    this._o.minYear  = value.getFullYear();
                    this._o.minMonth = value.getMonth();
                } else {
                    this._o.minDate = defaults.minDate;
                    this._o.minYear  = defaults.minYear;
                    this._o.minMonth = defaults.minMonth;
                    this._o.startRange = defaults.startRange;
                }

                this.draw();
            },

            /**
             * change the maxDate
             */
            setMaxDate: function(value)
            {
                if(value instanceof Date) {
                    setToStartOfDay(value);
                    this._o.maxDate = value;
                    this._o.maxYear = value.getFullYear();
                    this._o.maxMonth = value.getMonth();
                } else {
                    this._o.maxDate = defaults.maxDate;
                    this._o.maxYear = defaults.maxYear;
                    this._o.maxMonth = defaults.maxMonth;
                    this._o.endRange = defaults.endRange;
                }

                this.draw();
            },

            setStartRange: function(value)
            {
                this._o.startRange = value;
            },

            setEndRange: function(value)
            {
                this._o.endRange = value;
            },

            /**
             * refresh the HTML
             */
            draw: function(force)
            {
                if (!this._v && !force) {
                    return;
                }
                var opts = this._o,
                    minYear = opts.minYear,
                    maxYear = opts.maxYear,
                    minMonth = opts.minMonth,
                    maxMonth = opts.maxMonth,
                    html = '',
                    randId;

                if (this._y <= minYear) {
                    this._y = minYear;
                    if (!isNaN(minMonth) && this._m < minMonth) {
                        this._m = minMonth;
                    }
                }
                if (this._y >= maxYear) {
                    this._y = maxYear;
                    if (!isNaN(maxMonth) && this._m > maxMonth) {
                        this._m = maxMonth;
                    }
                }

                randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

                for (var c = 0; c < opts.numberOfMonths; c++) {
                    html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
                }

                this.el.innerHTML = html;

                if (opts.bound) {
                    if(opts.field.type !== 'hidden') {
                        sto(function() {
                            opts.trigger.focus();
                        }, 1);
                    }
                }

                if (typeof this._o.onDraw === 'function') {
                    this._o.onDraw(this);
                }

                if (opts.bound) {
                    // let the screen reader user know to use arrow keys
                    opts.field.setAttribute('aria-label', 'Use the arrow keys to pick a date');
                }
            },

            adjustPosition: function()
            {
                var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

                if (this._o.container) return;

                this.el.style.position = 'absolute';

                field = this._o.trigger;
                pEl = field;
                width = this.el.offsetWidth;
                height = this.el.offsetHeight;
                viewportWidth = window.innerWidth || document.documentElement.clientWidth;
                viewportHeight = window.innerHeight || document.documentElement.clientHeight;
                scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

                if (typeof field.getBoundingClientRect === 'function') {
                    clientRect = field.getBoundingClientRect();
                    left = clientRect.left + window.pageXOffset;
                    top = clientRect.bottom + window.pageYOffset;
                } else {
                    left = pEl.offsetLeft;
                    top  = pEl.offsetTop + pEl.offsetHeight;
                    while((pEl = pEl.offsetParent)) {
                        left += pEl.offsetLeft;
                        top  += pEl.offsetTop;
                    }
                }

                // default position is bottom & left
                if ((this._o.reposition && left + width > viewportWidth) ||
                    (
                        this._o.position.indexOf('right') > -1 &&
                        left - width + field.offsetWidth > 0
                    )
                ) {
                    left = left - width + field.offsetWidth;
                }
                if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                    (
                        this._o.position.indexOf('top') > -1 &&
                        top - height - field.offsetHeight > 0
                    )
                ) {
                    top = top - height - field.offsetHeight;
                }

                this.el.style.left = left + 'px';
                this.el.style.top = top + 'px';
            },

            /**
             * render HTML for a particular month
             */
            render: function(year, month, randId)
            {
                var opts   = this._o,
                    now    = new Date(),
                    days   = getDaysInMonth(year, month),
                    before = new Date(year, month, 1).getDay(),
                    data   = [],
                    row    = [];
                setToStartOfDay(now);
                if (opts.firstDay > 0) {
                    before -= opts.firstDay;
                    if (before < 0) {
                        before += 7;
                    }
                }
                var previousMonth = month === 0 ? 11 : month - 1,
                    nextMonth = month === 11 ? 0 : month + 1,
                    yearOfPreviousMonth = month === 0 ? year - 1 : year,
                    yearOfNextMonth = month === 11 ? year + 1 : year,
                    daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
                var cells = days + before,
                    after = cells;
                while(after > 7) {
                    after -= 7;
                }
                cells += 7 - after;
                var isWeekSelected = false;
                for (var i = 0, r = 0; i < cells; i++)
                {
                    var day = new Date(year, month, 1 + (i - before)),
                        isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                        isToday = compareDates(day, now),
                        hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                        isEmpty = i < before || i >= (days + before),
                        dayNumber = 1 + (i - before),
                        monthNumber = month,
                        yearNumber = year,
                        isStartRange = opts.startRange && compareDates(opts.startRange, day),
                        isEndRange = opts.endRange && compareDates(opts.endRange, day),
                        isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                        isDisabled = (opts.minDate && day < opts.minDate) ||
                                     (opts.maxDate && day > opts.maxDate) ||
                                     (opts.disableWeekends && isWeekend(day)) ||
                                     (opts.disableDayFn && opts.disableDayFn(day));

                    if (isEmpty) {
                        if (i < before) {
                            dayNumber = daysInPreviousMonth + dayNumber;
                            monthNumber = previousMonth;
                            yearNumber = yearOfPreviousMonth;
                        } else {
                            dayNumber = dayNumber - days;
                            monthNumber = nextMonth;
                            yearNumber = yearOfNextMonth;
                        }
                    }

                    var dayConfig = {
                            day: dayNumber,
                            month: monthNumber,
                            year: yearNumber,
                            hasEvent: hasEvent,
                            isSelected: isSelected,
                            isToday: isToday,
                            isDisabled: isDisabled,
                            isEmpty: isEmpty,
                            isStartRange: isStartRange,
                            isEndRange: isEndRange,
                            isInRange: isInRange,
                            showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                            enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                        };

                    if (opts.pickWholeWeek && isSelected) {
                        isWeekSelected = true;
                    }

                    row.push(renderDay(dayConfig));

                    if (++r === 7) {
                        if (opts.showWeekNumber) {
                            row.unshift(renderWeek(i - before, month, year));
                        }
                        data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                        row = [];
                        r = 0;
                        isWeekSelected = false;
                    }
                }
                return renderTable(opts, data, randId);
            },

            isVisible: function()
            {
                return this._v;
            },

            show: function()
            {
                if (!this.isVisible()) {
                    this._v = true;
                    this.draw();
                    removeClass(this.el, 'is-hidden');
                    if (this._o.bound) {
                        addEvent(document, 'click', this._onClick);
                        this.adjustPosition();
                    }
                    if (typeof this._o.onOpen === 'function') {
                        this._o.onOpen.call(this);
                    }
                }
            },

            hide: function()
            {
                var v = this._v;
                if (v !== false) {
                    if (this._o.bound) {
                        removeEvent(document, 'click', this._onClick);
                    }
                    this.el.style.position = 'static'; // reset
                    this.el.style.left = 'auto';
                    this.el.style.top = 'auto';
                    addClass(this.el, 'is-hidden');
                    this._v = false;
                    if (v !== undefined && typeof this._o.onClose === 'function') {
                        this._o.onClose.call(this);
                    }
                }
            },

            /**
             * GAME OVER
             */
            destroy: function()
            {
                var opts = this._o;

                this.hide();
                removeEvent(this.el, 'mousedown', this._onMouseDown, true);
                removeEvent(this.el, 'touchend', this._onMouseDown, true);
                removeEvent(this.el, 'change', this._onChange);
                if (opts.keyboardInput) {
                    removeEvent(document, 'keydown', this._onKeyChange);
                }
                if (opts.field) {
                    removeEvent(opts.field, 'change', this._onInputChange);
                    if (opts.bound) {
                        removeEvent(opts.trigger, 'click', this._onInputClick);
                        removeEvent(opts.trigger, 'focus', this._onInputFocus);
                        removeEvent(opts.trigger, 'blur', this._onInputBlur);
                    }
                }
                if (this.el.parentNode) {
                    this.el.parentNode.removeChild(this.el);
                }
            }

        };

        return Pikaday;
    }));
    });

    /* src\core\ui\inputs\Date.html generated by Svelte v2.9.5 */

    function oncreate$6() {
    	const field = this.get().field;

    	// eslint-disable-next-line no-new
    	new pikaday({
    		field: this.refs.container,
    		format: "YYYY-MM-DD",
    		async onSelect(date) {
    			await field.init(date.toISOString());
    		}
    	});

    	const formElement = this.refs.container;
    	formElement.addEventListener("change", () => {
    		if (formElement.value === "") {
    			field.init(null);
    		}
    	});
    }
    const file$a = "src\\core\\ui\\inputs\\Date.html";

    function create_main_fragment$a(component, ctx) {
    	var input, input_updating = false, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.valueAsText = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "text");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.autocomplete = "off";
    			input.className = "form-control";
    			addLoc(input, file$a, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);
    			component.refs.container = input;

    			input.value = ctx.field.valueAsText;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating) input.value = ctx.field.valueAsText;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    			if (component.refs.container === input) component.refs.container = null;
    		}
    	};
    }

    function SvelteComponent$a(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$a(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$6.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$a.prototype, protoDev);

    SvelteComponent$a.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\DateRange.html generated by Svelte v2.9.5 */

    function oncreate$7() {
    	const field = this.get().field;

    	// eslint-disable-next-line no-new
    	new pikaday({
    		field: this.refs.minContainer,
    		format: "YYYY-MM-DD",
    		onSelect(date) {
    			field.value.min = date;
    		}
    	});

    	// eslint-disable-next-line no-new
    	new pikaday({
    		field: this.refs.maxContainer,
    		format: "YYYY-MM-DD",
    		onSelect(date) {
    			field.value.max = date;
    		}
    	});

    	const minElement = this.refs.minContainer;
    	minElement.addEventListener("change", () => {
    		if (minElement.value === "") {
    			field.value.min = null;
    		}
    	});

    	const maxElement = this.refs.maxContainer;
    	maxElement.addEventListener("change", () => {
    		if (maxElement.value === "") {
    			field.value.max = null;
    		}
    	});
    }
    const file$b = "src\\core\\ui\\inputs\\DateRange.html";

    function add_css$6() {
    	var style = createElement("style");
    	style.id = 'svelte-6lg6r4-style';
    	style.textContent = ".input-group-addon.svelte-6lg6r4{font-size:0.8rem !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZVJhbmdlLmh0bWwiLCJzb3VyY2VzIjpbIkRhdGVSYW5nZS5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbIjxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPlxyXG5cdDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5NaW48L3NwYW4+XHJcblx0PGlucHV0IHR5cGU9XCJ0ZXh0XCJcclxuXHRcdGJpbmQ6dmFsdWU9XCJmaWVsZC5taW5WYWx1ZUFzVGV4dFwiXHJcblx0XHRyZXF1aXJlZD1cIntmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cIlxyXG5cdFx0dGFiaW5kZXg9XCJ7dGFiaW5kZXh9XCJcclxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXHJcblx0XHRjbGFzcz1cImZvcm0tY29udHJvbFwiXHJcblx0XHRyZWY6bWluQ29udGFpbmVyPlxyXG5cclxuICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5NYXg8L3NwYW4+XHJcblx0PGlucHV0IHR5cGU9XCJ0ZXh0XCJcclxuXHRcdGJpbmQ6dmFsdWU9XCJmaWVsZC5tYXhWYWx1ZUFzVGV4dFwiXHJcblx0XHRyZXF1aXJlZD1cIntmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cIlxyXG5cdFx0dGFiaW5kZXg9XCJ7dGFiaW5kZXh9XCJcclxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXHJcblx0XHRjbGFzcz1cImZvcm0tY29udHJvbFwiXHJcblx0XHRyZWY6bWF4Q29udGFpbmVyPlxyXG48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IFBpa2FkYXkgZnJvbSBcInBpa2FkYXlcIjtcclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcclxuXHRcdFx0bmV3IFBpa2FkYXkoe1xyXG5cdFx0XHRcdGZpZWxkOiB0aGlzLnJlZnMubWluQ29udGFpbmVyLFxyXG5cdFx0XHRcdGZvcm1hdDogXCJZWVlZLU1NLUREXCIsXHJcblx0XHRcdFx0b25TZWxlY3QoZGF0ZSkge1xyXG5cdFx0XHRcdFx0ZmllbGQudmFsdWUubWluID0gZGF0ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xyXG5cdFx0XHRuZXcgUGlrYWRheSh7XHJcblx0XHRcdFx0ZmllbGQ6IHRoaXMucmVmcy5tYXhDb250YWluZXIsXHJcblx0XHRcdFx0Zm9ybWF0OiBcIllZWVktTU0tRERcIixcclxuXHRcdFx0XHRvblNlbGVjdChkYXRlKSB7XHJcblx0XHRcdFx0XHRmaWVsZC52YWx1ZS5tYXggPSBkYXRlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCBtaW5FbGVtZW50ID0gdGhpcy5yZWZzLm1pbkNvbnRhaW5lcjtcclxuXHRcdFx0bWluRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICgpID0+IHtcclxuXHRcdFx0XHRpZiAobWluRWxlbWVudC52YWx1ZSA9PT0gXCJcIikge1xyXG5cdFx0XHRcdFx0ZmllbGQudmFsdWUubWluID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgbWF4RWxlbWVudCA9IHRoaXMucmVmcy5tYXhDb250YWluZXI7XHJcblx0XHRcdG1heEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XHJcblx0XHRcdFx0aWYgKG1heEVsZW1lbnQudmFsdWUgPT09IFwiXCIpIHtcclxuXHRcdFx0XHRcdGZpZWxkLnZhbHVlLm1heCA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHRcdC5pbnB1dC1ncm91cC1hZGRvbiB7XHJcblx0XHRcdGZvbnQtc2l6ZTogMC44cmVtICFpbXBvcnRhbnQ7XHJcblx0XHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUErREUsa0JBQWtCLGNBQUMsQ0FBQyxBQUNuQixTQUFTLENBQUUsTUFBTSxDQUFDLFVBQVUsQUFDN0IsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$b(component, ctx) {
    	var div, span, text, text_1, input, input_updating = false, input_required_value, text_2, span_1, text_3, text_4, input_1, input_1_updating = false, input_1_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.minValueAsText = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	function input_1_input_handler() {
    		input_1_updating = true;
    		ctx.field.maxValueAsText = input_1.value;
    		component.set({ field: ctx.field });
    		input_1_updating = false;
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span = createElement("span");
    			text = createText("Min");
    			text_1 = createText("\r\n\t");
    			input = createElement("input");
    			text_2 = createText("\r\n\r\n    ");
    			span_1 = createElement("span");
    			text_3 = createText("Max");
    			text_4 = createText("\r\n\t");
    			input_1 = createElement("input");
    			span.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span, file$b, 1, 1, 28);
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "text");
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.autocomplete = "off";
    			input.className = "form-control";
    			addLoc(input, file$b, 2, 1, 73);
    			span_1.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span_1, file$b, 10, 4, 268);
    			addListener(input_1, "input", input_1_input_handler);
    			setAttribute(input_1, "type", "text");
    			input_1.required = input_1_required_value = ctx.field.metadata.required;
    			input_1.tabIndex = ctx.tabindex;
    			input_1.autocomplete = "off";
    			input_1.className = "form-control";
    			addLoc(input_1, file$b, 11, 1, 313);
    			div.className = "input-group";
    			addLoc(div, file$b, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(span, div);
    			appendNode(text, span);
    			appendNode(text_1, div);
    			appendNode(input, div);
    			component.refs.minContainer = input;

    			input.value = ctx.field.minValueAsText;

    			appendNode(text_2, div);
    			appendNode(span_1, div);
    			appendNode(text_3, span_1);
    			appendNode(text_4, div);
    			appendNode(input_1, div);
    			component.refs.maxContainer = input_1;

    			input_1.value = ctx.field.maxValueAsText;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating) input.value = ctx.field.minValueAsText;
    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if (!input_1_updating) input_1.value = ctx.field.maxValueAsText;
    			if ((changed.field) && input_1_required_value !== (input_1_required_value = ctx.field.metadata.required)) {
    				input_1.required = input_1_required_value;
    			}

    			if (changed.tabindex) {
    				input_1.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(input, "input", input_input_handler);
    			if (component.refs.minContainer === input) component.refs.minContainer = null;
    			removeListener(input_1, "input", input_1_input_handler);
    			if (component.refs.maxContainer === input_1) component.refs.maxContainer = null;
    		}
    	};
    }

    function SvelteComponent$b(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-6lg6r4-style")) add_css$6();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$b(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$7.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$b.prototype, protoDev);

    SvelteComponent$b.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Dropdown.html generated by Svelte v2.9.5 */

    function mapToTypeaheadItems(items) {
    	return items.map(t => ({
    		label: t.label,
    		value: t.value.toString()
    	}));
    }

    function buildFilter(parentForm, parameters) {
    	let promise;

    	const filter = {};
    	if (parameters != null && parameters.length > 0) {
    		promise = parentForm.get().form.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}

    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}

    	return promise;
    }

    var methods$3 = {
    	onChange() {
    		this.get().field.initFromSelected();
    		this.get().form.fireAndBubbleUp("input:changed", {
    			app: this.get().app,
    			form: this.get().form,
    			input: this
    		});
    	}
    };

    function oncreate$8() {
    	const field = this.get().field;
    	const { source, items } = field.metadata.customProperties;

    	if (items != null) {
    		this.set({ options: items });
    	}
    	else if (typeof (source) === "string") {
    		const { parameters } = field.metadata.customProperties;
    		const app = this.get().app;
    		const parentForm = this.get().form;

    		buildFilter(parentForm, parameters).then(filter => {
    			app.server.postForm(source, filter).then(data => {
    				this.set({ options: mapToTypeaheadItems(data.items) });
    			});
    		});
    	}
    }
    const file$c = "src\\core\\ui\\inputs\\Dropdown.html";

    function create_main_fragment$c(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.options != null) && create_if_block$a(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.options != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$a(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (10:1) {#each options as option}
    function create_each_block$4(component, ctx) {
    	var option, text_value = ctx.option.label, text, option_value_value;

    	return {
    		c: function create() {
    			option = createElement("option");
    			text = createText(text_value);
    			option.__value = option_value_value = ctx.option.value;
    			option.value = option.__value;
    			addLoc(option, file$c, 10, 1, 245);
    		},

    		m: function mount(target, anchor) {
    			insertNode(option, target, anchor);
    			appendNode(text, option);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.options) && text_value !== (text_value = ctx.option.label)) {
    				text.data = text_value;
    			}

    			if ((changed.options) && option_value_value !== (option_value_value = ctx.option.value)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(option);
    			}
    		}
    	};
    }

    // (1:0) {#if options != null }
    function create_if_block$a(component, ctx) {
    	var select, option, select_updating = false, select_required_value;

    	var each_value = ctx.options;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(component, get_each_context$4(ctx, each_value, i));
    	}

    	function select_change_handler() {
    		select_updating = true;
    		ctx.field.selected = selectValue(select);
    		component.set({ field: ctx.field, options: ctx.options });
    		select_updating = false;
    	}

    	function change_handler(event) {
    		component.onChange();
    	}

    	return {
    		c: function create() {
    			select = createElement("select");
    			option = createElement("option");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			option.__value = "";
    			option.value = option.__value;
    			addLoc(option, file$c, 8, 1, 188);
    			addListener(select, "change", select_change_handler);
    			if (!('field' in ctx)) component.root._beforecreate.push(select_change_handler);
    			addListener(select, "change", change_handler);
    			select.id = ctx.id;
    			select.required = select_required_value = ctx.field.metadata.required;
    			select.tabIndex = ctx.tabindex;
    			select.className = "form-control";
    			addLoc(select, file$c, 1, 0, 24);
    		},

    		m: function mount(target, anchor) {
    			insertNode(select, target, anchor);
    			appendNode(option, select);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			selectOption(select, ctx.field.selected);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (changed.options) {
    				each_value = ctx.options;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$4(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (!select_updating) selectOption(select, ctx.field.selected);
    			if (changed.id) {
    				select.id = ctx.id;
    			}

    			if ((changed.field) && select_required_value !== (select_required_value = ctx.field.metadata.required)) {
    				select.required = select_required_value;
    			}

    			if (changed.tabindex) {
    				select.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(select);
    			}

    			destroyEach(each_blocks, detach);

    			removeListener(select, "change", select_change_handler);
    			removeListener(select, "change", change_handler);
    		}
    	};
    }

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.option = list[i];
    	child_ctx.each_value = list;
    	child_ctx.option_index = i;
    	return child_ctx;
    }

    function SvelteComponent$c(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('options' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'options'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    	}

    	this._fragment = create_main_fragment$c(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$8.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$c.prototype, protoDev);
    assign(SvelteComponent$c.prototype, methods$3);

    SvelteComponent$c.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Email.html generated by Svelte v2.9.5 */

    function oncreate$9() {
    	const field = this.get().field;
    	const formElement = this.refs.container;
    	formElement.addEventListener("change", () => {
    		field.init(field.selected);
    	});
    }
    const file$d = "src\\core\\ui\\inputs\\Email.html";

    function create_main_fragment$d(component, ctx) {
    	var input, input_updating = false, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.selected = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "Email");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$d, 1, 0, 2);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);
    			component.refs.container = input;

    			input.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating) input.value = ctx.field.selected;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    			if (component.refs.container === input) component.refs.container = null;
    		}
    	};
    }

    function SvelteComponent$d(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$d(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$9.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$d.prototype, protoDev);

    SvelteComponent$d.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\FileUploader.html generated by Svelte v2.9.5 */

    function objectToArray(obj) {
    	if (obj) {
    		return Array.from(Object.keys(obj), k => obj[k]);
    	}

    	return [];
    }

    function getExtension(filename) {
    	return `.${filename.split(".").pop()}`;
    }

    function canFileBeAdded(filelist, file, allowedFileExtensions, app) {
    	const isFileExtensionAllowed =
    		allowedFileExtensions.indexOf("*") > -1 ||
    		allowedFileExtensions.indexOf(getExtension(file.name)) > -1;

    	const fileWasAlreadyAdded = filelist.find(f => f.name === file.name);

    	if (isFileExtensionAllowed && !fileWasAlreadyAdded) {
    		return true;
    	}

    	if (!isFileExtensionAllowed) {
    		app.showError(`File ${file.name} extension not allowed. Only ` +
    			`these file extensions are allowed: ${allowedFileExtensions}.`);
    	}

    	return false;
    }

    function getAllowedFileExtensions(component) {
    	let	allowedExtension = "*";
    	if (component.get().uploaderConfig && component.get().uploaderConfig.allowedFileExtensions) {
    		allowedExtension = component.get().uploaderConfig.allowedFileExtensions.split(",").map(item => item.trim());
    	}

    	return allowedExtension;
    }

    function addFiles(component, files) {
    	const app = component.get().app;
    	const filesToAdd = objectToArray(files);
    	let listedFiles = [];

    	if (component.get().selectedFiles) {
    		listedFiles = component.get().selectedFiles;
    	}

    	const allowedFileExtensions = getAllowedFileExtensions(component);
    	const filesThatCanBeAdded = filesToAdd
    		.filter(file => canFileBeAdded(listedFiles, file, allowedFileExtensions, app));

    	if (filesThatCanBeAdded.length > 0) {
    		if (!component.get().uploaderConfig.allowMultipleFiles) {
    			component.set({ selectedFiles: filesThatCanBeAdded.slice(0, 1) });
    		}
    		else {
    			component.set({ selectedFiles: filesThatCanBeAdded.concat(listedFiles) });
    		}
    	}
    }

    var methods$4 = {
    	addFiles(files) {
    		addFiles(this, files);
    		this.get().field.selected = this.get().selectedFiles;
    	},
    	removeFile(index) {
    		this.get().selectedFiles.splice(index, 1).splice(index, 1);
    		this.set({
    			selectedFiles: this.get().selectedFiles
    		});

    		this.get().field.selected = this.get().selectedFiles;
    	}
    };

    function oncreate$a() {
    	const field = this.get().field;

    	const uploaderConfig =
    		field.metadata.getCustomProperty("fileUploaderConfig") ||
    		{
    			allowMultipleFiles: true,
    			allowedFileExtensions: "*"
    		};

    	this.set({ uploaderConfig });

    	this.refs.dropzone.addEventListener("dragenter", () => {
    		this.refs.dropzone.classList.add("hover");
    	});

    	const self = this;
    	["dragleave", "drop"].forEach(t => {
    		self.refs.dropzone.addEventListener(t, () => {
    			self.refs.dropzone.classList.remove("hover");
    		});
    	});

    	this.refs.dropzone.ondragover = e => {
    		e.preventDefault();
    	};

    	this.refs.dropzone.ondrop = e => {
    		e.preventDefault();
    		self.addFiles(e.dataTransfer.files);
    		return false;
    	};
    }
    const file$e = "src\\core\\ui\\inputs\\FileUploader.html";

    function add_css$7() {
    	var style = createElement("style");
    	style.id = 'svelte-6mad9x-style';
    	style.textContent = ".file-drop-area.svelte-6mad9x{text-align:center;border:dashed 2px #9c9c9c;min-height:60px;z-index:99999}.file-drop-area.svelte-6mad9x label.svelte-6mad9x{margin:auto;line-height:60px;display:block}.files-list.svelte-6mad9x i.svelte-6mad9x{margin-left:10px}.second-color.svelte-6mad9x{color:#f3818c}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsZVVwbG9hZGVyLmh0bWwiLCJzb3VyY2VzIjpbIkZpbGVVcGxvYWRlci5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbInsjaWYgc2VsZWN0ZWRGaWxlcyAhPSBudWxsICYmIHNlbGVjdGVkRmlsZXMubGVuZ3RoID4gMH1cclxuPHVsIGNsYXNzPVwiZmlsZXMtbGlzdFwiPlxyXG5cdHsjZWFjaCBzZWxlY3RlZEZpbGVzIGFzIGZpbGUsIGluZGV4fVxyXG5cdDxsaT57ZmlsZS5uYW1lfVxyXG5cdFx0PGkgY2xhc3M9XCJmYSBmYS10aW1lcyBzZWNvbmQtY29sb3JcIiBvbjpjbGljaz1cInJlbW92ZUZpbGUoaW5kZXgpXCI+PC9pPlxyXG5cdDwvbGk+XHJcblx0ey9lYWNofVxyXG48L3VsPlxyXG57L2lmfVxyXG5cclxuPGRpdiBjbGFzcz1cImZpbGUtZHJvcC1hcmVhXCJcdHJlZjpkcm9wem9uZT5cclxuXHR7I2lmIHVwbG9hZGVyQ29uZmlnICE9IG51bGwgJiYgdXBsb2FkZXJDb25maWcuYWxsb3dNdWx0aXBsZUZpbGVzfVxyXG5cdDxpbnB1dCB0eXBlPVwiZmlsZVwiXHJcblx0XHRpZD1cIntpZH1cIlxyXG5cdFx0dGFiaW5kZXg9XCJ7dGFiaW5kZXh9XCJcclxuXHRcdG9uOmNoYW5nZT1cImFkZEZpbGVzKHRoaXMuZmlsZXMpXCJcclxuXHRcdG11bHRpcGxlPVwibXVsdGlwbGVcIlxyXG5cdFx0YWNjZXB0PVwie3VwbG9hZGVyQ29uZmlnID8gdXBsb2FkZXJDb25maWcuYWxsb3dlZEZpbGVFeHRlbnNpb25zIDogJyonfVwiLz5cclxuXHR7OmVsc2V9XHJcblx0PGlucHV0IHR5cGU9XCJmaWxlXCJcclxuXHRcdGlkPVwie2lkfVwiXHJcblx0XHR0YWJpbmRleD1cInt0YWJpbmRleH1cIlxyXG5cdFx0b246Y2hhbmdlPVwiYWRkRmlsZXModGhpcy5maWxlcylcIlxyXG5cdFx0YWNjZXB0PVwie3VwbG9hZGVyQ29uZmlnID8gdXBsb2FkZXJDb25maWcuYWxsb3dlZEZpbGVFeHRlbnNpb25zIDogJyonfVwiLz5cclxuXHR7L2lmfVxyXG5cdDxsYWJlbCBmb3I9XCJ7aWR9XCI+ZHJhZyBvciA8c3Ryb25nIGNsYXNzPSdzZWNvbmQtY29sb3InPnVwbG9hZDwvc3Ryb25nPiBmaWxlczwvbGFiZWw+XHJcbjwvZGl2PlxyXG5cclxuPHNjcmlwdD5cclxuXHRmdW5jdGlvbiBvYmplY3RUb0FycmF5KG9iaikge1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHRyZXR1cm4gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvYmopLCBrID0+IG9ialtrXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKGZpbGVuYW1lKSB7XHJcblx0XHRyZXR1cm4gYC4ke2ZpbGVuYW1lLnNwbGl0KFwiLlwiKS5wb3AoKX1gO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY2FuRmlsZUJlQWRkZWQoZmlsZWxpc3QsIGZpbGUsIGFsbG93ZWRGaWxlRXh0ZW5zaW9ucywgYXBwKSB7XHJcblx0XHRjb25zdCBpc0ZpbGVFeHRlbnNpb25BbGxvd2VkID1cclxuXHRcdFx0YWxsb3dlZEZpbGVFeHRlbnNpb25zLmluZGV4T2YoXCIqXCIpID4gLTEgfHxcclxuXHRcdFx0YWxsb3dlZEZpbGVFeHRlbnNpb25zLmluZGV4T2YoZ2V0RXh0ZW5zaW9uKGZpbGUubmFtZSkpID4gLTE7XHJcblxyXG5cdFx0Y29uc3QgZmlsZVdhc0FscmVhZHlBZGRlZCA9IGZpbGVsaXN0LmZpbmQoZiA9PiBmLm5hbWUgPT09IGZpbGUubmFtZSk7XHJcblxyXG5cdFx0aWYgKGlzRmlsZUV4dGVuc2lvbkFsbG93ZWQgJiYgIWZpbGVXYXNBbHJlYWR5QWRkZWQpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc0ZpbGVFeHRlbnNpb25BbGxvd2VkKSB7XHJcblx0XHRcdGFwcC5zaG93RXJyb3IoYEZpbGUgJHtmaWxlLm5hbWV9IGV4dGVuc2lvbiBub3QgYWxsb3dlZC4gT25seSBgICtcclxuXHRcdFx0XHRgdGhlc2UgZmlsZSBleHRlbnNpb25zIGFyZSBhbGxvd2VkOiAke2FsbG93ZWRGaWxlRXh0ZW5zaW9uc30uYCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0QWxsb3dlZEZpbGVFeHRlbnNpb25zKGNvbXBvbmVudCkge1xyXG5cdFx0bGV0XHRhbGxvd2VkRXh0ZW5zaW9uID0gXCIqXCI7XHJcblx0XHRpZiAoY29tcG9uZW50LmdldCgpLnVwbG9hZGVyQ29uZmlnICYmIGNvbXBvbmVudC5nZXQoKS51cGxvYWRlckNvbmZpZy5hbGxvd2VkRmlsZUV4dGVuc2lvbnMpIHtcclxuXHRcdFx0YWxsb3dlZEV4dGVuc2lvbiA9IGNvbXBvbmVudC5nZXQoKS51cGxvYWRlckNvbmZpZy5hbGxvd2VkRmlsZUV4dGVuc2lvbnMuc3BsaXQoXCIsXCIpLm1hcChpdGVtID0+IGl0ZW0udHJpbSgpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYWxsb3dlZEV4dGVuc2lvbjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZEZpbGVzKGNvbXBvbmVudCwgZmlsZXMpIHtcclxuXHRcdGNvbnN0IGFwcCA9IGNvbXBvbmVudC5nZXQoKS5hcHA7XHJcblx0XHRjb25zdCBmaWxlc1RvQWRkID0gb2JqZWN0VG9BcnJheShmaWxlcyk7XHJcblx0XHRsZXQgbGlzdGVkRmlsZXMgPSBbXTtcclxuXHJcblx0XHRpZiAoY29tcG9uZW50LmdldCgpLnNlbGVjdGVkRmlsZXMpIHtcclxuXHRcdFx0bGlzdGVkRmlsZXMgPSBjb21wb25lbnQuZ2V0KCkuc2VsZWN0ZWRGaWxlcztcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBhbGxvd2VkRmlsZUV4dGVuc2lvbnMgPSBnZXRBbGxvd2VkRmlsZUV4dGVuc2lvbnMoY29tcG9uZW50KTtcclxuXHRcdGNvbnN0IGZpbGVzVGhhdENhbkJlQWRkZWQgPSBmaWxlc1RvQWRkXHJcblx0XHRcdC5maWx0ZXIoZmlsZSA9PiBjYW5GaWxlQmVBZGRlZChsaXN0ZWRGaWxlcywgZmlsZSwgYWxsb3dlZEZpbGVFeHRlbnNpb25zLCBhcHApKTtcclxuXHJcblx0XHRpZiAoZmlsZXNUaGF0Q2FuQmVBZGRlZC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdGlmICghY29tcG9uZW50LmdldCgpLnVwbG9hZGVyQ29uZmlnLmFsbG93TXVsdGlwbGVGaWxlcykge1xyXG5cdFx0XHRcdGNvbXBvbmVudC5zZXQoeyBzZWxlY3RlZEZpbGVzOiBmaWxlc1RoYXRDYW5CZUFkZGVkLnNsaWNlKDAsIDEpIH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGNvbXBvbmVudC5zZXQoeyBzZWxlY3RlZEZpbGVzOiBmaWxlc1RoYXRDYW5CZUFkZGVkLmNvbmNhdChsaXN0ZWRGaWxlcykgfSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0YWRkRmlsZXMoZmlsZXMpIHtcclxuXHRcdFx0XHRhZGRGaWxlcyh0aGlzLCBmaWxlcyk7XHJcblx0XHRcdFx0dGhpcy5nZXQoKS5maWVsZC5zZWxlY3RlZCA9IHRoaXMuZ2V0KCkuc2VsZWN0ZWRGaWxlcztcclxuXHRcdFx0fSxcclxuXHRcdFx0cmVtb3ZlRmlsZShpbmRleCkge1xyXG5cdFx0XHRcdHRoaXMuZ2V0KCkuc2VsZWN0ZWRGaWxlcy5zcGxpY2UoaW5kZXgsIDEpLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0c2VsZWN0ZWRGaWxlczogdGhpcy5nZXQoKS5zZWxlY3RlZEZpbGVzXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0KCkuZmllbGQuc2VsZWN0ZWQgPSB0aGlzLmdldCgpLnNlbGVjdGVkRmlsZXM7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgZmllbGQgPSB0aGlzLmdldCgpLmZpZWxkO1xyXG5cclxuXHRcdFx0Y29uc3QgdXBsb2FkZXJDb25maWcgPVxyXG5cdFx0XHRcdGZpZWxkLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiZmlsZVVwbG9hZGVyQ29uZmlnXCIpIHx8XHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0YWxsb3dNdWx0aXBsZUZpbGVzOiB0cnVlLFxyXG5cdFx0XHRcdFx0YWxsb3dlZEZpbGVFeHRlbnNpb25zOiBcIipcIlxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLnNldCh7IHVwbG9hZGVyQ29uZmlnIH0pO1xyXG5cclxuXHRcdFx0dGhpcy5yZWZzLmRyb3B6b25lLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdHRoaXMucmVmcy5kcm9wem9uZS5jbGFzc0xpc3QuYWRkKFwiaG92ZXJcIik7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XHJcblx0XHRcdFtcImRyYWdsZWF2ZVwiLCBcImRyb3BcIl0uZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0XHRzZWxmLnJlZnMuZHJvcHpvbmUuYWRkRXZlbnRMaXN0ZW5lcih0LCAoKSA9PiB7XHJcblx0XHRcdFx0XHRzZWxmLnJlZnMuZHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZShcImhvdmVyXCIpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMucmVmcy5kcm9wem9uZS5vbmRyYWdvdmVyID0gZSA9PiB7XHJcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5yZWZzLmRyb3B6b25lLm9uZHJvcCA9IGUgPT4ge1xyXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRzZWxmLmFkZEZpbGVzKGUuZGF0YVRyYW5zZmVyLmZpbGVzKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LmZpbGUtZHJvcC1hcmVhIHtcclxuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHRcdGJvcmRlcjogZGFzaGVkIDJweCAjOWM5YzljO1xyXG5cdFx0bWluLWhlaWdodDogNjBweDtcclxuXHRcdHotaW5kZXg6IDk5OTk5O1xyXG5cdH1cclxuXHJcblx0LmZpbGUtZHJvcC1hcmVhLmhvdmVyIHtcclxuXHRcdGJhY2tncm91bmQ6ICNmZmZkZTY7XHJcblx0fVxyXG5cclxuXHQuZmlsZS1kcm9wLWFyZWEgbGFiZWwge1xyXG5cdFx0bWFyZ2luOiBhdXRvO1xyXG5cdFx0bGluZS1oZWlnaHQ6IDYwcHg7XHJcblx0XHRkaXNwbGF5OiBibG9jaztcclxuXHR9XHJcblxyXG5cdC5maWxlcy1saXN0IGkge1xyXG5cdFx0bWFyZ2luLWxlZnQ6IDEwcHg7XHJcblx0fVxyXG5cclxuXHQuc2Vjb25kLWNvbG9yIHtcclxuXHRcdGNvbG9yOiAjZjM4MThjO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWdKQyxlQUFlLGNBQUMsQ0FBQyxBQUNoQixVQUFVLENBQUUsTUFBTSxDQUNsQixNQUFNLENBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQzFCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE9BQU8sQ0FBRSxLQUFLLEFBQ2YsQ0FBQyxBQU1ELDZCQUFlLENBQUMsS0FBSyxjQUFDLENBQUMsQUFDdEIsTUFBTSxDQUFFLElBQUksQ0FDWixXQUFXLENBQUUsSUFBSSxDQUNqQixPQUFPLENBQUUsS0FBSyxBQUNmLENBQUMsQUFFRCx5QkFBVyxDQUFDLENBQUMsY0FBQyxDQUFDLEFBQ2QsV0FBVyxDQUFFLElBQUksQUFDbEIsQ0FBQyxBQUVELGFBQWEsY0FBQyxDQUFDLEFBQ2QsS0FBSyxDQUFFLE9BQU8sQUFDZixDQUFDIn0= */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$e(component_1, ctx) {
    	var text, div, text_1, label, text_2, strong, text_3, text_4;

    	var if_block = (ctx.selectedFiles != null && ctx.selectedFiles.length > 0) && create_if_block$b(component_1, ctx);

    	function select_block_type(ctx) {
    		if (ctx.uploaderConfig != null && ctx.uploaderConfig.allowMultipleFiles) return create_if_block_1$8;
    		return create_if_block_2$6;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block_1 = current_block_type(component_1, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n");
    			div = createElement("div");
    			if_block_1.c();
    			text_1 = createText("\r\n\t");
    			label = createElement("label");
    			text_2 = createText("drag or ");
    			strong = createElement("strong");
    			text_3 = createText("upload");
    			text_4 = createText(" files");
    			strong.className = "second-color svelte-6mad9x";
    			addLoc(strong, file$e, 25, 27, 767);
    			label.htmlFor = ctx.id;
    			label.className = "svelte-6mad9x";
    			addLoc(label, file$e, 25, 1, 741);
    			div.className = "file-drop-area svelte-6mad9x";
    			addLoc(div, file$e, 10, 0, 246);
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(text, target, anchor);
    			insertNode(div, target, anchor);
    			if_block_1.m(div, null);
    			appendNode(text_1, div);
    			appendNode(label, div);
    			appendNode(text_2, label);
    			appendNode(strong, label);
    			appendNode(text_3, strong);
    			appendNode(text_4, label);
    			component_1.refs.dropzone = div;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.selectedFiles != null && ctx.selectedFiles.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$b(component_1, ctx);
    					if_block.c();
    					if_block.m(text.parentNode, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block_1) {
    				if_block_1.p(changed, ctx);
    			} else {
    				if_block_1.d(1);
    				if_block_1 = current_block_type(component_1, ctx);
    				if_block_1.c();
    				if_block_1.m(div, text_1);
    			}

    			if (changed.id) {
    				label.htmlFor = ctx.id;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(text);
    				detachNode(div);
    			}

    			if_block_1.d();
    			if (component_1.refs.dropzone === div) component_1.refs.dropzone = null;
    		}
    	};
    }

    // (3:1) {#each selectedFiles as file, index}
    function create_each_block$5(component_1, ctx) {
    	var li, text_value = ctx.file.name, text, text_1, i;

    	return {
    		c: function create() {
    			li = createElement("li");
    			text = createText(text_value);
    			text_1 = createText("\r\n\t\t");
    			i = createElement("i");
    			i._svelte = { component: component_1, ctx };

    			addListener(i, "click", click_handler);
    			i.className = "fa fa-times second-color svelte-6mad9x";
    			addLoc(i, file$e, 4, 2, 141);
    			addLoc(li, file$e, 3, 1, 122);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			appendNode(text, li);
    			appendNode(text_1, li);
    			appendNode(i, li);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.selectedFiles) && text_value !== (text_value = ctx.file.name)) {
    				text.data = text_value;
    			}

    			i._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			removeListener(i, "click", click_handler);
    		}
    	};
    }

    // (1:0) {#if selectedFiles != null && selectedFiles.length > 0}
    function create_if_block$b(component_1, ctx) {
    	var ul;

    	var each_value = ctx.selectedFiles;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(component_1, get_each_context$5(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			ul.className = "files-list svelte-6mad9x";
    			addLoc(ul, file$e, 1, 0, 57);
    		},

    		m: function mount(target, anchor) {
    			insertNode(ul, target, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.selectedFiles) {
    				each_value = ctx.selectedFiles;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$5(component_1, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (12:1) {#if uploaderConfig != null && uploaderConfig.allowMultipleFiles}
    function create_if_block_1$8(component_1, ctx) {
    	var input, input_accept_value;

    	function change_handler(event) {
    		component_1.addFiles(this.files);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "file");
    			input.id = ctx.id;
    			input.tabIndex = ctx.tabindex;
    			input.multiple = "multiple";
    			input.accept = input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*';
    			addLoc(input, file$e, 12, 1, 358);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.uploaderConfig) && input_accept_value !== (input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*')) {
    				input.accept = input_accept_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (19:1) {:else}
    function create_if_block_2$6(component_1, ctx) {
    	var input, input_accept_value;

    	function change_handler(event) {
    		component_1.addFiles(this.files);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "file");
    			input.id = ctx.id;
    			input.tabIndex = ctx.tabindex;
    			input.accept = input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*';
    			addLoc(input, file$e, 19, 1, 562);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.uploaderConfig) && input_accept_value !== (input_accept_value = ctx.uploaderConfig ? ctx.uploaderConfig.allowedFileExtensions : '*')) {
    				input.accept = input_accept_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.file = list[i];
    	child_ctx.each_value = list;
    	child_ctx.index = i;
    	return child_ctx;
    }

    function click_handler(event) {
    	const { component, ctx } = this._svelte;

    	component.removeFile(ctx.index);
    }

    function SvelteComponent$e(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('selectedFiles' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'selectedFiles'");
    	if (!('uploaderConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'uploaderConfig'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-6mad9x-style")) add_css$7();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$e(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$a.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$e.prototype, protoDev);
    assign(SvelteComponent$e.prototype, methods$4);

    SvelteComponent$e.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var choices = createCommonjsModule(function (module, exports) {
    /*! choices.js v3.0.4 | (c) 2018 Josh Johnson | https://github.com/jshjohnson/Choices#readme */ 
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(commonjsGlobal, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};

    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {

    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId])
    /******/ 			return installedModules[moduleId].exports;

    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			exports: {},
    /******/ 			id: moduleId,
    /******/ 			loaded: false
    /******/ 		};

    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    /******/ 		// Flag the module as loaded
    /******/ 		module.loaded = true;

    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}


    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;

    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;

    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "/assets/scripts/dist/";

    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(0);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {

    	module.exports = __webpack_require__(1);


    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {

    	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	var _fuse = __webpack_require__(2);

    	var _fuse2 = _interopRequireDefault(_fuse);

    	var _classnames = __webpack_require__(3);

    	var _classnames2 = _interopRequireDefault(_classnames);

    	var _index = __webpack_require__(4);

    	var _index2 = _interopRequireDefault(_index);

    	var _index3 = __webpack_require__(31);

    	var _utils = __webpack_require__(32);

    	__webpack_require__(33);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	/**
    	 * Choices
    	 */
    	var Choices = function () {
    	  function Choices() {
    	    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-choice]';
    	    var userConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    	    _classCallCheck(this, Choices);

    	    // If there are multiple elements, create a new instance
    	    // for each element besides the first one (as that already has an instance)
    	    if ((0, _utils.isType)('String', element)) {
    	      var elements = document.querySelectorAll(element);
    	      if (elements.length > 1) {
    	        for (var i = 1; i < elements.length; i++) {
    	          var el = elements[i];
    	          new Choices(el, userConfig);
    	        }
    	      }
    	    }

    	    var defaultConfig = {
    	      silent: false,
    	      items: [],
    	      choices: [],
    	      renderChoiceLimit: -1,
    	      maxItemCount: -1,
    	      addItems: true,
    	      removeItems: true,
    	      removeItemButton: false,
    	      editItems: false,
    	      duplicateItems: true,
    	      delimiter: ',',
    	      paste: true,
    	      searchEnabled: true,
    	      searchChoices: true,
    	      searchFloor: 1,
    	      searchResultLimit: 4,
    	      searchFields: ['label', 'value'],
    	      position: 'auto',
    	      resetScrollPosition: true,
    	      regexFilter: null,
    	      shouldSort: true,
    	      shouldSortItems: false,
    	      sortFilter: _utils.sortByAlpha,
    	      placeholder: true,
    	      placeholderValue: null,
    	      searchPlaceholderValue: null,
    	      prependValue: null,
    	      appendValue: null,
    	      renderSelectedChoices: 'auto',
    	      loadingText: 'Loading...',
    	      noResultsText: 'No results found',
    	      noChoicesText: 'No choices to choose from',
    	      itemSelectText: 'Press to select',
    	      addItemText: function addItemText(value) {
    	        return 'Press Enter to add <b>"' + (0, _utils.stripHTML)(value) + '"</b>';
    	      },
    	      maxItemText: function maxItemText(maxItemCount) {
    	        return 'Only ' + maxItemCount + ' values can be added.';
    	      },
    	      itemComparer: function itemComparer(choice, item) {
    	        return choice === item;
    	      },
    	      uniqueItemText: 'Only unique values can be added.',
    	      classNames: {
    	        containerOuter: 'choices',
    	        containerInner: 'choices__inner',
    	        input: 'choices__input',
    	        inputCloned: 'choices__input--cloned',
    	        list: 'choices__list',
    	        listItems: 'choices__list--multiple',
    	        listSingle: 'choices__list--single',
    	        listDropdown: 'choices__list--dropdown',
    	        item: 'choices__item',
    	        itemSelectable: 'choices__item--selectable',
    	        itemDisabled: 'choices__item--disabled',
    	        itemChoice: 'choices__item--choice',
    	        placeholder: 'choices__placeholder',
    	        group: 'choices__group',
    	        groupHeading: 'choices__heading',
    	        button: 'choices__button',
    	        activeState: 'is-active',
    	        focusState: 'is-focused',
    	        openState: 'is-open',
    	        disabledState: 'is-disabled',
    	        highlightedState: 'is-highlighted',
    	        hiddenState: 'is-hidden',
    	        flippedState: 'is-flipped',
    	        loadingState: 'is-loading',
    	        noResults: 'has-no-results',
    	        noChoices: 'has-no-choices'
    	      },
    	      fuseOptions: {
    	        include: 'score'
    	      },
    	      callbackOnInit: null,
    	      callbackOnCreateTemplates: null
    	    };

    	    this.idNames = {
    	      itemChoice: 'item-choice'
    	    };

    	    // Merge options with user options
    	    this.config = (0, _utils.extend)(defaultConfig, userConfig);

    	    if (this.config.renderSelectedChoices !== 'auto' && this.config.renderSelectedChoices !== 'always') {
    	      if (!this.config.silent) {
    	        console.warn('renderSelectedChoices: Possible values are \'auto\' and \'always\'. Falling back to \'auto\'.');
    	      }
    	      this.config.renderSelectedChoices = 'auto';
    	    }

    	    // Create data store
    	    this.store = new _index2.default(this.render);

    	    // State tracking
    	    this.initialised = false;
    	    this.currentState = {};
    	    this.prevState = {};
    	    this.currentValue = '';

    	    // Retrieve triggering element (i.e. element with 'data-choice' trigger)
    	    this.element = element;
    	    this.passedElement = (0, _utils.isType)('String', element) ? document.querySelector(element) : element;

    	    if (!this.passedElement) {
    	      if (!this.config.silent) {
    	        console.error('Passed element not found');
    	      }
    	      return;
    	    }

    	    this.isTextElement = this.passedElement.type === 'text';
    	    this.isSelectOneElement = this.passedElement.type === 'select-one';
    	    this.isSelectMultipleElement = this.passedElement.type === 'select-multiple';
    	    this.isSelectElement = this.isSelectOneElement || this.isSelectMultipleElement;
    	    this.isValidElementType = this.isTextElement || this.isSelectElement;
    	    this.isIe11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));
    	    this.isScrollingOnIe = false;

    	    if (this.config.shouldSortItems === true && this.isSelectOneElement) {
    	      if (!this.config.silent) {
    	        console.warn('shouldSortElements: Type of passed element is \'select-one\', falling back to false.');
    	      }
    	    }

    	    this.highlightPosition = 0;
    	    this.canSearch = this.config.searchEnabled;

    	    this.placeholder = false;
    	    if (!this.isSelectOneElement) {
    	      this.placeholder = this.config.placeholder ? this.config.placeholderValue || this.passedElement.getAttribute('placeholder') : false;
    	    }

    	    // Assign preset choices from passed object
    	    this.presetChoices = this.config.choices;

    	    // Assign preset items from passed object first
    	    this.presetItems = this.config.items;

    	    // Then add any values passed from attribute
    	    if (this.passedElement.value) {
    	      this.presetItems = this.presetItems.concat(this.passedElement.value.split(this.config.delimiter));
    	    }

    	    // Set unique base Id
    	    this.baseId = (0, _utils.generateId)(this.passedElement, 'choices-');

    	    // Bind methods
    	    this.render = this.render.bind(this);

    	    // Bind event handlers
    	    this._onFocus = this._onFocus.bind(this);
    	    this._onBlur = this._onBlur.bind(this);
    	    this._onKeyUp = this._onKeyUp.bind(this);
    	    this._onKeyDown = this._onKeyDown.bind(this);
    	    this._onClick = this._onClick.bind(this);
    	    this._onTouchMove = this._onTouchMove.bind(this);
    	    this._onTouchEnd = this._onTouchEnd.bind(this);
    	    this._onMouseDown = this._onMouseDown.bind(this);
    	    this._onMouseOver = this._onMouseOver.bind(this);
    	    this._onPaste = this._onPaste.bind(this);
    	    this._onInput = this._onInput.bind(this);

    	    // Monitor touch taps/scrolls
    	    this.wasTap = true;

    	    // Cutting the mustard
    	    var cuttingTheMustard = 'classList' in document.documentElement;
    	    if (!cuttingTheMustard && !this.config.silent) {
    	      console.error('Choices: Your browser doesn\'t support Choices');
    	    }

    	    var canInit = (0, _utils.isElement)(this.passedElement) && this.isValidElementType;

    	    if (canInit) {
    	      // If element has already been initialised with Choices
    	      if (this.passedElement.getAttribute('data-choice') === 'active') {
    	        return;
    	      }

    	      // Let's go
    	      this.init();
    	    } else if (!this.config.silent) {
    	      console.error('Incompatible input passed');
    	    }
    	  }

    	  /*========================================
    	  =            Public functions            =
    	  ========================================*/

    	  /**
    	   * Initialise Choices
    	   * @return
    	   * @public
    	   */


    	  _createClass(Choices, [{
    	    key: 'init',
    	    value: function init() {
    	      if (this.initialised === true) {
    	        return;
    	      }

    	      var callback = this.config.callbackOnInit;

    	      // Set initialise flag
    	      this.initialised = true;
    	      // Create required elements
    	      this._createTemplates();
    	      // Generate input markup
    	      this._createInput();
    	      // Subscribe store to render method
    	      this.store.subscribe(this.render);
    	      // Render any items
    	      this.render();
    	      // Trigger event listeners
    	      this._addEventListeners();

    	      // Run callback if it is a function
    	      if (callback) {
    	        if ((0, _utils.isType)('Function', callback)) {
    	          callback.call(this);
    	        }
    	      }
    	    }

    	    /**
    	     * Destroy Choices and nullify values
    	     * @return
    	     * @public
    	     */

    	  }, {
    	    key: 'destroy',
    	    value: function destroy() {
    	      if (this.initialised === false) {
    	        return;
    	      }

    	      // Remove all event listeners
    	      this._removeEventListeners();

    	      // Reinstate passed element
    	      this.passedElement.classList.remove(this.config.classNames.input, this.config.classNames.hiddenState);
    	      this.passedElement.removeAttribute('tabindex');
    	      // Recover original styles if any
    	      var origStyle = this.passedElement.getAttribute('data-choice-orig-style');
    	      if (Boolean(origStyle)) {
    	        this.passedElement.removeAttribute('data-choice-orig-style');
    	        this.passedElement.setAttribute('style', origStyle);
    	      } else {
    	        this.passedElement.removeAttribute('style');
    	      }
    	      this.passedElement.removeAttribute('aria-hidden');
    	      this.passedElement.removeAttribute('data-choice');

    	      // Re-assign values - this is weird, I know
    	      this.passedElement.value = this.passedElement.value;

    	      // Move passed element back to original position
    	      this.containerOuter.parentNode.insertBefore(this.passedElement, this.containerOuter);
    	      // Remove added elements
    	      this.containerOuter.parentNode.removeChild(this.containerOuter);

    	      // Clear data store
    	      this.clearStore();

    	      // Nullify instance-specific data
    	      this.config.templates = null;

    	      // Uninitialise
    	      this.initialised = false;
    	    }

    	    /**
    	     * Render group choices into a DOM fragment and append to choice list
    	     * @param  {Array} groups    Groups to add to list
    	     * @param  {Array} choices   Choices to add to groups
    	     * @param  {DocumentFragment} fragment Fragment to add groups and options to (optional)
    	     * @return {DocumentFragment} Populated options fragment
    	     * @private
    	     */

    	  }, {
    	    key: 'renderGroups',
    	    value: function renderGroups(groups, choices, fragment) {
    	      var _this = this;

    	      var groupFragment = fragment || document.createDocumentFragment();
    	      var filter = this.config.sortFilter;

    	      // If sorting is enabled, filter groups
    	      if (this.config.shouldSort) {
    	        groups.sort(filter);
    	      }

    	      groups.forEach(function (group) {
    	        // Grab options that are children of this group
    	        var groupChoices = choices.filter(function (choice) {
    	          if (_this.isSelectOneElement) {
    	            return choice.groupId === group.id;
    	          }
    	          return choice.groupId === group.id && !choice.selected;
    	        });

    	        if (groupChoices.length >= 1) {
    	          var dropdownGroup = _this._getTemplate('choiceGroup', group);
    	          groupFragment.appendChild(dropdownGroup);
    	          _this.renderChoices(groupChoices, groupFragment, true);
    	        }
    	      });

    	      return groupFragment;
    	    }

    	    /**
    	     * Render choices into a DOM fragment and append to choice list
    	     * @param  {Array} choices    Choices to add to list
    	     * @param  {DocumentFragment} fragment Fragment to add choices to (optional)
    	     * @return {DocumentFragment} Populated choices fragment
    	     * @private
    	     */

    	  }, {
    	    key: 'renderChoices',
    	    value: function renderChoices(choices, fragment) {
    	      var _this2 = this;

    	      var withinGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    	      // Create a fragment to store our list items (so we don't have to update the DOM for each item)
    	      var choicesFragment = fragment || document.createDocumentFragment();
    	      var _config = this.config,
    	          renderSelectedChoices = _config.renderSelectedChoices,
    	          searchResultLimit = _config.searchResultLimit,
    	          renderChoiceLimit = _config.renderChoiceLimit;

    	      var filter = this.isSearching ? _utils.sortByScore : this.config.sortFilter;
    	      var appendChoice = function appendChoice(choice) {
    	        var shouldRender = renderSelectedChoices === 'auto' ? _this2.isSelectOneElement || !choice.selected : true;
    	        if (shouldRender) {
    	          var dropdownItem = _this2._getTemplate('choice', choice);
    	          choicesFragment.appendChild(dropdownItem);
    	        }
    	      };

    	      var rendererableChoices = choices;

    	      if (renderSelectedChoices === 'auto' && !this.isSelectOneElement) {
    	        rendererableChoices = choices.filter(function (choice) {
    	          return !choice.selected;
    	        });
    	      }

    	      // Split array into placeholders and "normal" choices

    	      var _rendererableChoices$ = rendererableChoices.reduce(function (acc, choice) {
    	        if (choice.placeholder) {
    	          acc.placeholderChoices.push(choice);
    	        } else {
    	          acc.normalChoices.push(choice);
    	        }
    	        return acc;
    	      }, { placeholderChoices: [], normalChoices: [] }),
    	          placeholderChoices = _rendererableChoices$.placeholderChoices,
    	          normalChoices = _rendererableChoices$.normalChoices;

    	      // If sorting is enabled or the user is searching, filter choices


    	      if (this.config.shouldSort || this.isSearching) {
    	        normalChoices.sort(filter);
    	      }

    	      var choiceLimit = rendererableChoices.length;

    	      // Prepend placeholeder
    	      var sortedChoices = [].concat(_toConsumableArray(placeholderChoices), _toConsumableArray(normalChoices));

    	      if (this.isSearching) {
    	        choiceLimit = searchResultLimit;
    	      } else if (renderChoiceLimit > 0 && !withinGroup) {
    	        choiceLimit = renderChoiceLimit;
    	      }

    	      // Add each choice to dropdown within range
    	      for (var i = 0; i < choiceLimit; i++) {
    	        if (sortedChoices[i]) {
    	          appendChoice(sortedChoices[i]);
    	        }
    	      }
    	      return choicesFragment;
    	    }

    	    /**
    	     * Render items into a DOM fragment and append to items list
    	     * @param  {Array} items    Items to add to list
    	     * @param  {DocumentFragment} [fragment] Fragment to add items to (optional)
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: 'renderItems',
    	    value: function renderItems(items) {
    	      var _this3 = this;

    	      var fragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    	      // Create fragment to add elements to
    	      var itemListFragment = fragment || document.createDocumentFragment();

    	      // If sorting is enabled, filter items
    	      if (this.config.shouldSortItems && !this.isSelectOneElement) {
    	        items.sort(this.config.sortFilter);
    	      }

    	      if (this.isTextElement) {
    	        // Simplify store data to just values
    	        var itemsFiltered = this.store.getItemsReducedToValues(items);
    	        var itemsFilteredString = itemsFiltered.join(this.config.delimiter);
    	        // Update the value of the hidden input
    	        this.passedElement.setAttribute('value', itemsFilteredString);
    	        this.passedElement.value = itemsFilteredString;
    	      } else {
    	        var selectedOptionsFragment = document.createDocumentFragment();

    	        // Add each list item to list
    	        items.forEach(function (item) {
    	          // Create a standard select option
    	          var option = _this3._getTemplate('option', item);
    	          // Append it to fragment
    	          selectedOptionsFragment.appendChild(option);
    	        });

    	        // Update selected choices
    	        this.passedElement.innerHTML = '';
    	        this.passedElement.appendChild(selectedOptionsFragment);
    	      }

    	      // Add each list item to list
    	      items.forEach(function (item) {
    	        // Create new list element
    	        var listItem = _this3._getTemplate('item', item);
    	        // Append it to list
    	        itemListFragment.appendChild(listItem);
    	      });

    	      return itemListFragment;
    	    }

    	    /**
    	     * Render DOM with values
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: 'render',
    	    value: function render() {
    	      if (this.store.isLoading()) {
    	        return;
    	      }

    	      this.currentState = this.store.getState();

    	      // Only render if our state has actually changed
    	      if (this.currentState !== this.prevState) {
    	        // Choices
    	        if (this.currentState.choices !== this.prevState.choices || this.currentState.groups !== this.prevState.groups || this.currentState.items !== this.prevState.items) {
    	          if (this.isSelectElement) {
    	            // Get active groups/choices
    	            var activeGroups = this.store.getGroupsFilteredByActive();
    	            var activeChoices = this.store.getChoicesFilteredByActive();

    	            var choiceListFragment = document.createDocumentFragment();

    	            // Clear choices
    	            this.choiceList.innerHTML = '';

    	            // Scroll back to top of choices list
    	            if (this.config.resetScrollPosition) {
    	              this.choiceList.scrollTop = 0;
    	            }

    	            // If we have grouped options
    	            if (activeGroups.length >= 1 && this.isSearching !== true) {
    	              choiceListFragment = this.renderGroups(activeGroups, activeChoices, choiceListFragment);
    	            } else if (activeChoices.length >= 1) {
    	              choiceListFragment = this.renderChoices(activeChoices, choiceListFragment);
    	            }

    	            var activeItems = this.store.getItemsFilteredByActive();
    	            var canAddItem = this._canAddItem(activeItems, this.input.value);

    	            // If we have choices to show
    	            if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
    	              // ...and we can select them
    	              if (canAddItem.response) {
    	                // ...append them and highlight the first choice
    	                this.choiceList.appendChild(choiceListFragment);
    	                this._highlightChoice();
    	              } else {
    	                // ...otherwise show a notice
    	                this.choiceList.appendChild(this._getTemplate('notice', canAddItem.notice));
    	              }
    	            } else {
    	              // Otherwise show a notice
    	              var dropdownItem = void 0;
    	              var notice = void 0;

    	              if (this.isSearching) {
    	                notice = (0, _utils.isType)('Function', this.config.noResultsText) ? this.config.noResultsText() : this.config.noResultsText;

    	                dropdownItem = this._getTemplate('notice', notice, 'no-results');
    	              } else {
    	                notice = (0, _utils.isType)('Function', this.config.noChoicesText) ? this.config.noChoicesText() : this.config.noChoicesText;

    	                dropdownItem = this._getTemplate('notice', notice, 'no-choices');
    	              }

    	              this.choiceList.appendChild(dropdownItem);
    	            }
    	          }
    	        }

    	        // Items
    	        if (this.currentState.items !== this.prevState.items) {
    	          // Get active items (items that can be selected)
    	          var _activeItems = this.store.getItemsFilteredByActive();

    	          // Clear list
    	          this.itemList.innerHTML = '';

    	          if (_activeItems && _activeItems) {
    	            // Create a fragment to store our list items
    	            // (so we don't have to update the DOM for each item)
    	            var itemListFragment = this.renderItems(_activeItems);

    	            // If we have items to add
    	            if (itemListFragment.childNodes) {
    	              // Update list
    	              this.itemList.appendChild(itemListFragment);
    	            }
    	          }
    	        }

    	        this.prevState = this.currentState;
    	      }
    	    }

    	    /**
    	     * Select item (a selected item can be deleted)
    	     * @param  {Element} item Element to select
    	     * @param  {Boolean} [runEvent=true] Whether to trigger 'highlightItem' event
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'highlightItem',
    	    value: function highlightItem(item) {
    	      var runEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    	      if (!item) {
    	        return this;
    	      }

    	      var id = item.id;
    	      var groupId = item.groupId;
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      this.store.dispatch((0, _index3.highlightItem)(id, true));

    	      if (runEvent) {
    	        if (group && group.value) {
    	          (0, _utils.triggerEvent)(this.passedElement, 'highlightItem', {
    	            id: id,
    	            value: item.value,
    	            label: item.label,
    	            groupValue: group.value
    	          });
    	        } else {
    	          (0, _utils.triggerEvent)(this.passedElement, 'highlightItem', {
    	            id: id,
    	            value: item.value,
    	            label: item.label
    	          });
    	        }
    	      }

    	      return this;
    	    }

    	    /**
    	     * Deselect item
    	     * @param  {Element} item Element to de-select
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'unhighlightItem',
    	    value: function unhighlightItem(item) {
    	      if (!item) {
    	        return this;
    	      }

    	      var id = item.id;
    	      var groupId = item.groupId;
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      this.store.dispatch((0, _index3.highlightItem)(id, false));

    	      if (group && group.value) {
    	        (0, _utils.triggerEvent)(this.passedElement, 'unhighlightItem', {
    	          id: id,
    	          value: item.value,
    	          label: item.label,
    	          groupValue: group.value
    	        });
    	      } else {
    	        (0, _utils.triggerEvent)(this.passedElement, 'unhighlightItem', {
    	          id: id,
    	          value: item.value,
    	          label: item.label
    	        });
    	      }

    	      return this;
    	    }

    	    /**
    	     * Highlight items within store
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'highlightAll',
    	    value: function highlightAll() {
    	      var _this4 = this;

    	      var items = this.store.getItems();
    	      items.forEach(function (item) {
    	        _this4.highlightItem(item);
    	      });

    	      return this;
    	    }

    	    /**
    	     * Deselect items within store
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'unhighlightAll',
    	    value: function unhighlightAll() {
    	      var _this5 = this;

    	      var items = this.store.getItems();
    	      items.forEach(function (item) {
    	        _this5.unhighlightItem(item);
    	      });

    	      return this;
    	    }

    	    /**
    	     * Remove an item from the store by its value
    	     * @param  {String} value Value to search for
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'removeItemsByValue',
    	    value: function removeItemsByValue(value) {
    	      var _this6 = this;

    	      if (!value || !(0, _utils.isType)('String', value)) {
    	        return this;
    	      }

    	      var items = this.store.getItemsFilteredByActive();

    	      items.forEach(function (item) {
    	        if (item.value === value) {
    	          _this6._removeItem(item);
    	        }
    	      });

    	      return this;
    	    }

    	    /**
    	     * Remove all items from store array
    	     * @note Removed items are soft deleted
    	     * @param  {Number} excludedId Optionally exclude item by ID
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'removeActiveItems',
    	    value: function removeActiveItems(excludedId) {
    	      var _this7 = this;

    	      var items = this.store.getItemsFilteredByActive();

    	      items.forEach(function (item) {
    	        if (item.active && excludedId !== item.id) {
    	          _this7._removeItem(item);
    	        }
    	      });

    	      return this;
    	    }

    	    /**
    	     * Remove all selected items from store
    	     * @note Removed items are soft deleted
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'removeHighlightedItems',
    	    value: function removeHighlightedItems() {
    	      var _this8 = this;

    	      var runEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      var items = this.store.getItemsFilteredByActive();

    	      items.forEach(function (item) {
    	        if (item.highlighted && item.active) {
    	          _this8._removeItem(item);
    	          // If this action was performed by the user
    	          // trigger the event
    	          if (runEvent) {
    	            _this8._triggerChange(item.value);
    	          }
    	        }
    	      });

    	      return this;
    	    }

    	    /**
    	     * Show dropdown to user by adding active state class
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'showDropdown',
    	    value: function showDropdown() {
    	      var focusInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      var body = document.body;
    	      var html = document.documentElement;
    	      var winHeight = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);

    	      this.containerOuter.classList.add(this.config.classNames.openState);
    	      this.containerOuter.setAttribute('aria-expanded', 'true');
    	      this.dropdown.classList.add(this.config.classNames.activeState);
    	      this.dropdown.setAttribute('aria-expanded', 'true');

    	      var dimensions = this.dropdown.getBoundingClientRect();
    	      var dropdownPos = Math.ceil(dimensions.top + window.scrollY + this.dropdown.offsetHeight);

    	      // If flip is enabled and the dropdown bottom position is greater than the window height flip the dropdown.
    	      var shouldFlip = false;
    	      if (this.config.position === 'auto') {
    	        shouldFlip = dropdownPos >= winHeight;
    	      } else if (this.config.position === 'top') {
    	        shouldFlip = true;
    	      }

    	      if (shouldFlip) {
    	        this.containerOuter.classList.add(this.config.classNames.flippedState);
    	      }

    	      // Optionally focus the input if we have a search input
    	      if (focusInput && this.canSearch && document.activeElement !== this.input) {
    	        this.input.focus();
    	      }

    	      (0, _utils.triggerEvent)(this.passedElement, 'showDropdown', {});

    	      return this;
    	    }

    	    /**
    	     * Hide dropdown from user
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'hideDropdown',
    	    value: function hideDropdown() {
    	      var blurInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      // A dropdown flips if it does not have space within the page
    	      var isFlipped = this.containerOuter.classList.contains(this.config.classNames.flippedState);

    	      this.containerOuter.classList.remove(this.config.classNames.openState);
    	      this.containerOuter.setAttribute('aria-expanded', 'false');
    	      this.dropdown.classList.remove(this.config.classNames.activeState);
    	      this.dropdown.setAttribute('aria-expanded', 'false');

    	      if (isFlipped) {
    	        this.containerOuter.classList.remove(this.config.classNames.flippedState);
    	      }

    	      // Optionally blur the input if we have a search input
    	      if (blurInput && this.canSearch && document.activeElement === this.input) {
    	        this.input.blur();
    	      }

    	      (0, _utils.triggerEvent)(this.passedElement, 'hideDropdown', {});

    	      return this;
    	    }

    	    /**
    	     * Determine whether to hide or show dropdown based on its current state
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'toggleDropdown',
    	    value: function toggleDropdown() {
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	      if (hasActiveDropdown) {
    	        this.hideDropdown();
    	      } else {
    	        this.showDropdown(true);
    	      }

    	      return this;
    	    }

    	    /**
    	     * Get value(s) of input (i.e. inputted items (text) or selected choices (select))
    	     * @param {Boolean} valueOnly Get only values of selected items, otherwise return selected items
    	     * @return {Array/String} selected value (select-one) or array of selected items (inputs & select-multiple)
    	     * @public
    	     */

    	  }, {
    	    key: 'getValue',
    	    value: function getValue() {
    	      var _this9 = this;

    	      var valueOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    	      var items = this.store.getItemsFilteredByActive();
    	      var selectedItems = [];

    	      items.forEach(function (item) {
    	        if (_this9.isTextElement) {
    	          selectedItems.push(valueOnly ? item.value : item);
    	        } else if (item.active) {
    	          selectedItems.push(valueOnly ? item.value : item);
    	        }
    	      });

    	      if (this.isSelectOneElement) {
    	        return selectedItems[0];
    	      }

    	      return selectedItems;
    	    }

    	    /**
    	     * Set value of input. If the input is a select box, a choice will be created and selected otherwise
    	     * an item will created directly.
    	     * @param  {Array}   args  Array of value objects or value strings
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'setValue',
    	    value: function setValue(args) {
    	      var _this10 = this;

    	      if (this.initialised === true) {
    	        // Convert args to an iterable array
    	        var values = [].concat(_toConsumableArray(args)),
    	            handleValue = function handleValue(item) {
    	          var itemType = (0, _utils.getType)(item);
    	          if (itemType === 'Object') {
    	            if (!item.value) {
    	              return;
    	            }

    	            // If we are dealing with a select input, we need to create an option first
    	            // that is then selected. For text inputs we can just add items normally.
    	            if (!_this10.isTextElement) {
    	              _this10._addChoice(item.value, item.label, true, false, -1, item.customProperties, item.placeholder);
    	            } else {
    	              _this10._addItem(item.value, item.label, item.id, undefined, item.customProperties, item.placeholder);
    	            }
    	          } else if (itemType === 'String') {
    	            if (!_this10.isTextElement) {
    	              _this10._addChoice(item, item, true, false, -1, null);
    	            } else {
    	              _this10._addItem(item);
    	            }
    	          }
    	        };

    	        if (values.length > 1) {
    	          values.forEach(function (value) {
    	            handleValue(value);
    	          });
    	        } else {
    	          handleValue(values[0]);
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Select value of select box via the value of an existing choice
    	     * @param {Array/String} value An array of strings of a single string
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'setValueByChoice',
    	    value: function setValueByChoice(value) {
    	      var _this11 = this;

    	      if (!this.isTextElement) {
    	        var choices = this.store.getChoices();
    	        // If only one value has been passed, convert to array
    	        var choiceValue = (0, _utils.isType)('Array', value) ? value : [value];

    	        // Loop through each value and
    	        choiceValue.forEach(function (val) {
    	          var foundChoice = choices.find(function (choice) {
    	            // Check 'value' property exists and the choice isn't already selected
    	            return _this11.config.itemComparer(choice.value, val);
    	          });

    	          if (foundChoice) {
    	            if (!foundChoice.selected) {
    	              _this11._addItem(foundChoice.value, foundChoice.label, foundChoice.id, foundChoice.groupId, foundChoice.customProperties, foundChoice.placeholder, foundChoice.keyCode);
    	            } else if (!_this11.config.silent) {
    	              console.warn('Attempting to select choice already selected');
    	            }
    	          } else if (!_this11.config.silent) {
    	            console.warn('Attempting to select choice that does not exist');
    	          }
    	        });
    	      }
    	      return this;
    	    }

    	    /**
    	     * Direct populate choices
    	     * @param  {Array} choices - Choices to insert
    	     * @param  {String} value - Name of 'value' property
    	     * @param  {String} label - Name of 'label' property
    	     * @param  {Boolean} replaceChoices Whether existing choices should be removed
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'setChoices',
    	    value: function setChoices(choices, value, label) {
    	      var _this12 = this;

    	      var replaceChoices = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    	      if (this.initialised === true) {
    	        if (this.isSelectElement) {
    	          if (!(0, _utils.isType)('Array', choices) || !value) {
    	            return this;
    	          }

    	          // Clear choices if needed
    	          if (replaceChoices) {
    	            this._clearChoices();
    	          }

    	          this._setLoading(true);

    	          // Add choices if passed
    	          if (choices && choices.length) {
    	            this.containerOuter.classList.remove(this.config.classNames.loadingState);
    	            choices.forEach(function (result) {
    	              if (result.choices) {
    	                _this12._addGroup(result, result.id || null, value, label);
    	              } else {
    	                _this12._addChoice(result[value], result[label], result.selected, result.disabled, undefined, result.customProperties, result.placeholder);
    	              }
    	            });
    	          }

    	          this._setLoading(false);
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Clear items,choices and groups
    	     * @note Hard delete
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'clearStore',
    	    value: function clearStore() {
    	      this.store.dispatch((0, _index3.clearAll)());
    	      return this;
    	    }

    	    /**
    	     * Set value of input to blank
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'clearInput',
    	    value: function clearInput() {
    	      if (this.input.value) {
    	        this.input.value = '';
    	      }
    	      if (!this.isSelectOneElement) {
    	        this._setInputWidth();
    	      }
    	      if (!this.isTextElement && this.config.searchEnabled) {
    	        this.isSearching = false;
    	        this.store.dispatch((0, _index3.activateChoices)(true));
    	      }
    	      return this;
    	    }

    	    /**
    	     * Enable interaction with Choices
    	     * @return {Object} Class instance
    	     */

    	  }, {
    	    key: 'enable',
    	    value: function enable() {
    	      if (this.initialised) {
    	        this.passedElement.disabled = false;
    	        var isDisabled = this.containerOuter.classList.contains(this.config.classNames.disabledState);
    	        if (isDisabled) {
    	          this._addEventListeners();
    	          this.passedElement.removeAttribute('disabled');
    	          this.input.removeAttribute('disabled');
    	          this.containerOuter.classList.remove(this.config.classNames.disabledState);
    	          this.containerOuter.removeAttribute('aria-disabled');
    	          if (this.isSelectOneElement) {
    	            this.containerOuter.setAttribute('tabindex', '0');
    	          }
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Disable interaction with Choices
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'disable',
    	    value: function disable() {
    	      if (this.initialised) {
    	        this.passedElement.disabled = true;
    	        var isEnabled = !this.containerOuter.classList.contains(this.config.classNames.disabledState);
    	        if (isEnabled) {
    	          this._removeEventListeners();
    	          this.passedElement.setAttribute('disabled', '');
    	          this.input.setAttribute('disabled', '');
    	          this.containerOuter.classList.add(this.config.classNames.disabledState);
    	          this.containerOuter.setAttribute('aria-disabled', 'true');
    	          if (this.isSelectOneElement) {
    	            this.containerOuter.setAttribute('tabindex', '-1');
    	          }
    	        }
    	      }
    	      return this;
    	    }

    	    /**
    	     * Populate options via ajax callback
    	     * @param  {Function} fn Function that actually makes an AJAX request
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: 'ajax',
    	    value: function ajax(fn) {
    	      var _this13 = this;

    	      if (this.initialised === true) {
    	        if (this.isSelectElement) {
    	          // Show loading text
    	          requestAnimationFrame(function () {
    	            _this13._handleLoadingState(true);
    	          });
    	          // Run callback
    	          fn(this._ajaxCallback());
    	        }
    	      }
    	      return this;
    	    }

    	    /*=====  End of Public functions  ======*/

    	    /*=============================================
    	    =                Private functions            =
    	    =============================================*/

    	    /**
    	     * Call change callback
    	     * @param  {String} value - last added/deleted/selected value
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_triggerChange',
    	    value: function _triggerChange(value) {
    	      if (!value) {
    	        return;
    	      }

    	      (0, _utils.triggerEvent)(this.passedElement, 'change', {
    	        value: value
    	      });
    	    }

    	    /**
    	     * Process enter/click of an item button
    	     * @param {Array} activeItems The currently active items
    	     * @param  {Element} element Button being interacted with
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleButtonAction',
    	    value: function _handleButtonAction(activeItems, element) {
    	      if (!activeItems || !element) {
    	        return;
    	      }

    	      // If we are clicking on a button
    	      if (this.config.removeItems && this.config.removeItemButton) {
    	        var itemId = element.parentNode.getAttribute('data-id');
    	        var itemToRemove = activeItems.find(function (item) {
    	          return item.id === parseInt(itemId, 10);
    	        });

    	        // Remove item associated with button
    	        this._removeItem(itemToRemove);
    	        this._triggerChange(itemToRemove.value);

    	        if (this.isSelectOneElement) {
    	          this._selectPlaceholderChoice();
    	        }
    	      }
    	    }

    	    /**
    	     * Select placeholder choice
    	     */

    	  }, {
    	    key: '_selectPlaceholderChoice',
    	    value: function _selectPlaceholderChoice() {
    	      var placeholderChoice = this.store.getPlaceholderChoice();

    	      if (placeholderChoice) {
    	        this._addItem(placeholderChoice.value, placeholderChoice.label, placeholderChoice.id, placeholderChoice.groupId, null, placeholderChoice.placeholder);
    	        this._triggerChange(placeholderChoice.value);
    	      }
    	    }

    	    /**
    	     * Process click of an item
    	     * @param {Array} activeItems The currently active items
    	     * @param  {Element} element Item being interacted with
    	     * @param  {Boolean} hasShiftKey Whether the user has the shift key active
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleItemAction',
    	    value: function _handleItemAction(activeItems, element) {
    	      var _this14 = this;

    	      var hasShiftKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    	      if (!activeItems || !element) {
    	        return;
    	      }

    	      // If we are clicking on an item
    	      if (this.config.removeItems && !this.isSelectOneElement) {
    	        var passedId = element.getAttribute('data-id');

    	        // We only want to select one item with a click
    	        // so we deselect any items that aren't the target
    	        // unless shift is being pressed
    	        activeItems.forEach(function (item) {
    	          if (item.id === parseInt(passedId, 10) && !item.highlighted) {
    	            _this14.highlightItem(item);
    	          } else if (!hasShiftKey) {
    	            if (item.highlighted) {
    	              _this14.unhighlightItem(item);
    	            }
    	          }
    	        });

    	        // Focus input as without focus, a user cannot do anything with a
    	        // highlighted item
    	        if (document.activeElement !== this.input) {
    	          this.input.focus();
    	        }
    	      }
    	    }

    	    /**
    	     * Process click of a choice
    	     * @param {Array} activeItems The currently active items
    	     * @param  {Element} element Choice being interacted with
    	     * @return
    	     */

    	  }, {
    	    key: '_handleChoiceAction',
    	    value: function _handleChoiceAction(activeItems, element) {
    	      if (!activeItems || !element) {
    	        return;
    	      }

    	      // If we are clicking on an option
    	      var id = element.getAttribute('data-id');
    	      var choice = this.store.getChoiceById(id);
    	      var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : null;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);

    	      // Update choice keyCode
    	      choice.keyCode = passedKeyCode;

    	      (0, _utils.triggerEvent)(this.passedElement, 'choice', {
    	        choice: choice
    	      });

    	      if (choice && !choice.selected && !choice.disabled) {
    	        var canAddItem = this._canAddItem(activeItems, choice.value);

    	        if (canAddItem.response) {
    	          this._addItem(choice.value, choice.label, choice.id, choice.groupId, choice.customProperties, choice.placeholder, choice.keyCode);
    	          this._triggerChange(choice.value);
    	        }
    	      }

    	      this.clearInput();

    	      // We wont to close the dropdown if we are dealing with a single select box
    	      if (hasActiveDropdown && this.isSelectOneElement) {
    	        this.hideDropdown();
    	        this.containerOuter.focus();
    	      }
    	    }

    	    /**
    	     * Process back space event
    	     * @param  {Array} activeItems items
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleBackspace',
    	    value: function _handleBackspace(activeItems) {
    	      if (this.config.removeItems && activeItems) {
    	        var lastItem = activeItems[activeItems.length - 1];
    	        var hasHighlightedItems = activeItems.some(function (item) {
    	          return item.highlighted;
    	        });

    	        // If editing the last item is allowed and there are not other selected items,
    	        // we can edit the item value. Otherwise if we can remove items, remove all selected items
    	        if (this.config.editItems && !hasHighlightedItems && lastItem) {
    	          this.input.value = lastItem.value;
    	          this._setInputWidth();
    	          this._removeItem(lastItem);
    	          this._triggerChange(lastItem.value);
    	        } else {
    	          if (!hasHighlightedItems) {
    	            this.highlightItem(lastItem, false);
    	          }
    	          this.removeHighlightedItems(true);
    	        }
    	      }
    	    }

    	    /**
    	     * Validates whether an item can be added by a user
    	     * @param {Array} activeItems The currently active items
    	     * @param  {String} value     Value of item to add
    	     * @return {Object}           Response: Whether user can add item
    	     *                            Notice: Notice show in dropdown
    	     */

    	  }, {
    	    key: '_canAddItem',
    	    value: function _canAddItem(activeItems, value) {
    	      var canAddItem = true;
    	      var notice = (0, _utils.isType)('Function', this.config.addItemText) ? this.config.addItemText(value) : this.config.addItemText;

    	      if (this.isSelectMultipleElement || this.isTextElement) {
    	        if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
    	          // If there is a max entry limit and we have reached that limit
    	          // don't update
    	          canAddItem = false;
    	          notice = (0, _utils.isType)('Function', this.config.maxItemText) ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
    	        }
    	      }

    	      if (this.isTextElement && this.config.addItems && canAddItem) {
    	        // If a user has supplied a regular expression filter
    	        if (this.config.regexFilter) {
    	          // Determine whether we can update based on whether
    	          // our regular expression passes
    	          canAddItem = this._regexFilter(value);
    	        }
    	      }

    	      // If no duplicates are allowed, and the value already exists
    	      // in the array
    	      var isUnique = !activeItems.some(function (item) {
    	        if ((0, _utils.isType)('String', value)) {
    	          return item.value === value.trim();
    	        }

    	        return item.value === value;
    	      });

    	      if (!isUnique && !this.config.duplicateItems && !this.isSelectOneElement && canAddItem) {
    	        canAddItem = false;
    	        notice = (0, _utils.isType)('Function', this.config.uniqueItemText) ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
    	      }

    	      return {
    	        response: canAddItem,
    	        notice: notice
    	      };
    	    }

    	    /**
    	     * Apply or remove a loading state to the component.
    	     * @param {Boolean} setLoading default value set to 'true'.
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleLoadingState',
    	    value: function _handleLoadingState() {
    	      var setLoading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    	      var placeholderItem = this.itemList.querySelector('.' + this.config.classNames.placeholder);
    	      if (setLoading) {
    	        this.containerOuter.classList.add(this.config.classNames.loadingState);
    	        this.containerOuter.setAttribute('aria-busy', 'true');
    	        if (this.isSelectOneElement) {
    	          if (!placeholderItem) {
    	            placeholderItem = this._getTemplate('placeholder', this.config.loadingText);
    	            this.itemList.appendChild(placeholderItem);
    	          } else {
    	            placeholderItem.innerHTML = this.config.loadingText;
    	          }
    	        } else {
    	          this.input.placeholder = this.config.loadingText;
    	        }
    	      } else {
    	        // Remove loading states/text
    	        this.containerOuter.classList.remove(this.config.classNames.loadingState);

    	        if (this.isSelectOneElement) {
    	          placeholderItem.innerHTML = this.placeholder || '';
    	        } else {
    	          this.input.placeholder = this.placeholder || '';
    	        }
    	      }
    	    }

    	    /**
    	     * Retrieve the callback used to populate component's choices in an async way.
    	     * @returns {Function} The callback as a function.
    	     * @private
    	     */

    	  }, {
    	    key: '_ajaxCallback',
    	    value: function _ajaxCallback() {
    	      var _this15 = this;

    	      return function (results, value, label) {
    	        if (!results || !value) {
    	          return;
    	        }

    	        var parsedResults = (0, _utils.isType)('Object', results) ? [results] : results;

    	        if (parsedResults && (0, _utils.isType)('Array', parsedResults) && parsedResults.length) {
    	          // Remove loading states/text
    	          _this15._handleLoadingState(false);
    	          // Add each result as a choice

    	          _this15._setLoading(true);

    	          parsedResults.forEach(function (result) {
    	            if (result.choices) {
    	              var groupId = result.id || null;
    	              _this15._addGroup(result, groupId, value, label);
    	            } else {
    	              _this15._addChoice(result[value], result[label], result.selected, result.disabled, undefined, result.customProperties, result.placeholder);
    	            }
    	          });

    	          _this15._setLoading(false);

    	          if (_this15.isSelectOneElement) {
    	            _this15._selectPlaceholderChoice();
    	          }
    	        } else {
    	          // No results, remove loading state
    	          _this15._handleLoadingState(false);
    	        }

    	        _this15.containerOuter.removeAttribute('aria-busy');
    	      };
    	    }

    	    /**
    	     * Filter choices based on search value
    	     * @param  {String} value Value to filter by
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_searchChoices',
    	    value: function _searchChoices(value) {
    	      var newValue = (0, _utils.isType)('String', value) ? value.trim() : value;
    	      var currentValue = (0, _utils.isType)('String', this.currentValue) ? this.currentValue.trim() : this.currentValue;

    	      // If new value matches the desired length and is not the same as the current value with a space
    	      if (newValue.length >= 1 && newValue !== currentValue + ' ') {
    	        var haystack = this.store.getSearchableChoices();
    	        var needle = newValue;
    	        var keys = (0, _utils.isType)('Array', this.config.searchFields) ? this.config.searchFields : [this.config.searchFields];
    	        var options = Object.assign(this.config.fuseOptions, { keys: keys });
    	        var fuse = new _fuse2.default(haystack, options);
    	        var results = fuse.search(needle);

    	        this.currentValue = newValue;
    	        this.highlightPosition = 0;
    	        this.isSearching = true;
    	        this.store.dispatch((0, _index3.filterChoices)(results));

    	        return results.length;
    	      }

    	      return 0;
    	    }

    	    /**
    	     * Determine the action when a user is searching
    	     * @param  {String} value Value entered by user
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_handleSearch',
    	    value: function _handleSearch(value) {
    	      if (!value) {
    	        return;
    	      }

    	      var choices = this.store.getChoices();
    	      var hasUnactiveChoices = choices.some(function (option) {
    	        return !option.active;
    	      });

    	      // Run callback if it is a function
    	      if (this.input === document.activeElement) {
    	        // Check that we have a value to search and the input was an alphanumeric character
    	        if (value && value.length >= this.config.searchFloor) {
    	          var resultCount = 0;
    	          // Check flag to filter search input
    	          if (this.config.searchChoices) {
    	            // Filter available choices
    	            resultCount = this._searchChoices(value);
    	          }
    	          // Trigger search event
    	          (0, _utils.triggerEvent)(this.passedElement, 'search', {
    	            value: value,
    	            resultCount: resultCount
    	          });
    	        } else if (hasUnactiveChoices) {
    	          // Otherwise reset choices to active
    	          this.isSearching = false;
    	          this.store.dispatch((0, _index3.activateChoices)(true));
    	        }
    	      }
    	    }

    	    /**
    	     * Trigger event listeners
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_addEventListeners',
    	    value: function _addEventListeners() {
    	      document.addEventListener('keyup', this._onKeyUp);
    	      document.addEventListener('keydown', this._onKeyDown);
    	      document.addEventListener('click', this._onClick);
    	      document.addEventListener('touchmove', this._onTouchMove);
    	      document.addEventListener('touchend', this._onTouchEnd);
    	      document.addEventListener('mousedown', this._onMouseDown);
    	      document.addEventListener('mouseover', this._onMouseOver);

    	      if (this.isSelectOneElement) {
    	        this.containerOuter.addEventListener('focus', this._onFocus);
    	        this.containerOuter.addEventListener('blur', this._onBlur);
    	      }

    	      this.input.addEventListener('input', this._onInput);
    	      this.input.addEventListener('paste', this._onPaste);
    	      this.input.addEventListener('focus', this._onFocus);
    	      this.input.addEventListener('blur', this._onBlur);
    	    }

    	    /**
    	     * Remove event listeners
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_removeEventListeners',
    	    value: function _removeEventListeners() {
    	      document.removeEventListener('keyup', this._onKeyUp);
    	      document.removeEventListener('keydown', this._onKeyDown);
    	      document.removeEventListener('click', this._onClick);
    	      document.removeEventListener('touchmove', this._onTouchMove);
    	      document.removeEventListener('touchend', this._onTouchEnd);
    	      document.removeEventListener('mousedown', this._onMouseDown);
    	      document.removeEventListener('mouseover', this._onMouseOver);

    	      if (this.isSelectOneElement) {
    	        this.containerOuter.removeEventListener('focus', this._onFocus);
    	        this.containerOuter.removeEventListener('blur', this._onBlur);
    	      }

    	      this.input.removeEventListener('input', this._onInput);
    	      this.input.removeEventListener('paste', this._onPaste);
    	      this.input.removeEventListener('focus', this._onFocus);
    	      this.input.removeEventListener('blur', this._onBlur);
    	    }

    	    /**
    	     * Set the correct input width based on placeholder
    	     * value or input value
    	     * @return
    	     */

    	  }, {
    	    key: '_setInputWidth',
    	    value: function _setInputWidth() {
    	      if (this.placeholder) {
    	        // If there is a placeholder, we only want to set the width of the input when it is a greater
    	        // length than 75% of the placeholder. This stops the input jumping around.
    	        if (this.input.value && this.input.value.length >= this.placeholder.length / 1.25) {
    	          this.input.style.width = (0, _utils.getWidthOfInput)(this.input);
    	        }
    	      } else {
    	        // If there is no placeholder, resize input to contents
    	        this.input.style.width = (0, _utils.getWidthOfInput)(this.input);
    	      }
    	    }

    	    /**
    	     * Key down event
    	     * @param  {Object} e Event
    	     * @return
    	     */

    	  }, {
    	    key: '_onKeyDown',
    	    value: function _onKeyDown(e) {
    	      var _this16 = this,
    	          _keyDownActions;

    	      if (e.target !== this.input && !this.containerOuter.contains(e.target)) {
    	        return;
    	      }

    	      var target = e.target;
    	      var activeItems = this.store.getItemsFilteredByActive();
    	      var hasFocusedInput = this.input === document.activeElement;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	      var hasItems = this.itemList && this.itemList.children;
    	      var keyString = String.fromCharCode(e.keyCode);

    	      var backKey = 46;
    	      var deleteKey = 8;
    	      var enterKey = 13;
    	      var aKey = 65;
    	      var escapeKey = 27;
    	      var upKey = 38;
    	      var downKey = 40;
    	      var pageUpKey = 33;
    	      var pageDownKey = 34;
    	      var ctrlDownKey = e.ctrlKey || e.metaKey;

    	      // If a user is typing and the dropdown is not active
    	      if (!this.isTextElement && /[a-zA-Z0-9-_ ]/.test(keyString) && !hasActiveDropdown) {
    	        this.showDropdown(true);
    	      }

    	      this.canSearch = this.config.searchEnabled;

    	      var onAKey = function onAKey() {
    	        // If CTRL + A or CMD + A have been pressed and there are items to select
    	        if (ctrlDownKey && hasItems) {
    	          _this16.canSearch = false;
    	          if (_this16.config.removeItems && !_this16.input.value && _this16.input === document.activeElement) {
    	            // Highlight items
    	            _this16.highlightAll();
    	          }
    	        }
    	      };

    	      var onEnterKey = function onEnterKey() {
    	        // If enter key is pressed and the input has a value
    	        if (_this16.isTextElement && target.value) {
    	          var value = _this16.input.value;
    	          var canAddItem = _this16._canAddItem(activeItems, value);

    	          // All is good, add
    	          if (canAddItem.response) {
    	            if (hasActiveDropdown) {
    	              _this16.hideDropdown();
    	            }
    	            _this16._addItem(value);
    	            _this16._triggerChange(value);
    	            _this16.clearInput();
    	          }
    	        }

    	        if (target.hasAttribute('data-button')) {
    	          _this16._handleButtonAction(activeItems, target);
    	          e.preventDefault();
    	        }

    	        if (hasActiveDropdown) {
    	          e.preventDefault();
    	          var highlighted = _this16.dropdown.querySelector('.' + _this16.config.classNames.highlightedState);

    	          // If we have a highlighted choice
    	          if (highlighted) {
    	            // add enter keyCode value
    	            if (activeItems[0]) {
    	              activeItems[0].keyCode = enterKey;
    	            }
    	            _this16._handleChoiceAction(activeItems, highlighted);
    	          }
    	        } else if (_this16.isSelectOneElement) {
    	          // Open single select dropdown if it's not active
    	          if (!hasActiveDropdown) {
    	            _this16.showDropdown(true);
    	            e.preventDefault();
    	          }
    	        }
    	      };

    	      var onEscapeKey = function onEscapeKey() {
    	        if (hasActiveDropdown) {
    	          _this16.toggleDropdown();
    	          _this16.containerOuter.focus();
    	        }
    	      };

    	      var onDirectionKey = function onDirectionKey() {
    	        // If up or down key is pressed, traverse through options
    	        if (hasActiveDropdown || _this16.isSelectOneElement) {
    	          // Show dropdown if focus
    	          if (!hasActiveDropdown) {
    	            _this16.showDropdown(true);
    	          }

    	          _this16.canSearch = false;

    	          var directionInt = e.keyCode === downKey || e.keyCode === pageDownKey ? 1 : -1;
    	          var skipKey = e.metaKey || e.keyCode === pageDownKey || e.keyCode === pageUpKey;

    	          var nextEl = void 0;
    	          if (skipKey) {
    	            if (directionInt > 0) {
    	              nextEl = Array.from(_this16.dropdown.querySelectorAll('[data-choice-selectable]')).pop();
    	            } else {
    	              nextEl = _this16.dropdown.querySelector('[data-choice-selectable]');
    	            }
    	          } else {
    	            var currentEl = _this16.dropdown.querySelector('.' + _this16.config.classNames.highlightedState);
    	            if (currentEl) {
    	              nextEl = (0, _utils.getAdjacentEl)(currentEl, '[data-choice-selectable]', directionInt);
    	            } else {
    	              nextEl = _this16.dropdown.querySelector('[data-choice-selectable]');
    	            }
    	          }

    	          if (nextEl) {
    	            // We prevent default to stop the cursor moving
    	            // when pressing the arrow
    	            if (!(0, _utils.isScrolledIntoView)(nextEl, _this16.choiceList, directionInt)) {
    	              _this16._scrollToChoice(nextEl, directionInt);
    	            }
    	            _this16._highlightChoice(nextEl);
    	          }

    	          // Prevent default to maintain cursor position whilst
    	          // traversing dropdown options
    	          e.preventDefault();
    	        }
    	      };

    	      var onDeleteKey = function onDeleteKey() {
    	        // If backspace or delete key is pressed and the input has no value
    	        if (hasFocusedInput && !e.target.value && !_this16.isSelectOneElement) {
    	          _this16._handleBackspace(activeItems);
    	          e.preventDefault();
    	        }
    	      };

    	      // Map keys to key actions
    	      var keyDownActions = (_keyDownActions = {}, _defineProperty(_keyDownActions, aKey, onAKey), _defineProperty(_keyDownActions, enterKey, onEnterKey), _defineProperty(_keyDownActions, escapeKey, onEscapeKey), _defineProperty(_keyDownActions, upKey, onDirectionKey), _defineProperty(_keyDownActions, pageUpKey, onDirectionKey), _defineProperty(_keyDownActions, downKey, onDirectionKey), _defineProperty(_keyDownActions, pageDownKey, onDirectionKey), _defineProperty(_keyDownActions, deleteKey, onDeleteKey), _defineProperty(_keyDownActions, backKey, onDeleteKey), _keyDownActions);

    	      // If keycode has a function, run it
    	      if (keyDownActions[e.keyCode]) {
    	        keyDownActions[e.keyCode]();
    	      }
    	    }

    	    /**
    	     * Key up event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onKeyUp',
    	    value: function _onKeyUp(e) {
    	      if (e.target !== this.input) {
    	        return;
    	      }

    	      var value = this.input.value;
    	      var activeItems = this.store.getItemsFilteredByActive();
    	      var canAddItem = this._canAddItem(activeItems, value);

    	      // We are typing into a text input and have a value, we want to show a dropdown
    	      // notice. Otherwise hide the dropdown
    	      if (this.isTextElement) {
    	        var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	        if (value) {

    	          if (canAddItem.notice) {
    	            var dropdownItem = this._getTemplate('notice', canAddItem.notice);
    	            this.dropdown.innerHTML = dropdownItem.outerHTML;
    	          }

    	          if (canAddItem.response === true) {
    	            if (!hasActiveDropdown) {
    	              this.showDropdown();
    	            }
    	          } else if (!canAddItem.notice && hasActiveDropdown) {
    	            this.hideDropdown();
    	          }
    	        } else if (hasActiveDropdown) {
    	          this.hideDropdown();
    	        }
    	      } else {
    	        var backKey = 46;
    	        var deleteKey = 8;

    	        // If user has removed value...
    	        if ((e.keyCode === backKey || e.keyCode === deleteKey) && !e.target.value) {
    	          // ...and it is a multiple select input, activate choices (if searching)
    	          if (!this.isTextElement && this.isSearching) {
    	            this.isSearching = false;
    	            this.store.dispatch((0, _index3.activateChoices)(true));
    	          }
    	        } else if (this.canSearch && canAddItem.response) {
    	          this._handleSearch(this.input.value);
    	        }
    	      }
    	      // Re-establish canSearch value from changes in _onKeyDown
    	      this.canSearch = this.config.searchEnabled;
    	    }

    	    /**
    	     * Input event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onInput',
    	    value: function _onInput() {
    	      if (!this.isSelectOneElement) {
    	        this._setInputWidth();
    	      }
    	    }

    	    /**
    	     * Touch move event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onTouchMove',
    	    value: function _onTouchMove() {
    	      if (this.wasTap === true) {
    	        this.wasTap = false;
    	      }
    	    }

    	    /**
    	     * Touch end event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onTouchEnd',
    	    value: function _onTouchEnd(e) {
    	      var target = e.target || e.touches[0].target;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);

    	      // If a user tapped within our container...
    	      if (this.wasTap === true && this.containerOuter.contains(target)) {
    	        // ...and we aren't dealing with a single select box, show dropdown/focus input
    	        if ((target === this.containerOuter || target === this.containerInner) && !this.isSelectOneElement) {
    	          if (this.isTextElement) {
    	            // If text element, we only want to focus the input (if it isn't already)
    	            if (document.activeElement !== this.input) {
    	              this.input.focus();
    	            }
    	          } else {
    	            if (!hasActiveDropdown) {
    	              // If a select box, we want to show the dropdown
    	              this.showDropdown(true);
    	            }
    	          }
    	        }
    	        // Prevents focus event firing
    	        e.stopPropagation();
    	      }

    	      this.wasTap = true;
    	    }

    	    /**
    	     * Mouse down event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onMouseDown',
    	    value: function _onMouseDown(e) {
    	      var target = e.target;

    	      // If we have our mouse down on the scrollbar and are on IE11...
    	      if (target === this.choiceList && this.isIe11) {
    	        this.isScrollingOnIe = true;
    	      }

    	      if (this.containerOuter.contains(target) && target !== this.input) {
    	        var foundTarget = void 0;
    	        var activeItems = this.store.getItemsFilteredByActive();
    	        var hasShiftKey = e.shiftKey;

    	        if (foundTarget = (0, _utils.findAncestorByAttrName)(target, 'data-button')) {
    	          this._handleButtonAction(activeItems, foundTarget);
    	        } else if (foundTarget = (0, _utils.findAncestorByAttrName)(target, 'data-item')) {
    	          this._handleItemAction(activeItems, foundTarget, hasShiftKey);
    	        } else if (foundTarget = (0, _utils.findAncestorByAttrName)(target, 'data-choice')) {
    	          this._handleChoiceAction(activeItems, foundTarget);
    	        }

    	        e.preventDefault();
    	      }
    	    }

    	    /**
    	     * Click event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onClick',
    	    value: function _onClick(e) {
    	      var target = e.target;
    	      var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	      var activeItems = this.store.getItemsFilteredByActive();

    	      // If target is something that concerns us
    	      if (this.containerOuter.contains(target)) {
    	        // Handle button delete
    	        if (target.hasAttribute('data-button')) {
    	          this._handleButtonAction(activeItems, target);
    	        }

    	        if (!hasActiveDropdown) {
    	          if (this.isTextElement) {
    	            if (document.activeElement !== this.input) {
    	              this.input.focus();
    	            }
    	          } else {
    	            if (this.canSearch) {
    	              this.showDropdown(true);
    	            } else {
    	              this.showDropdown();
    	              this.containerOuter.focus();
    	            }
    	          }
    	        } else if (this.isSelectOneElement && target !== this.input && !this.dropdown.contains(target)) {
    	          this.hideDropdown(true);
    	        }
    	      } else {
    	        var hasHighlightedItems = activeItems.some(function (item) {
    	          return item.highlighted;
    	        });

    	        // De-select any highlighted items
    	        if (hasHighlightedItems) {
    	          this.unhighlightAll();
    	        }

    	        // Remove focus state
    	        this.containerOuter.classList.remove(this.config.classNames.focusState);

    	        // Close all other dropdowns
    	        if (hasActiveDropdown) {
    	          this.hideDropdown();
    	        }
    	      }
    	    }

    	    /**
    	     * Mouse over (hover) event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onMouseOver',
    	    value: function _onMouseOver(e) {
    	      // If the dropdown is either the target or one of its children is the target
    	      if (e.target === this.dropdown || this.dropdown.contains(e.target)) {
    	        if (e.target.hasAttribute('data-choice')) this._highlightChoice(e.target);
    	      }
    	    }

    	    /**
    	     * Paste event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onPaste',
    	    value: function _onPaste(e) {
    	      // Disable pasting into the input if option has been set
    	      if (e.target === this.input && !this.config.paste) {
    	        e.preventDefault();
    	      }
    	    }

    	    /**
    	     * Focus event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onFocus',
    	    value: function _onFocus(e) {
    	      var _this17 = this;

    	      var target = e.target;
    	      // If target is something that concerns us
    	      if (this.containerOuter.contains(target)) {
    	        var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	        var focusActions = {
    	          text: function text() {
    	            if (target === _this17.input) {
    	              _this17.containerOuter.classList.add(_this17.config.classNames.focusState);
    	            }
    	          },
    	          'select-one': function selectOne() {
    	            _this17.containerOuter.classList.add(_this17.config.classNames.focusState);
    	            if (target === _this17.input) {
    	              // Show dropdown if it isn't already showing
    	              if (!hasActiveDropdown) {
    	                _this17.showDropdown();
    	              }
    	            }
    	          },
    	          'select-multiple': function selectMultiple() {
    	            if (target === _this17.input) {
    	              // If element is a select box, the focused element is the container and the dropdown
    	              // isn't already open, focus and show dropdown
    	              _this17.containerOuter.classList.add(_this17.config.classNames.focusState);

    	              if (!hasActiveDropdown) {
    	                _this17.showDropdown(true);
    	              }
    	            }
    	          }
    	        };

    	        focusActions[this.passedElement.type]();
    	      }
    	    }

    	    /**
    	     * Blur event
    	     * @param  {Object} e Event
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_onBlur',
    	    value: function _onBlur(e) {
    	      var _this18 = this;

    	      var target = e.target;
    	      // If target is something that concerns us
    	      if (this.containerOuter.contains(target) && !this.isScrollingOnIe) {
    	        var activeItems = this.store.getItemsFilteredByActive();
    	        var hasActiveDropdown = this.dropdown.classList.contains(this.config.classNames.activeState);
    	        var hasHighlightedItems = activeItems.some(function (item) {
    	          return item.highlighted;
    	        });
    	        var blurActions = {
    	          text: function text() {
    	            if (target === _this18.input) {
    	              // Remove the focus state
    	              _this18.containerOuter.classList.remove(_this18.config.classNames.focusState);
    	              // De-select any highlighted items
    	              if (hasHighlightedItems) {
    	                _this18.unhighlightAll();
    	              }
    	              // Hide dropdown if it is showing
    	              if (hasActiveDropdown) {
    	                _this18.hideDropdown();
    	              }
    	            }
    	          },
    	          'select-one': function selectOne() {
    	            _this18.containerOuter.classList.remove(_this18.config.classNames.focusState);
    	            if (target === _this18.containerOuter) {
    	              // Hide dropdown if it is showing
    	              if (hasActiveDropdown && !_this18.canSearch) {
    	                _this18.hideDropdown();
    	              }
    	            }
    	            if (target === _this18.input && hasActiveDropdown) {
    	              // Hide dropdown if it is showing
    	              _this18.hideDropdown();
    	            }
    	          },
    	          'select-multiple': function selectMultiple() {
    	            if (target === _this18.input) {
    	              // Remove the focus state
    	              _this18.containerOuter.classList.remove(_this18.config.classNames.focusState);
    	              // Hide dropdown if it is showing
    	              if (hasActiveDropdown) {
    	                _this18.hideDropdown();
    	              }
    	              // De-select any highlighted items
    	              if (hasHighlightedItems) {
    	                _this18.unhighlightAll();
    	              }
    	            }
    	          }
    	        };

    	        blurActions[this.passedElement.type]();
    	      } else {
    	        // On IE11, clicking the scollbar blurs our input and thus
    	        // closes the dropdown. To stop this, we refocus our input
    	        // if we know we are on IE *and* are scrolling.
    	        this.isScrollingOnIe = false;
    	        this.input.focus();
    	      }
    	    }

    	    /**
    	     * Tests value against a regular expression
    	     * @param  {string} value   Value to test
    	     * @return {Boolean}        Whether test passed/failed
    	     * @private
    	     */

    	  }, {
    	    key: '_regexFilter',
    	    value: function _regexFilter(value) {
    	      if (!value) {
    	        return false;
    	      }

    	      var regex = this.config.regexFilter;
    	      var expression = new RegExp(regex.source, 'i');
    	      return expression.test(value);
    	    }

    	    /**
    	     * Scroll to an option element
    	     * @param  {HTMLElement} choice  Option to scroll to
    	     * @param  {Number} direction  Whether option is above or below
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_scrollToChoice',
    	    value: function _scrollToChoice(choice, direction) {
    	      var _this19 = this;

    	      if (!choice) {
    	        return;
    	      }

    	      var dropdownHeight = this.choiceList.offsetHeight;
    	      var choiceHeight = choice.offsetHeight;
    	      // Distance from bottom of element to top of parent
    	      var choicePos = choice.offsetTop + choiceHeight;
    	      // Scroll position of dropdown
    	      var containerScrollPos = this.choiceList.scrollTop + dropdownHeight;
    	      // Difference between the choice and scroll position
    	      var endPoint = direction > 0 ? this.choiceList.scrollTop + choicePos - containerScrollPos : choice.offsetTop;

    	      var animateScroll = function animateScroll() {
    	        var strength = 4;
    	        var choiceListScrollTop = _this19.choiceList.scrollTop;
    	        var continueAnimation = false;
    	        var easing = void 0;
    	        var distance = void 0;

    	        if (direction > 0) {
    	          easing = (endPoint - choiceListScrollTop) / strength;
    	          distance = easing > 1 ? easing : 1;

    	          _this19.choiceList.scrollTop = choiceListScrollTop + distance;
    	          if (choiceListScrollTop < endPoint) {
    	            continueAnimation = true;
    	          }
    	        } else {
    	          easing = (choiceListScrollTop - endPoint) / strength;
    	          distance = easing > 1 ? easing : 1;

    	          _this19.choiceList.scrollTop = choiceListScrollTop - distance;
    	          if (choiceListScrollTop > endPoint) {
    	            continueAnimation = true;
    	          }
    	        }

    	        if (continueAnimation) {
    	          requestAnimationFrame(function (time) {
    	            animateScroll(time, endPoint, direction);
    	          });
    	        }
    	      };

    	      requestAnimationFrame(function (time) {
    	        animateScroll(time, endPoint, direction);
    	      });
    	    }

    	    /**
    	     * Highlight choice
    	     * @param  {HTMLElement} [el] Element to highlight
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_highlightChoice',
    	    value: function _highlightChoice() {
    	      var _this20 = this;

    	      var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    	      // Highlight first element in dropdown
    	      var choices = Array.from(this.dropdown.querySelectorAll('[data-choice-selectable]'));
    	      var passedEl = el;

    	      if (choices && choices.length) {
    	        var highlightedChoices = Array.from(this.dropdown.querySelectorAll('.' + this.config.classNames.highlightedState));

    	        // Remove any highlighted choices
    	        highlightedChoices.forEach(function (choice) {
    	          choice.classList.remove(_this20.config.classNames.highlightedState);
    	          choice.setAttribute('aria-selected', 'false');
    	        });

    	        if (passedEl) {
    	          this.highlightPosition = choices.indexOf(passedEl);
    	        } else {
    	          // Highlight choice based on last known highlight location
    	          if (choices.length > this.highlightPosition) {
    	            // If we have an option to highlight
    	            passedEl = choices[this.highlightPosition];
    	          } else {
    	            // Otherwise highlight the option before
    	            passedEl = choices[choices.length - 1];
    	          }

    	          if (!passedEl) {
    	            passedEl = choices[0];
    	          }
    	        }

    	        // Highlight given option, and set accessiblity attributes
    	        passedEl.classList.add(this.config.classNames.highlightedState);
    	        passedEl.setAttribute('aria-selected', 'true');
    	        this.containerOuter.setAttribute('aria-activedescendant', passedEl.id);
    	      }
    	    }

    	    /**
    	     * Add item to store with correct value
    	     * @param {String} value Value to add to store
    	     * @param {String} [label] Label to add to store
    	     * @param {Number} [choiceId=-1] ID of the associated choice that was selected
    	     * @param {Number} [groupId=-1] ID of group choice is within. Negative number indicates no group
    	     * @param {Object} [customProperties] Object containing user defined properties
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: '_addItem',
    	    value: function _addItem(value) {
    	      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    	      var choiceId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    	      var groupId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
    	      var customProperties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    	      var placeholder = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    	      var keyCode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

    	      var passedValue = (0, _utils.isType)('String', value) ? value.trim() : value;
    	      var passedKeyCode = keyCode;
    	      var items = this.store.getItems();
    	      var passedLabel = label || passedValue;
    	      var passedOptionId = parseInt(choiceId, 10) || -1;

    	      // Get group if group ID passed
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      // Generate unique id
    	      var id = items ? items.length + 1 : 1;

    	      // If a prepended value has been passed, prepend it
    	      if (this.config.prependValue) {
    	        passedValue = this.config.prependValue + passedValue.toString();
    	      }

    	      // If an appended value has been passed, append it
    	      if (this.config.appendValue) {
    	        passedValue += this.config.appendValue.toString();
    	      }

    	      this.store.dispatch((0, _index3.addItem)(passedValue, passedLabel, id, passedOptionId, groupId, customProperties, placeholder, passedKeyCode));

    	      if (this.isSelectOneElement) {
    	        this.removeActiveItems(id);
    	      }

    	      // Trigger change event
    	      if (group && group.value) {
    	        (0, _utils.triggerEvent)(this.passedElement, 'addItem', {
    	          id: id,
    	          value: passedValue,
    	          label: passedLabel,
    	          groupValue: group.value,
    	          keyCode: passedKeyCode
    	        });
    	      } else {
    	        (0, _utils.triggerEvent)(this.passedElement, 'addItem', {
    	          id: id,
    	          value: passedValue,
    	          label: passedLabel,
    	          keyCode: passedKeyCode
    	        });
    	      }

    	      return this;
    	    }

    	    /**
    	     * Remove item from store
    	     * @param {Object} item Item to remove
    	     * @return {Object} Class instance
    	     * @public
    	     */

    	  }, {
    	    key: '_removeItem',
    	    value: function _removeItem(item) {
    	      if (!item || !(0, _utils.isType)('Object', item)) {
    	        return this;
    	      }

    	      var id = item.id;
    	      var value = item.value;
    	      var label = item.label;
    	      var choiceId = item.choiceId;
    	      var groupId = item.groupId;
    	      var group = groupId >= 0 ? this.store.getGroupById(groupId) : null;

    	      this.store.dispatch((0, _index3.removeItem)(id, choiceId));

    	      if (group && group.value) {
    	        (0, _utils.triggerEvent)(this.passedElement, 'removeItem', {
    	          id: id,
    	          value: value,
    	          label: label,
    	          groupValue: group.value
    	        });
    	      } else {
    	        (0, _utils.triggerEvent)(this.passedElement, 'removeItem', {
    	          id: id,
    	          value: value,
    	          label: label
    	        });
    	      }

    	      return this;
    	    }

    	    /**
    	     * Add choice to dropdown
    	     * @param {String} value Value of choice
    	     * @param {String} [label] Label of choice
    	     * @param {Boolean} [isSelected=false] Whether choice is selected
    	     * @param {Boolean} [isDisabled=false] Whether choice is disabled
    	     * @param {Number} [groupId=-1] ID of group choice is within. Negative number indicates no group
    	     * @param {Object} [customProperties] Object containing user defined properties
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_addChoice',
    	    value: function _addChoice(value) {
    	      var label = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    	      var isSelected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    	      var isDisabled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    	      var groupId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
    	      var customProperties = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    	      var placeholder = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    	      var keyCode = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

    	      if (typeof value === 'undefined' || value === null) {
    	        return;
    	      }

    	      // Generate unique id
    	      var choices = this.store.getChoices();
    	      var choiceLabel = label || value;
    	      var choiceId = choices ? choices.length + 1 : 1;
    	      var choiceElementId = this.baseId + '-' + this.idNames.itemChoice + '-' + choiceId;

    	      this.store.dispatch((0, _index3.addChoice)(value, choiceLabel, choiceId, groupId, isDisabled, choiceElementId, customProperties, placeholder, keyCode));

    	      if (isSelected) {
    	        this._addItem(value, choiceLabel, choiceId, undefined, customProperties, placeholder, keyCode);
    	      }
    	    }

    	    /**
    	     * Clear all choices added to the store.
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_clearChoices',
    	    value: function _clearChoices() {
    	      this.store.dispatch((0, _index3.clearChoices)());
    	    }

    	    /**
    	     * Add group to dropdown
    	     * @param {Object} group Group to add
    	     * @param {Number} id Group ID
    	     * @param {String} [valueKey] name of the value property on the object
    	     * @param {String} [labelKey] name of the label property on the object
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_addGroup',
    	    value: function _addGroup(group, id) {
    	      var _this21 = this;

    	      var valueKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'value';
    	      var labelKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'label';

    	      var groupChoices = (0, _utils.isType)('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));
    	      var groupId = id ? id : Math.floor(new Date().valueOf() * Math.random());
    	      var isDisabled = group.disabled ? group.disabled : false;

    	      if (groupChoices) {
    	        this.store.dispatch((0, _index3.addGroup)(group.label, groupId, true, isDisabled));

    	        groupChoices.forEach(function (option) {
    	          var isOptDisabled = option.disabled || option.parentNode && option.parentNode.disabled;
    	          _this21._addChoice(option[valueKey], (0, _utils.isType)('Object', option) ? option[labelKey] : option.innerHTML, option.selected, isOptDisabled, groupId, option.customProperties, option.placeholder);
    	        });
    	      } else {
    	        this.store.dispatch((0, _index3.addGroup)(group.label, group.id, false, group.disabled));
    	      }
    	    }

    	    /**
    	     * Get template from name
    	     * @param  {String}    template Name of template to get
    	     * @param  {...}       args     Data to pass to template
    	     * @return {HTMLElement}        Template
    	     * @private
    	     */

    	  }, {
    	    key: '_getTemplate',
    	    value: function _getTemplate(template) {
    	      if (!template) {
    	        return null;
    	      }
    	      var templates = this.config.templates;

    	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    	        args[_key - 1] = arguments[_key];
    	      }

    	      return templates[template].apply(templates, args);
    	    }

    	    /**
    	     * Create HTML element based on type and arguments
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_createTemplates',
    	    value: function _createTemplates() {
    	      var _this22 = this;

    	      var globalClasses = this.config.classNames;
    	      var templates = {
    	        containerOuter: function containerOuter(direction) {
    	          return (0, _utils.strToEl)('\n          <div\n            class="' + globalClasses.containerOuter + '"\n            ' + (_this22.isSelectElement ? _this22.config.searchEnabled ? 'role="combobox" aria-autocomplete="list"' : 'role="listbox"' : '') + '\n            data-type="' + _this22.passedElement.type + '"\n            ' + (_this22.isSelectOneElement ? 'tabindex="0"' : '') + '\n            aria-haspopup="true"\n            aria-expanded="false"\n            dir="' + direction + '"\n            >\n          </div>\n        ');
    	        },
    	        containerInner: function containerInner() {
    	          return (0, _utils.strToEl)('\n          <div class="' + globalClasses.containerInner + '"></div>\n        ');
    	        },
    	        itemList: function itemList() {
    	          var _classNames;

    	          var localClasses = (0, _classnames2.default)(globalClasses.list, (_classNames = {}, _defineProperty(_classNames, globalClasses.listSingle, _this22.isSelectOneElement), _defineProperty(_classNames, globalClasses.listItems, !_this22.isSelectOneElement), _classNames));

    	          return (0, _utils.strToEl)('\n          <div class="' + localClasses + '"></div>\n        ');
    	        },
    	        placeholder: function placeholder(value) {
    	          return (0, _utils.strToEl)('\n          <div class="' + globalClasses.placeholder + '">\n            ' + value + '\n          </div>\n        ');
    	        },
    	        item: function item(data) {
    	          var _classNames2;

    	          var localClasses = (0, _classnames2.default)(globalClasses.item, (_classNames2 = {}, _defineProperty(_classNames2, globalClasses.highlightedState, data.highlighted), _defineProperty(_classNames2, globalClasses.itemSelectable, !data.highlighted), _defineProperty(_classNames2, globalClasses.placeholder, data.placeholder), _classNames2));

    	          if (_this22.config.removeItemButton) {
    	            var _classNames3;

    	            localClasses = (0, _classnames2.default)(globalClasses.item, (_classNames3 = {}, _defineProperty(_classNames3, globalClasses.highlightedState, data.highlighted), _defineProperty(_classNames3, globalClasses.itemSelectable, !data.disabled), _defineProperty(_classNames3, globalClasses.placeholder, data.placeholder), _classNames3));

    	            return (0, _utils.strToEl)('\n            <div\n              class="' + localClasses + '"\n              data-item\n              data-id="' + data.id + '"\n              data-value="' + data.value + '"\n              data-deletable\n              ' + (data.active ? 'aria-selected="true"' : '') + '\n              ' + (data.disabled ? 'aria-disabled="true"' : '') + '\n              >\n              ' + data.label + '<!--\n           --><button\n                type="button"\n                class="' + globalClasses.button + '"\n                data-button\n                aria-label="Remove item: \'' + data.value + '\'"\n                >\n                Remove item\n              </button>\n            </div>\n          ');
    	          }

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            data-item\n            data-id="' + data.id + '"\n            data-value="' + data.value + '"\n            ' + (data.active ? 'aria-selected="true"' : '') + '\n            ' + (data.disabled ? 'aria-disabled="true"' : '') + '\n            >\n            ' + data.label + '\n          </div>\n        ');
    	        },
    	        choiceList: function choiceList() {
    	          return (0, _utils.strToEl)('\n          <div\n            class="' + globalClasses.list + '"\n            dir="ltr"\n            role="listbox"\n            ' + (!_this22.isSelectOneElement ? 'aria-multiselectable="true"' : '') + '\n            >\n          </div>\n        ');
    	        },
    	        choiceGroup: function choiceGroup(data) {
    	          var localClasses = (0, _classnames2.default)(globalClasses.group, _defineProperty({}, globalClasses.itemDisabled, data.disabled));

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            data-group\n            data-id="' + data.id + '"\n            data-value="' + data.value + '"\n            role="group"\n            ' + (data.disabled ? 'aria-disabled="true"' : '') + '\n            >\n            <div class="' + globalClasses.groupHeading + '">' + data.value + '</div>\n          </div>\n        ');
    	        },
    	        choice: function choice(data) {
    	          var _classNames5;

    	          var localClasses = (0, _classnames2.default)(globalClasses.item, globalClasses.itemChoice, (_classNames5 = {}, _defineProperty(_classNames5, globalClasses.itemDisabled, data.disabled), _defineProperty(_classNames5, globalClasses.itemSelectable, !data.disabled), _defineProperty(_classNames5, globalClasses.placeholder, data.placeholder), _classNames5));

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            data-select-text="' + _this22.config.itemSelectText + '"\n            data-choice\n            data-id="' + data.id + '"\n            data-value="' + data.value + '"\n            ' + (data.disabled ? 'data-choice-disabled aria-disabled="true"' : 'data-choice-selectable') + '\n            id="' + data.elementId + '"\n            ' + (data.groupId > 0 ? 'role="treeitem"' : 'role="option"') + '\n            >\n            ' + data.label + '\n          </div>\n        ');
    	        },
    	        input: function input() {
    	          var localClasses = (0, _classnames2.default)(globalClasses.input, globalClasses.inputCloned);

    	          return (0, _utils.strToEl)('\n          <input\n            type="text"\n            class="' + localClasses + '"\n            autocomplete="off"\n            autocapitalize="off"\n            spellcheck="false"\n            role="textbox"\n            aria-autocomplete="list"\n            >\n        ');
    	        },
    	        dropdown: function dropdown() {
    	          var localClasses = (0, _classnames2.default)(globalClasses.list, globalClasses.listDropdown);

    	          return (0, _utils.strToEl)('\n          <div\n            class="' + localClasses + '"\n            aria-expanded="false"\n            >\n          </div>\n        ');
    	        },
    	        notice: function notice(label) {
    	          var _classNames6;

    	          var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    	          var localClasses = (0, _classnames2.default)(globalClasses.item, globalClasses.itemChoice, (_classNames6 = {}, _defineProperty(_classNames6, globalClasses.noResults, type === 'no-results'), _defineProperty(_classNames6, globalClasses.noChoices, type === 'no-choices'), _classNames6));

    	          return (0, _utils.strToEl)('\n          <div class="' + localClasses + '">\n            ' + label + '\n          </div>\n        ');
    	        },
    	        option: function option(data) {
    	          return (0, _utils.strToEl)('\n          <option value="' + data.value + '" selected>' + data.label + '</option>\n        ');
    	        }
    	      };

    	      // User's custom templates
    	      var callbackTemplate = this.config.callbackOnCreateTemplates;
    	      var userTemplates = {};
    	      if (callbackTemplate && (0, _utils.isType)('Function', callbackTemplate)) {
    	        userTemplates = callbackTemplate.call(this, _utils.strToEl);
    	      }

    	      this.config.templates = (0, _utils.extend)(templates, userTemplates);
    	    }
    	  }, {
    	    key: '_setLoading',
    	    value: function _setLoading(isLoading) {
    	      this.store.dispatch((0, _index3.setIsLoading)(isLoading));
    	    }

    	    /**
    	     * Create DOM structure around passed select element
    	     * @return
    	     * @private
    	     */

    	  }, {
    	    key: '_createInput',
    	    value: function _createInput() {
    	      var _this23 = this;

    	      var direction = this.passedElement.getAttribute('dir') || 'ltr';
    	      var containerOuter = this._getTemplate('containerOuter', direction);
    	      var containerInner = this._getTemplate('containerInner');
    	      var itemList = this._getTemplate('itemList');
    	      var choiceList = this._getTemplate('choiceList');
    	      var input = this._getTemplate('input');
    	      var dropdown = this._getTemplate('dropdown');

    	      this.containerOuter = containerOuter;
    	      this.containerInner = containerInner;
    	      this.input = input;
    	      this.choiceList = choiceList;
    	      this.itemList = itemList;
    	      this.dropdown = dropdown;

    	      // Hide passed input
    	      this.passedElement.classList.add(this.config.classNames.input, this.config.classNames.hiddenState);

    	      // Remove element from tab index
    	      this.passedElement.tabIndex = '-1';

    	      // Backup original styles if any
    	      var origStyle = this.passedElement.getAttribute('style');

    	      if (Boolean(origStyle)) {
    	        this.passedElement.setAttribute('data-choice-orig-style', origStyle);
    	      }

    	      this.passedElement.setAttribute('style', 'display:none;');
    	      this.passedElement.setAttribute('aria-hidden', 'true');
    	      this.passedElement.setAttribute('data-choice', 'active');

    	      // Wrap input in container preserving DOM ordering
    	      (0, _utils.wrap)(this.passedElement, containerInner);

    	      // Wrapper inner container with outer container
    	      (0, _utils.wrap)(containerInner, containerOuter);

    	      if (this.isSelectOneElement) {
    	        input.placeholder = this.config.searchPlaceholderValue || '';
    	      } else if (this.placeholder) {
    	        input.placeholder = this.placeholder;
    	        input.style.width = (0, _utils.getWidthOfInput)(input);
    	      }

    	      if (!this.config.addItems) {
    	        this.disable();
    	      }

    	      containerOuter.appendChild(containerInner);
    	      containerOuter.appendChild(dropdown);
    	      containerInner.appendChild(itemList);

    	      if (!this.isTextElement) {
    	        dropdown.appendChild(choiceList);
    	      }

    	      if (this.isSelectMultipleElement || this.isTextElement) {
    	        containerInner.appendChild(input);
    	      } else if (this.canSearch) {
    	        dropdown.insertBefore(input, dropdown.firstChild);
    	      }

    	      if (this.isSelectElement) {
    	        var passedGroups = Array.from(this.passedElement.getElementsByTagName('OPTGROUP'));

    	        this.highlightPosition = 0;
    	        this.isSearching = false;

    	        this._setLoading(true);

    	        if (passedGroups && passedGroups.length) {
    	          passedGroups.forEach(function (group) {
    	            _this23._addGroup(group, group.id || null);
    	          });
    	        } else {
    	          var passedOptions = Array.from(this.passedElement.options);
    	          var filter = this.config.sortFilter;
    	          var allChoices = this.presetChoices;

    	          // Create array of options from option elements
    	          passedOptions.forEach(function (o) {
    	            allChoices.push({
    	              value: o.value,
    	              label: o.innerHTML,
    	              selected: o.selected,
    	              disabled: o.disabled || o.parentNode.disabled,
    	              placeholder: o.hasAttribute('placeholder')
    	            });
    	          });

    	          // If sorting is enabled or the user is searching, filter choices
    	          if (this.config.shouldSort) {
    	            allChoices.sort(filter);
    	          }

    	          // Determine whether there is a selected choice
    	          var hasSelectedChoice = allChoices.some(function (choice) {
    	            return choice.selected;
    	          });

    	          // Add each choice
    	          allChoices.forEach(function (choice, index) {
    	            // Pre-select first choice if it's a single select
    	            if (_this23.isSelectOneElement) {
    	              // If there is a selected choice already or the choice is not
    	              // the first in the array, add each choice normally
    	              // Otherwise pre-select the first choice in the array
    	              var shouldPreselect = hasSelectedChoice || !hasSelectedChoice && index > 0;
    	              _this23._addChoice(choice.value, choice.label, shouldPreselect ? choice.selected : true, shouldPreselect ? choice.disabled : false, undefined, choice.customProperties, choice.placeholder);
    	            } else {
    	              _this23._addChoice(choice.value, choice.label, choice.selected, choice.disabled, undefined, choice.customProperties, choice.placeholder);
    	            }
    	          });
    	        }

    	        this._setLoading(false);
    	      } else if (this.isTextElement) {
    	        // Add any preset values seperated by delimiter
    	        this.presetItems.forEach(function (item) {
    	          var itemType = (0, _utils.getType)(item);
    	          if (itemType === 'Object') {
    	            if (!item.value) {
    	              return;
    	            }
    	            _this23._addItem(item.value, item.label, item.id, undefined, item.customProperties, item.placeholder);
    	          } else if (itemType === 'String') {
    	            _this23._addItem(item);
    	          }
    	        });
    	      }
    	    }

    	    /*=====  End of Private functions  ======*/

    	  }]);

    	  return Choices;
    	}();

    		module.exports = Choices;

    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {
    (function (global) {

    	  /** @type {function(...*)} */
    	  function log () {
    	    console.log.apply(console, arguments);
    	  }

    	  var defaultOptions = {
    	    // The name of the identifier property. If specified, the returned result will be a list
    	    // of the items' dentifiers, otherwise it will be a list of the items.
    	    id: null,

    	    // Indicates whether comparisons should be case sensitive.

    	    caseSensitive: false,

    	    // An array of values that should be included from the searcher's output. When this array
    	    // contains elements, each result in the list will be of the form `{ item: ..., include1: ..., include2: ... }`.
    	    // Values you can include are `score`, `matchedLocations`
    	    include: [],

    	    // Whether to sort the result list, by score
    	    shouldSort: true,

    	    // The search function to use
    	    // Note that the default search function ([[Function]]) must conform to the following API:
    	    //
    	    //  @param pattern The pattern string to search
    	    //  @param options The search option
    	    //  [[Function]].constructor = function(pattern, options)
    	    //
    	    //  @param text: the string to search in for the pattern
    	    //  @return Object in the form of:
    	    //    - isMatch: boolean
    	    //    - score: Int
    	    //  [[Function]].prototype.search = function(text)
    	    searchFn: BitapSearcher,

    	    // Default sort function
    	    sortFn: function (a, b) {
    	      return a.score - b.score
    	    },

    	    // The get function to use when fetching an object's properties.
    	    // The default will search nested paths *ie foo.bar.baz*
    	    getFn: deepValue,

    	    // List of properties that will be searched. This also supports nested properties.
    	    keys: [],

    	    // Will print to the console. Useful for debugging.
    	    verbose: false,

    	    // When true, the search algorithm will search individual words **and** the full string,
    	    // computing the final score as a function of both. Note that when `tokenize` is `true`,
    	    // the `threshold`, `distance`, and `location` are inconsequential for individual tokens.
    	    tokenize: false,

    	    // When true, the result set will only include records that match all tokens. Will only work
    	    // if `tokenize` is also true.
    	    matchAllTokens: false,

    	    // Regex used to separate words when searching. Only applicable when `tokenize` is `true`.
    	    tokenSeparator: / +/g,

    	    // Minimum number of characters that must be matched before a result is considered a match
    	    minMatchCharLength: 1,

    	    // When true, the algorithm continues searching to the end of the input even if a perfect
    	    // match is found before the end of the same input.
    	    findAllMatches: false
    	  };

    	  /**
    	   * @constructor
    	   * @param {!Array} list
    	   * @param {!Object<string, *>} options
    	   */
    	  function Fuse (list, options) {
    	    var key;

    	    this.list = list;
    	    this.options = options = options || {};

    	    for (key in defaultOptions) {
    	      if (!defaultOptions.hasOwnProperty(key)) {
    	        continue;
    	      }
    	      // Add boolean type options
    	      if (typeof defaultOptions[key] === 'boolean') {
    	        this.options[key] = key in options ? options[key] : defaultOptions[key];
    	      // Add all other options
    	      } else {
    	        this.options[key] = options[key] || defaultOptions[key];
    	      }
    	    }
    	  }

    	  Fuse.VERSION = '2.7.3';

    	  /**
    	   * Sets a new list for Fuse to match against.
    	   * @param {!Array} list
    	   * @return {!Array} The newly set list
    	   * @public
    	   */
    	  Fuse.prototype.set = function (list) {
    	    this.list = list;
    	    return list
    	  };

    	  Fuse.prototype.search = function (pattern) {
    	    if (this.options.verbose) log('\nSearch term:', pattern, '\n');

    	    this.pattern = pattern;
    	    this.results = [];
    	    this.resultMap = {};
    	    this._keyMap = null;

    	    this._prepareSearchers();
    	    this._startSearch();
    	    this._computeScore();
    	    this._sort();

    	    var output = this._format();
    	    return output
    	  };

    	  Fuse.prototype._prepareSearchers = function () {
    	    var options = this.options;
    	    var pattern = this.pattern;
    	    var searchFn = options.searchFn;
    	    var tokens = pattern.split(options.tokenSeparator);
    	    var i = 0;
    	    var len = tokens.length;

    	    if (this.options.tokenize) {
    	      this.tokenSearchers = [];
    	      for (; i < len; i++) {
    	        this.tokenSearchers.push(new searchFn(tokens[i], options));
    	      }
    	    }
    	    this.fullSeacher = new searchFn(pattern, options);
    	  };

    	  Fuse.prototype._startSearch = function () {
    	    var options = this.options;
    	    var getFn = options.getFn;
    	    var list = this.list;
    	    var listLen = list.length;
    	    var keys = this.options.keys;
    	    var keysLen = keys.length;
    	    var key;
    	    var weight;
    	    var item = null;
    	    var i;
    	    var j;

    	    // Check the first item in the list, if it's a string, then we assume
    	    // that every item in the list is also a string, and thus it's a flattened array.
    	    if (typeof list[0] === 'string') {
    	      // Iterate over every item
    	      for (i = 0; i < listLen; i++) {
    	        this._analyze('', list[i], i, i);
    	      }
    	    } else {
    	      this._keyMap = {};
    	      // Otherwise, the first item is an Object (hopefully), and thus the searching
    	      // is done on the values of the keys of each item.
    	      // Iterate over every item
    	      for (i = 0; i < listLen; i++) {
    	        item = list[i];
    	        // Iterate over every key
    	        for (j = 0; j < keysLen; j++) {
    	          key = keys[j];
    	          if (typeof key !== 'string') {
    	            weight = (1 - key.weight) || 1;
    	            this._keyMap[key.name] = {
    	              weight: weight
    	            };
    	            if (key.weight <= 0 || key.weight > 1) {
    	              throw new Error('Key weight has to be > 0 and <= 1')
    	            }
    	            key = key.name;
    	          } else {
    	            this._keyMap[key] = {
    	              weight: 1
    	            };
    	          }
    	          this._analyze(key, getFn(item, key, []), item, i);
    	        }
    	      }
    	    }
    	  };

    	  Fuse.prototype._analyze = function (key, text, entity, index) {
    	    var options = this.options;
    	    var words;
    	    var scores;
    	    var exists = false;
    	    var existingResult;
    	    var averageScore;
    	    var finalScore;
    	    var scoresLen;
    	    var mainSearchResult;
    	    var tokenSearcher;
    	    var termScores;
    	    var word;
    	    var tokenSearchResult;
    	    var hasMatchInText;
    	    var checkTextMatches;
    	    var i;
    	    var j;

    	    // Check if the text can be searched
    	    if (text === undefined || text === null) {
    	      return
    	    }

    	    scores = [];

    	    var numTextMatches = 0;

    	    if (typeof text === 'string') {
    	      words = text.split(options.tokenSeparator);

    	      if (options.verbose) log('---------\nKey:', key);

    	      if (this.options.tokenize) {
    	        for (i = 0; i < this.tokenSearchers.length; i++) {
    	          tokenSearcher = this.tokenSearchers[i];

    	          if (options.verbose) log('Pattern:', tokenSearcher.pattern);

    	          termScores = [];
    	          hasMatchInText = false;

    	          for (j = 0; j < words.length; j++) {
    	            word = words[j];
    	            tokenSearchResult = tokenSearcher.search(word);
    	            var obj = {};
    	            if (tokenSearchResult.isMatch) {
    	              obj[word] = tokenSearchResult.score;
    	              exists = true;
    	              hasMatchInText = true;
    	              scores.push(tokenSearchResult.score);
    	            } else {
    	              obj[word] = 1;
    	              if (!this.options.matchAllTokens) {
    	                scores.push(1);
    	              }
    	            }
    	            termScores.push(obj);
    	          }

    	          if (hasMatchInText) {
    	            numTextMatches++;
    	          }

    	          if (options.verbose) log('Token scores:', termScores);
    	        }

    	        averageScore = scores[0];
    	        scoresLen = scores.length;
    	        for (i = 1; i < scoresLen; i++) {
    	          averageScore += scores[i];
    	        }
    	        averageScore = averageScore / scoresLen;

    	        if (options.verbose) log('Token score average:', averageScore);
    	      }

    	      mainSearchResult = this.fullSeacher.search(text);
    	      if (options.verbose) log('Full text score:', mainSearchResult.score);

    	      finalScore = mainSearchResult.score;
    	      if (averageScore !== undefined) {
    	        finalScore = (finalScore + averageScore) / 2;
    	      }

    	      if (options.verbose) log('Score average:', finalScore);

    	      checkTextMatches = (this.options.tokenize && this.options.matchAllTokens) ? numTextMatches >= this.tokenSearchers.length : true;

    	      if (options.verbose) log('Check Matches', checkTextMatches);

    	      // If a match is found, add the item to <rawResults>, including its score
    	      if ((exists || mainSearchResult.isMatch) && checkTextMatches) {
    	        // Check if the item already exists in our results
    	        existingResult = this.resultMap[index];

    	        if (existingResult) {
    	          // Use the lowest score
    	          // existingResult.score, bitapResult.score
    	          existingResult.output.push({
    	            key: key,
    	            score: finalScore,
    	            matchedIndices: mainSearchResult.matchedIndices
    	          });
    	        } else {
    	          // Add it to the raw result list
    	          this.resultMap[index] = {
    	            item: entity,
    	            output: [{
    	              key: key,
    	              score: finalScore,
    	              matchedIndices: mainSearchResult.matchedIndices
    	            }]
    	          };

    	          this.results.push(this.resultMap[index]);
    	        }
    	      }
    	    } else if (isArray(text)) {
    	      for (i = 0; i < text.length; i++) {
    	        this._analyze(key, text[i], entity, index);
    	      }
    	    }
    	  };

    	  Fuse.prototype._computeScore = function () {
    	    var i;
    	    var j;
    	    var keyMap = this._keyMap;
    	    var totalScore;
    	    var output;
    	    var scoreLen;
    	    var score;
    	    var weight;
    	    var results = this.results;
    	    var bestScore;
    	    var nScore;

    	    if (this.options.verbose) log('\n\nComputing score:\n');

    	    for (i = 0; i < results.length; i++) {
    	      totalScore = 0;
    	      output = results[i].output;
    	      scoreLen = output.length;

    	      bestScore = 1;

    	      for (j = 0; j < scoreLen; j++) {
    	        score = output[j].score;
    	        weight = keyMap ? keyMap[output[j].key].weight : 1;

    	        nScore = score * weight;

    	        if (weight !== 1) {
    	          bestScore = Math.min(bestScore, nScore);
    	        } else {
    	          totalScore += nScore;
    	          output[j].nScore = nScore;
    	        }
    	      }

    	      if (bestScore === 1) {
    	        results[i].score = totalScore / scoreLen;
    	      } else {
    	        results[i].score = bestScore;
    	      }

    	      if (this.options.verbose) log(results[i]);
    	    }
    	  };

    	  Fuse.prototype._sort = function () {
    	    var options = this.options;
    	    if (options.shouldSort) {
    	      if (options.verbose) log('\n\nSorting....');
    	      this.results.sort(options.sortFn);
    	    }
    	  };

    	  Fuse.prototype._format = function () {
    	    var options = this.options;
    	    var getFn = options.getFn;
    	    var finalOutput = [];
    	    var i;
    	    var len;
    	    var results = this.results;
    	    var replaceValue;
    	    var getItemAtIndex;
    	    var include = options.include;

    	    if (options.verbose) log('\n\nOutput:\n\n', results);

    	    // Helper function, here for speed-up, which replaces the item with its value,
    	    // if the options specifies it,
    	    replaceValue = options.id ? function (index) {
    	      results[index].item = getFn(results[index].item, options.id, [])[0];
    	    } : function () {};

    	    getItemAtIndex = function (index) {
    	      var record = results[index];
    	      var data;
    	      var j;
    	      var output;
    	      var _item;
    	      var _result;

    	      // If `include` has values, put the item in the result
    	      if (include.length > 0) {
    	        data = {
    	          item: record.item
    	        };
    	        if (include.indexOf('matches') !== -1) {
    	          output = record.output;
    	          data.matches = [];
    	          for (j = 0; j < output.length; j++) {
    	            _item = output[j];
    	            _result = {
    	              indices: _item.matchedIndices
    	            };
    	            if (_item.key) {
    	              _result.key = _item.key;
    	            }
    	            data.matches.push(_result);
    	          }
    	        }

    	        if (include.indexOf('score') !== -1) {
    	          data.score = results[index].score;
    	        }

    	      } else {
    	        data = record.item;
    	      }

    	      return data
    	    };

    	    // From the results, push into a new array only the item identifier (if specified)
    	    // of the entire item.  This is because we don't want to return the <results>,
    	    // since it contains other metadata
    	    for (i = 0, len = results.length; i < len; i++) {
    	      replaceValue(i);
    	      finalOutput.push(getItemAtIndex(i));
    	    }

    	    return finalOutput
    	  };

    	  // Helpers

    	  function deepValue (obj, path, list) {
    	    var firstSegment;
    	    var remaining;
    	    var dotIndex;
    	    var value;
    	    var i;
    	    var len;

    	    if (!path) {
    	      // If there's no path left, we've gotten to the object we care about.
    	      list.push(obj);
    	    } else {
    	      dotIndex = path.indexOf('.');

    	      if (dotIndex !== -1) {
    	        firstSegment = path.slice(0, dotIndex);
    	        remaining = path.slice(dotIndex + 1);
    	      } else {
    	        firstSegment = path;
    	      }

    	      value = obj[firstSegment];
    	      if (value !== null && value !== undefined) {
    	        if (!remaining && (typeof value === 'string' || typeof value === 'number')) {
    	          list.push(value);
    	        } else if (isArray(value)) {
    	          // Search each item in the array.
    	          for (i = 0, len = value.length; i < len; i++) {
    	            deepValue(value[i], remaining, list);
    	          }
    	        } else if (remaining) {
    	          // An object. Recurse further.
    	          deepValue(value, remaining, list);
    	        }
    	      }
    	    }

    	    return list
    	  }

    	  function isArray (obj) {
    	    return Object.prototype.toString.call(obj) === '[object Array]'
    	  }

    	  /**
    	   * Adapted from "Diff, Match and Patch", by Google
    	   *
    	   *   http://code.google.com/p/google-diff-match-patch/
    	   *
    	   * Modified by: Kirollos Risk <kirollos@gmail.com>
    	   * -----------------------------------------------
    	   * Details: the algorithm and structure was modified to allow the creation of
    	   * <Searcher> instances with a <search> method which does the actual
    	   * bitap search. The <pattern> (the string that is searched for) is only defined
    	   * once per instance and thus it eliminates redundant re-creation when searching
    	   * over a list of strings.
    	   *
    	   * Licensed under the Apache License, Version 2.0 (the "License")
    	   * you may not use this file except in compliance with the License.
    	   *
    	   * @constructor
    	   */
    	  function BitapSearcher (pattern, options) {
    	    options = options || {};
    	    this.options = options;
    	    this.options.location = options.location || BitapSearcher.defaultOptions.location;
    	    this.options.distance = 'distance' in options ? options.distance : BitapSearcher.defaultOptions.distance;
    	    this.options.threshold = 'threshold' in options ? options.threshold : BitapSearcher.defaultOptions.threshold;
    	    this.options.maxPatternLength = options.maxPatternLength || BitapSearcher.defaultOptions.maxPatternLength;

    	    this.pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
    	    this.patternLen = pattern.length;

    	    if (this.patternLen <= this.options.maxPatternLength) {
    	      this.matchmask = 1 << (this.patternLen - 1);
    	      this.patternAlphabet = this._calculatePatternAlphabet();
    	    }
    	  }

    	  BitapSearcher.defaultOptions = {
    	    // Approximately where in the text is the pattern expected to be found?
    	    location: 0,

    	    // Determines how close the match must be to the fuzzy location (specified above).
    	    // An exact letter match which is 'distance' characters away from the fuzzy location
    	    // would score as a complete mismatch. A distance of '0' requires the match be at
    	    // the exact location specified, a threshold of '1000' would require a perfect match
    	    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    	    distance: 100,

    	    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    	    // (of both letters and location), a threshold of '1.0' would match anything.
    	    threshold: 0.6,

    	    // Machine word size
    	    maxPatternLength: 32
    	  };

    	  /**
    	   * Initialize the alphabet for the Bitap algorithm.
    	   * @return {Object} Hash of character locations.
    	   * @private
    	   */
    	  BitapSearcher.prototype._calculatePatternAlphabet = function () {
    	    var mask = {},
    	      i = 0;

    	    for (i = 0; i < this.patternLen; i++) {
    	      mask[this.pattern.charAt(i)] = 0;
    	    }

    	    for (i = 0; i < this.patternLen; i++) {
    	      mask[this.pattern.charAt(i)] |= 1 << (this.pattern.length - i - 1);
    	    }

    	    return mask
    	  };

    	  /**
    	   * Compute and return the score for a match with `e` errors and `x` location.
    	   * @param {number} errors Number of errors in match.
    	   * @param {number} location Location of match.
    	   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
    	   * @private
    	   */
    	  BitapSearcher.prototype._bitapScore = function (errors, location) {
    	    var accuracy = errors / this.patternLen,
    	      proximity = Math.abs(this.options.location - location);

    	    if (!this.options.distance) {
    	      // Dodge divide by zero error.
    	      return proximity ? 1.0 : accuracy
    	    }
    	    return accuracy + (proximity / this.options.distance)
    	  };

    	  /**
    	   * Compute and return the result of the search
    	   * @param {string} text The text to search in
    	   * @return {{isMatch: boolean, score: number}} Literal containing:
    	   *                          isMatch - Whether the text is a match or not
    	   *                          score - Overall score for the match
    	   * @public
    	   */
    	  BitapSearcher.prototype.search = function (text) {
    	    var options = this.options;
    	    var i;
    	    var j;
    	    var textLen;
    	    var findAllMatches;
    	    var location;
    	    var threshold;
    	    var bestLoc;
    	    var binMin;
    	    var binMid;
    	    var binMax;
    	    var start, finish;
    	    var bitArr;
    	    var lastBitArr;
    	    var charMatch;
    	    var score;
    	    var locations;
    	    var matches;
    	    var isMatched;
    	    var matchMask;
    	    var matchedIndices;
    	    var matchesLen;
    	    var match;

    	    text = options.caseSensitive ? text : text.toLowerCase();

    	    if (this.pattern === text) {
    	      // Exact match
    	      return {
    	        isMatch: true,
    	        score: 0,
    	        matchedIndices: [[0, text.length - 1]]
    	      }
    	    }

    	    // When pattern length is greater than the machine word length, just do a a regex comparison
    	    if (this.patternLen > options.maxPatternLength) {
    	      matches = text.match(new RegExp(this.pattern.replace(options.tokenSeparator, '|')));
    	      isMatched = !!matches;

    	      if (isMatched) {
    	        matchedIndices = [];
    	        for (i = 0, matchesLen = matches.length; i < matchesLen; i++) {
    	          match = matches[i];
    	          matchedIndices.push([text.indexOf(match), match.length - 1]);
    	        }
    	      }

    	      return {
    	        isMatch: isMatched,
    	        // TODO: revisit this score
    	        score: isMatched ? 0.5 : 1,
    	        matchedIndices: matchedIndices
    	      }
    	    }

    	    findAllMatches = options.findAllMatches;

    	    location = options.location;
    	    // Set starting location at beginning text and initialize the alphabet.
    	    textLen = text.length;
    	    // Highest score beyond which we give up.
    	    threshold = options.threshold;
    	    // Is there a nearby exact match? (speedup)
    	    bestLoc = text.indexOf(this.pattern, location);

    	    // a mask of the matches
    	    matchMask = [];
    	    for (i = 0; i < textLen; i++) {
    	      matchMask[i] = 0;
    	    }

    	    if (bestLoc != -1) {
    	      threshold = Math.min(this._bitapScore(0, bestLoc), threshold);
    	      // What about in the other direction? (speed up)
    	      bestLoc = text.lastIndexOf(this.pattern, location + this.patternLen);

    	      if (bestLoc != -1) {
    	        threshold = Math.min(this._bitapScore(0, bestLoc), threshold);
    	      }
    	    }

    	    bestLoc = -1;
    	    score = 1;
    	    locations = [];
    	    binMax = this.patternLen + textLen;

    	    for (i = 0; i < this.patternLen; i++) {
    	      // Scan for the best match; each iteration allows for one more error.
    	      // Run a binary search to determine how far from the match location we can stray
    	      // at this error level.
    	      binMin = 0;
    	      binMid = binMax;
    	      while (binMin < binMid) {
    	        if (this._bitapScore(i, location + binMid) <= threshold) {
    	          binMin = binMid;
    	        } else {
    	          binMax = binMid;
    	        }
    	        binMid = Math.floor((binMax - binMin) / 2 + binMin);
    	      }

    	      // Use the result from this iteration as the maximum for the next.
    	      binMax = binMid;
    	      start = Math.max(1, location - binMid + 1);
    	      if (findAllMatches) {
    	        finish = textLen;
    	      } else {
    	        finish = Math.min(location + binMid, textLen) + this.patternLen;
    	      }

    	      // Initialize the bit array
    	      bitArr = Array(finish + 2);

    	      bitArr[finish + 1] = (1 << i) - 1;

    	      for (j = finish; j >= start; j--) {
    	        charMatch = this.patternAlphabet[text.charAt(j - 1)];

    	        if (charMatch) {
    	          matchMask[j - 1] = 1;
    	        }

    	        bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

    	        if (i !== 0) {
    	          // Subsequent passes: fuzzy match.
    	          bitArr[j] |= (((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1) | lastBitArr[j + 1];
    	        }
    	        if (bitArr[j] & this.matchmask) {
    	          score = this._bitapScore(i, j - 1);

    	          // This match will almost certainly be better than any existing match.
    	          // But check anyway.
    	          if (score <= threshold) {
    	            // Indeed it is
    	            threshold = score;
    	            bestLoc = j - 1;
    	            locations.push(bestLoc);

    	            // Already passed loc, downhill from here on in.
    	            if (bestLoc <= location) {
    	              break
    	            }

    	            // When passing loc, don't exceed our current distance from loc.
    	            start = Math.max(1, 2 * location - bestLoc);
    	          }
    	        }
    	      }

    	      // No hope for a (better) match at greater error levels.
    	      if (this._bitapScore(i + 1, location) > threshold) {
    	        break
    	      }
    	      lastBitArr = bitArr;
    	    }

    	    matchedIndices = this._getMatchedIndices(matchMask);

    	    // Count exact matches (those with a score of 0) to be "almost" exact
    	    return {
    	      isMatch: bestLoc >= 0,
    	      score: score === 0 ? 0.001 : score,
    	      matchedIndices: matchedIndices
    	    }
    	  };

    	  BitapSearcher.prototype._getMatchedIndices = function (matchMask) {
    	    var matchedIndices = [];
    	    var start = -1;
    	    var end = -1;
    	    var i = 0;
    	    var match;
    	    var len = matchMask.length;
    	    for (; i < len; i++) {
    	      match = matchMask[i];
    	      if (match && start === -1) {
    	        start = i;
    	      } else if (!match && start !== -1) {
    	        end = i - 1;
    	        if ((end - start) + 1 >= this.options.minMatchCharLength) {
    	            matchedIndices.push([start, end]);
    	        }
    	        start = -1;
    	      }
    	    }
    	    if (matchMask[i - 1]) {
    	      if ((i-1 - start) + 1 >= this.options.minMatchCharLength) {
    	        matchedIndices.push([start, i - 1]);
    	      }
    	    }
    	    return matchedIndices
    	  };

    	  // Export to Common JS Loader
    	  {
    	    // Node. Does not work with strict CommonJS, but
    	    // only CommonJS-like environments that support module.exports,
    	    // like Node.
    	    module.exports = Fuse;
    	  }

    	})(this);


    /***/ }),
    /* 3 */
    /***/ (function(module, exports, __webpack_require__) {

    	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
    	  Copyright (c) 2016 Jed Watson.
    	  Licensed under the MIT License (MIT), see
    	  http://jedwatson.github.io/classnames
    	*/
    	/* global define */

    	(function () {

    		var hasOwn = {}.hasOwnProperty;

    		function classNames () {
    			var classes = [];

    			for (var i = 0; i < arguments.length; i++) {
    				var arg = arguments[i];
    				if (!arg) continue;

    				var argType = typeof arg;

    				if (argType === 'string' || argType === 'number') {
    					classes.push(arg);
    				} else if (Array.isArray(arg)) {
    					classes.push(classNames.apply(null, arg));
    				} else if (argType === 'object') {
    					for (var key in arg) {
    						if (hasOwn.call(arg, key) && arg[key]) {
    							classes.push(key);
    						}
    					}
    				}
    			}

    			return classes.join(' ');
    		}

    		if (typeof module !== 'undefined' && module.exports) {
    			module.exports = classNames;
    		} else {
    			// register as 'classnames', consistent with npm package name
    			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
    				return classNames;
    			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    		}
    	}());


    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	var _redux = __webpack_require__(5);

    	var _index = __webpack_require__(26);

    	var _index2 = _interopRequireDefault(_index);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	var Store = function () {
    	  function Store() {
    	    _classCallCheck(this, Store);

    	    this.store = (0, _redux.createStore)(_index2.default, window.devToolsExtension ? window.devToolsExtension() : undefined);
    	  }

    	  /**
    	   * Get store object (wrapping Redux method)
    	   * @return {Object} State
    	   */


    	  _createClass(Store, [{
    	    key: 'getState',
    	    value: function getState() {
    	      return this.store.getState();
    	    }

    	    /**
    	     * Dispatch event to store (wrapped Redux method)
    	     * @param  {Function} action Action function to trigger
    	     * @return
    	     */

    	  }, {
    	    key: 'dispatch',
    	    value: function dispatch(action) {
    	      this.store.dispatch(action);
    	    }

    	    /**
    	     * Subscribe store to function call (wrapped Redux method)
    	     * @param  {Function} onChange Function to trigger when state changes
    	     * @return
    	     */

    	  }, {
    	    key: 'subscribe',
    	    value: function subscribe(onChange) {
    	      this.store.subscribe(onChange);
    	    }

    	    /**
    	     * Get loading state from store
    	     * @return {Boolean} Loading State
    	     */

    	  }, {
    	    key: 'isLoading',
    	    value: function isLoading() {
    	      var state = this.store.getState();
    	      return state.general.loading;
    	    }

    	    /**
    	     * Get items from store
    	     * @return {Array} Item objects
    	     */

    	  }, {
    	    key: 'getItems',
    	    value: function getItems() {
    	      var state = this.store.getState();
    	      return state.items;
    	    }

    	    /**
    	     * Get active items from store
    	     * @return {Array} Item objects
    	     */

    	  }, {
    	    key: 'getItemsFilteredByActive',
    	    value: function getItemsFilteredByActive() {
    	      var items = this.getItems();
    	      var values = items.filter(function (item) {
    	        return item.active === true;
    	      }, []);

    	      return values;
    	    }

    	    /**
    	     * Get items from store reduced to just their values
    	     * @return {Array} Item objects
    	     */

    	  }, {
    	    key: 'getItemsReducedToValues',
    	    value: function getItemsReducedToValues() {
    	      var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getItems();

    	      var values = items.reduce(function (prev, current) {
    	        prev.push(current.value);
    	        return prev;
    	      }, []);

    	      return values;
    	    }

    	    /**
    	     * Get choices from store
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getChoices',
    	    value: function getChoices() {
    	      var state = this.store.getState();
    	      return state.choices;
    	    }

    	    /**
    	     * Get active choices from store
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getChoicesFilteredByActive',
    	    value: function getChoicesFilteredByActive() {
    	      var choices = this.getChoices();
    	      var values = choices.filter(function (choice) {
    	        return choice.active === true;
    	      });

    	      return values;
    	    }

    	    /**
    	     * Get selectable choices from store
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getChoicesFilteredBySelectable',
    	    value: function getChoicesFilteredBySelectable() {
    	      var choices = this.getChoices();
    	      var values = choices.filter(function (choice) {
    	        return choice.disabled !== true;
    	      });

    	      return values;
    	    }

    	    /**
    	     * Get choices that can be searched (excluding placeholders)
    	     * @return {Array} Option objects
    	     */

    	  }, {
    	    key: 'getSearchableChoices',
    	    value: function getSearchableChoices() {
    	      var filtered = this.getChoicesFilteredBySelectable();
    	      return filtered.filter(function (choice) {
    	        return choice.placeholder !== true;
    	      });
    	    }

    	    /**
    	     * Get single choice by it's ID
    	     * @return {Object} Found choice
    	     */

    	  }, {
    	    key: 'getChoiceById',
    	    value: function getChoiceById(id) {
    	      if (id) {
    	        var choices = this.getChoicesFilteredByActive();
    	        var foundChoice = choices.find(function (choice) {
    	          return choice.id === parseInt(id, 10);
    	        });
    	        return foundChoice;
    	      }
    	      return false;
    	    }

    	    /**
    	     * Get groups from store
    	     * @return {Array} Group objects
    	     */

    	  }, {
    	    key: 'getGroups',
    	    value: function getGroups() {
    	      var state = this.store.getState();
    	      return state.groups;
    	    }

    	    /**
    	     * Get active groups from store
    	     * @return {Array} Group objects
    	     */

    	  }, {
    	    key: 'getGroupsFilteredByActive',
    	    value: function getGroupsFilteredByActive() {
    	      var groups = this.getGroups();
    	      var choices = this.getChoices();

    	      var values = groups.filter(function (group) {
    	        var isActive = group.active === true && group.disabled === false;
    	        var hasActiveOptions = choices.some(function (choice) {
    	          return choice.active === true && choice.disabled === false;
    	        });
    	        return isActive && hasActiveOptions;
    	      }, []);

    	      return values;
    	    }

    	    /**
    	     * Get group by group id
    	     * @param  {Number} id Group ID
    	     * @return {Object}    Group data
    	     */

    	  }, {
    	    key: 'getGroupById',
    	    value: function getGroupById(id) {
    	      var groups = this.getGroups();
    	      var foundGroup = groups.find(function (group) {
    	        return group.id === id;
    	      });

    	      return foundGroup;
    	    }

    	    /**
    	     * Get placeholder choice from store
    	     * @return {Object} Found placeholder
    	     */

    	  }, {
    	    key: 'getPlaceholderChoice',
    	    value: function getPlaceholderChoice() {
    	      var choices = this.getChoices();
    	      var placeholderChoice = [].concat(_toConsumableArray(choices)).reverse().find(function (choice) {
    	        return choice.placeholder === true;
    	      });

    	      return placeholderChoice;
    	    }
    	  }]);

    	  return Store;
    	}();

    	exports.default = Store;


    		module.exports = Store;

    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;
    	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

    	var _createStore = __webpack_require__(6);

    	var _createStore2 = _interopRequireDefault(_createStore);

    	var _combineReducers = __webpack_require__(21);

    	var _combineReducers2 = _interopRequireDefault(_combineReducers);

    	var _bindActionCreators = __webpack_require__(23);

    	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

    	var _applyMiddleware = __webpack_require__(24);

    	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

    	var _compose = __webpack_require__(25);

    	var _compose2 = _interopRequireDefault(_compose);

    	var _warning = __webpack_require__(22);

    	var _warning2 = _interopRequireDefault(_warning);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	exports.createStore = _createStore2['default'];
    	exports.combineReducers = _combineReducers2['default'];
    	exports.bindActionCreators = _bindActionCreators2['default'];
    	exports.applyMiddleware = _applyMiddleware2['default'];
    	exports.compose = _compose2['default'];

    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;
    	exports.ActionTypes = undefined;
    	exports['default'] = createStore;

    	var _isPlainObject = __webpack_require__(7);

    	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

    	var _symbolObservable = __webpack_require__(17);

    	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	/**
    	 * These are private action types reserved by Redux.
    	 * For any unknown actions, you must return the current state.
    	 * If the current state is undefined, you must return the initial state.
    	 * Do not reference these action types directly in your code.
    	 */
    	var ActionTypes = exports.ActionTypes = {
    	  INIT: '@@redux/INIT'

    	  /**
    	   * Creates a Redux store that holds the state tree.
    	   * The only way to change the data in the store is to call `dispatch()` on it.
    	   *
    	   * There should only be a single store in your app. To specify how different
    	   * parts of the state tree respond to actions, you may combine several reducers
    	   * into a single reducer function by using `combineReducers`.
    	   *
    	   * @param {Function} reducer A function that returns the next state tree, given
    	   * the current state tree and the action to handle.
    	   *
    	   * @param {any} [preloadedState] The initial state. You may optionally specify it
    	   * to hydrate the state from the server in universal apps, or to restore a
    	   * previously serialized user session.
    	   * If you use `combineReducers` to produce the root reducer function, this must be
    	   * an object with the same shape as `combineReducers` keys.
    	   *
    	   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
    	   * to enhance the store with third-party capabilities such as middleware,
    	   * time travel, persistence, etc. The only store enhancer that ships with Redux
    	   * is `applyMiddleware()`.
    	   *
    	   * @returns {Store} A Redux store that lets you read the state, dispatch actions
    	   * and subscribe to changes.
    	   */
    	};function createStore(reducer, preloadedState, enhancer) {
    	  var _ref2;

    	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    	    enhancer = preloadedState;
    	    preloadedState = undefined;
    	  }

    	  if (typeof enhancer !== 'undefined') {
    	    if (typeof enhancer !== 'function') {
    	      throw new Error('Expected the enhancer to be a function.');
    	    }

    	    return enhancer(createStore)(reducer, preloadedState);
    	  }

    	  if (typeof reducer !== 'function') {
    	    throw new Error('Expected the reducer to be a function.');
    	  }

    	  var currentReducer = reducer;
    	  var currentState = preloadedState;
    	  var currentListeners = [];
    	  var nextListeners = currentListeners;
    	  var isDispatching = false;

    	  function ensureCanMutateNextListeners() {
    	    if (nextListeners === currentListeners) {
    	      nextListeners = currentListeners.slice();
    	    }
    	  }

    	  /**
    	   * Reads the state tree managed by the store.
    	   *
    	   * @returns {any} The current state tree of your application.
    	   */
    	  function getState() {
    	    return currentState;
    	  }

    	  /**
    	   * Adds a change listener. It will be called any time an action is dispatched,
    	   * and some part of the state tree may potentially have changed. You may then
    	   * call `getState()` to read the current state tree inside the callback.
    	   *
    	   * You may call `dispatch()` from a change listener, with the following
    	   * caveats:
    	   *
    	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
    	   * If you subscribe or unsubscribe while the listeners are being invoked, this
    	   * will not have any effect on the `dispatch()` that is currently in progress.
    	   * However, the next `dispatch()` call, whether nested or not, will use a more
    	   * recent snapshot of the subscription list.
    	   *
    	   * 2. The listener should not expect to see all state changes, as the state
    	   * might have been updated multiple times during a nested `dispatch()` before
    	   * the listener is called. It is, however, guaranteed that all subscribers
    	   * registered before the `dispatch()` started will be called with the latest
    	   * state by the time it exits.
    	   *
    	   * @param {Function} listener A callback to be invoked on every dispatch.
    	   * @returns {Function} A function to remove this change listener.
    	   */
    	  function subscribe(listener) {
    	    if (typeof listener !== 'function') {
    	      throw new Error('Expected listener to be a function.');
    	    }

    	    var isSubscribed = true;

    	    ensureCanMutateNextListeners();
    	    nextListeners.push(listener);

    	    return function unsubscribe() {
    	      if (!isSubscribed) {
    	        return;
    	      }

    	      isSubscribed = false;

    	      ensureCanMutateNextListeners();
    	      var index = nextListeners.indexOf(listener);
    	      nextListeners.splice(index, 1);
    	    };
    	  }

    	  /**
    	   * Dispatches an action. It is the only way to trigger a state change.
    	   *
    	   * The `reducer` function, used to create the store, will be called with the
    	   * current state tree and the given `action`. Its return value will
    	   * be considered the **next** state of the tree, and the change listeners
    	   * will be notified.
    	   *
    	   * The base implementation only supports plain object actions. If you want to
    	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
    	   * wrap your store creating function into the corresponding middleware. For
    	   * example, see the documentation for the `redux-thunk` package. Even the
    	   * middleware will eventually dispatch plain object actions using this method.
    	   *
    	   * @param {Object} action A plain object representing what changed. It is
    	   * a good idea to keep actions serializable so you can record and replay user
    	   * sessions, or use the time travelling `redux-devtools`. An action must have
    	   * a `type` property which may not be `undefined`. It is a good idea to use
    	   * string constants for action types.
    	   *
    	   * @returns {Object} For convenience, the same action object you dispatched.
    	   *
    	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
    	   * return something else (for example, a Promise you can await).
    	   */
    	  function dispatch(action) {
    	    if (!(0, _isPlainObject2['default'])(action)) {
    	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    	    }

    	    if (typeof action.type === 'undefined') {
    	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    	    }

    	    if (isDispatching) {
    	      throw new Error('Reducers may not dispatch actions.');
    	    }

    	    try {
    	      isDispatching = true;
    	      currentState = currentReducer(currentState, action);
    	    } finally {
    	      isDispatching = false;
    	    }

    	    var listeners = currentListeners = nextListeners;
    	    for (var i = 0; i < listeners.length; i++) {
    	      var listener = listeners[i];
    	      listener();
    	    }

    	    return action;
    	  }

    	  /**
    	   * Replaces the reducer currently used by the store to calculate the state.
    	   *
    	   * You might need this if your app implements code splitting and you want to
    	   * load some of the reducers dynamically. You might also need this if you
    	   * implement a hot reloading mechanism for Redux.
    	   *
    	   * @param {Function} nextReducer The reducer for the store to use instead.
    	   * @returns {void}
    	   */
    	  function replaceReducer(nextReducer) {
    	    if (typeof nextReducer !== 'function') {
    	      throw new Error('Expected the nextReducer to be a function.');
    	    }

    	    currentReducer = nextReducer;
    	    dispatch({ type: ActionTypes.INIT });
    	  }

    	  /**
    	   * Interoperability point for observable/reactive libraries.
    	   * @returns {observable} A minimal observable of state changes.
    	   * For more information, see the observable proposal:
    	   * https://github.com/tc39/proposal-observable
    	   */
    	  function observable() {
    	    var _ref;

    	    var outerSubscribe = subscribe;
    	    return _ref = {
    	      /**
    	       * The minimal observable subscription method.
    	       * @param {Object} observer Any object that can be used as an observer.
    	       * The observer object should have a `next` method.
    	       * @returns {subscription} An object with an `unsubscribe` method that can
    	       * be used to unsubscribe the observable from the store, and prevent further
    	       * emission of values from the observable.
    	       */
    	      subscribe: function subscribe(observer) {
    	        if (typeof observer !== 'object') {
    	          throw new TypeError('Expected the observer to be an object.');
    	        }

    	        function observeState() {
    	          if (observer.next) {
    	            observer.next(getState());
    	          }
    	        }

    	        observeState();
    	        var unsubscribe = outerSubscribe(observeState);
    	        return { unsubscribe: unsubscribe };
    	      }
    	    }, _ref[_symbolObservable2['default']] = function () {
    	      return this;
    	    }, _ref;
    	  }

    	  // When a store is created, an "INIT" action is dispatched so that every
    	  // reducer returns their initial state. This effectively populates
    	  // the initial state tree.
    	  dispatch({ type: ActionTypes.INIT });

    	  return _ref2 = {
    	    dispatch: dispatch,
    	    subscribe: subscribe,
    	    getState: getState,
    	    replaceReducer: replaceReducer
    	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
    	}

    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {

    	var baseGetTag = __webpack_require__(8),
    	    getPrototype = __webpack_require__(14),
    	    isObjectLike = __webpack_require__(16);

    	/** `Object#toString` result references. */
    	var objectTag = '[object Object]';

    	/** Used for built-in method references. */
    	var funcProto = Function.prototype,
    	    objectProto = Object.prototype;

    	/** Used to resolve the decompiled source of functions. */
    	var funcToString = funcProto.toString;

    	/** Used to check objects for own properties. */
    	var hasOwnProperty = objectProto.hasOwnProperty;

    	/** Used to infer the `Object` constructor. */
    	var objectCtorString = funcToString.call(Object);

    	/**
    	 * Checks if `value` is a plain object, that is, an object created by the
    	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 0.8.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
    	 * @example
    	 *
    	 * function Foo() {
    	 *   this.a = 1;
    	 * }
    	 *
    	 * _.isPlainObject(new Foo);
    	 * // => false
    	 *
    	 * _.isPlainObject([1, 2, 3]);
    	 * // => false
    	 *
    	 * _.isPlainObject({ 'x': 0, 'y': 0 });
    	 * // => true
    	 *
    	 * _.isPlainObject(Object.create(null));
    	 * // => true
    	 */
    	function isPlainObject(value) {
    	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    	    return false;
    	  }
    	  var proto = getPrototype(value);
    	  if (proto === null) {
    	    return true;
    	  }
    	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    	    funcToString.call(Ctor) == objectCtorString;
    	}

    	module.exports = isPlainObject;


    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {

    	var Symbol = __webpack_require__(9),
    	    getRawTag = __webpack_require__(12),
    	    objectToString = __webpack_require__(13);

    	/** `Object#toString` result references. */
    	var nullTag = '[object Null]',
    	    undefinedTag = '[object Undefined]';

    	/** Built-in value references. */
    	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    	/**
    	 * The base implementation of `getTag` without fallbacks for buggy environments.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @returns {string} Returns the `toStringTag`.
    	 */
    	function baseGetTag(value) {
    	  if (value == null) {
    	    return value === undefined ? undefinedTag : nullTag;
    	  }
    	  return (symToStringTag && symToStringTag in Object(value))
    	    ? getRawTag(value)
    	    : objectToString(value);
    	}

    	module.exports = baseGetTag;


    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {

    	var root = __webpack_require__(10);

    	/** Built-in value references. */
    	var Symbol = root.Symbol;

    	module.exports = Symbol;


    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {

    	var freeGlobal = __webpack_require__(11);

    	/** Detect free variable `self`. */
    	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    	/** Used as a reference to the global object. */
    	var root = freeGlobal || freeSelf || Function('return this')();

    	module.exports = root;


    /***/ }),
    /* 11 */
    /***/ (function(module, exports) {

    	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
    	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    	module.exports = freeGlobal;

    	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())));

    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {

    	var Symbol = __webpack_require__(9);

    	/** Used for built-in method references. */
    	var objectProto = Object.prototype;

    	/** Used to check objects for own properties. */
    	var hasOwnProperty = objectProto.hasOwnProperty;

    	/**
    	 * Used to resolve the
    	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
    	 * of values.
    	 */
    	var nativeObjectToString = objectProto.toString;

    	/** Built-in value references. */
    	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    	/**
    	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @returns {string} Returns the raw `toStringTag`.
    	 */
    	function getRawTag(value) {
    	  var isOwn = hasOwnProperty.call(value, symToStringTag),
    	      tag = value[symToStringTag];

    	  try {
    	    value[symToStringTag] = undefined;
    	  } catch (e) {}

    	  var result = nativeObjectToString.call(value);
    	  {
    	    if (isOwn) {
    	      value[symToStringTag] = tag;
    	    } else {
    	      delete value[symToStringTag];
    	    }
    	  }
    	  return result;
    	}

    	module.exports = getRawTag;


    /***/ }),
    /* 13 */
    /***/ (function(module, exports) {

    	/** Used for built-in method references. */
    	var objectProto = Object.prototype;

    	/**
    	 * Used to resolve the
    	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
    	 * of values.
    	 */
    	var nativeObjectToString = objectProto.toString;

    	/**
    	 * Converts `value` to a string using `Object.prototype.toString`.
    	 *
    	 * @private
    	 * @param {*} value The value to convert.
    	 * @returns {string} Returns the converted string.
    	 */
    	function objectToString(value) {
    	  return nativeObjectToString.call(value);
    	}

    	module.exports = objectToString;


    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {

    	var overArg = __webpack_require__(15);

    	/** Built-in value references. */
    	var getPrototype = overArg(Object.getPrototypeOf, Object);

    	module.exports = getPrototype;


    /***/ }),
    /* 15 */
    /***/ (function(module, exports) {

    	/**
    	 * Creates a unary function that invokes `func` with its argument transformed.
    	 *
    	 * @private
    	 * @param {Function} func The function to wrap.
    	 * @param {Function} transform The argument transform.
    	 * @returns {Function} Returns the new function.
    	 */
    	function overArg(func, transform) {
    	  return function(arg) {
    	    return func(transform(arg));
    	  };
    	}

    	module.exports = overArg;


    /***/ }),
    /* 16 */
    /***/ (function(module, exports) {

    	/**
    	 * Checks if `value` is object-like. A value is object-like if it's not `null`
    	 * and has a `typeof` result of "object".
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.0.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
    	 * @example
    	 *
    	 * _.isObjectLike({});
    	 * // => true
    	 *
    	 * _.isObjectLike([1, 2, 3]);
    	 * // => true
    	 *
    	 * _.isObjectLike(_.noop);
    	 * // => false
    	 *
    	 * _.isObjectLike(null);
    	 * // => false
    	 */
    	function isObjectLike(value) {
    	  return value != null && typeof value == 'object';
    	}

    	module.exports = isObjectLike;


    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {

    	module.exports = __webpack_require__(18);


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {

    	/* WEBPACK VAR INJECTION */(function(global, module) {
    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _ponyfill = __webpack_require__(20);

    	var _ponyfill2 = _interopRequireDefault(_ponyfill);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	var root; /* global window */


    	if (typeof self !== 'undefined') {
    	  root = self;
    	} else if (typeof window !== 'undefined') {
    	  root = window;
    	} else if (typeof global !== 'undefined') {
    	  root = global;
    	} else {
    	  root = module;
    	}

    	var result = (0, _ponyfill2['default'])(root);
    	exports['default'] = result;
    	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(19)(module)));

    /***/ }),
    /* 19 */
    /***/ (function(module, exports) {

    	module.exports = function(module) {
    		if(!module.webpackPolyfill) {
    			module.deprecate = function() {};
    			module.paths = [];
    			// module.parent = undefined by default
    			module.children = [];
    			module.webpackPolyfill = 1;
    		}
    		return module;
    	};


    /***/ }),
    /* 20 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    		value: true
    	});
    	exports['default'] = symbolObservablePonyfill;
    	function symbolObservablePonyfill(root) {
    		var result;
    		var _Symbol = root.Symbol;

    		if (typeof _Symbol === 'function') {
    			if (_Symbol.observable) {
    				result = _Symbol.observable;
    			} else {
    				result = _Symbol('observable');
    				_Symbol.observable = result;
    			}
    		} else {
    			result = '@@observable';
    		}

    		return result;
    	}
    /***/ }),
    /* 21 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;
    	exports['default'] = combineReducers;

    	var _createStore = __webpack_require__(6);

    	var _isPlainObject = __webpack_require__(7);

    	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

    	var _warning = __webpack_require__(22);

    	var _warning2 = _interopRequireDefault(_warning);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	function getUndefinedStateErrorMessage(key, action) {
    	  var actionType = action && action.type;
    	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

    	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
    	}

    	function assertReducerShape(reducers) {
    	  Object.keys(reducers).forEach(function (key) {
    	    var reducer = reducers[key];
    	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    	    if (typeof initialState === 'undefined') {
    	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    	    }

    	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
    	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    	    }
    	  });
    	}

    	/**
    	 * Turns an object whose values are different reducer functions, into a single
    	 * reducer function. It will call every child reducer, and gather their results
    	 * into a single state object, whose keys correspond to the keys of the passed
    	 * reducer functions.
    	 *
    	 * @param {Object} reducers An object whose values correspond to different
    	 * reducer functions that need to be combined into one. One handy way to obtain
    	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
    	 * undefined for any action. Instead, they should return their initial state
    	 * if the state passed to them was undefined, and the current state for any
    	 * unrecognized action.
    	 *
    	 * @returns {Function} A reducer function that invokes every reducer inside the
    	 * passed object, and builds a state object with the same shape.
    	 */
    	function combineReducers(reducers) {
    	  var reducerKeys = Object.keys(reducers);
    	  var finalReducers = {};
    	  for (var i = 0; i < reducerKeys.length; i++) {
    	    var key = reducerKeys[i];

    	    if (typeof reducers[key] === 'function') {
    	      finalReducers[key] = reducers[key];
    	    }
    	  }
    	  var finalReducerKeys = Object.keys(finalReducers);

    	  var shapeAssertionError = void 0;
    	  try {
    	    assertReducerShape(finalReducers);
    	  } catch (e) {
    	    shapeAssertionError = e;
    	  }

    	  return function combination() {
    	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    	    var action = arguments[1];

    	    if (shapeAssertionError) {
    	      throw shapeAssertionError;
    	    }

    	    var hasChanged = false;
    	    var nextState = {};
    	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
    	      var _key = finalReducerKeys[_i];
    	      var reducer = finalReducers[_key];
    	      var previousStateForKey = state[_key];
    	      var nextStateForKey = reducer(previousStateForKey, action);
    	      if (typeof nextStateForKey === 'undefined') {
    	        var errorMessage = getUndefinedStateErrorMessage(_key, action);
    	        throw new Error(errorMessage);
    	      }
    	      nextState[_key] = nextStateForKey;
    	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    	    }
    	    return hasChanged ? nextState : state;
    	  };
    	}

    /***/ }),
    /* 22 */
    /***/ (function(module, exports) {

    	exports.__esModule = true;
    	exports['default'] = warning;
    	/**
    	 * Prints a warning in the console if it exists.
    	 *
    	 * @param {String} message The warning message.
    	 * @returns {void}
    	 */
    	function warning(message) {
    	  /* eslint-disable no-console */
    	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    	    console.error(message);
    	  }
    	  /* eslint-enable no-console */
    	  try {
    	    // This error was thrown as a convenience so that if you enable
    	    // "break on all exceptions" in your console,
    	    // it would pause the execution at this line.
    	    throw new Error(message);
    	    /* eslint-disable no-empty */
    	  } catch (e) {}
    	  /* eslint-enable no-empty */
    	}

    /***/ }),
    /* 23 */
    /***/ (function(module, exports) {

    	exports.__esModule = true;
    	exports['default'] = bindActionCreators;
    	function bindActionCreator(actionCreator, dispatch) {
    	  return function () {
    	    return dispatch(actionCreator.apply(undefined, arguments));
    	  };
    	}

    	/**
    	 * Turns an object whose values are action creators, into an object with the
    	 * same keys, but with every function wrapped into a `dispatch` call so they
    	 * may be invoked directly. This is just a convenience method, as you can call
    	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
    	 *
    	 * For convenience, you can also pass a single function as the first argument,
    	 * and get a function in return.
    	 *
    	 * @param {Function|Object} actionCreators An object whose values are action
    	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
    	 * syntax. You may also pass a single function.
    	 *
    	 * @param {Function} dispatch The `dispatch` function available on your Redux
    	 * store.
    	 *
    	 * @returns {Function|Object} The object mimicking the original object, but with
    	 * every action creator wrapped into the `dispatch` call. If you passed a
    	 * function as `actionCreators`, the return value will also be a single
    	 * function.
    	 */
    	function bindActionCreators(actionCreators, dispatch) {
    	  if (typeof actionCreators === 'function') {
    	    return bindActionCreator(actionCreators, dispatch);
    	  }

    	  if (typeof actionCreators !== 'object' || actionCreators === null) {
    	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    	  }

    	  var keys = Object.keys(actionCreators);
    	  var boundActionCreators = {};
    	  for (var i = 0; i < keys.length; i++) {
    	    var key = keys[i];
    	    var actionCreator = actionCreators[key];
    	    if (typeof actionCreator === 'function') {
    	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    	    }
    	  }
    	  return boundActionCreators;
    	}

    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {

    	exports.__esModule = true;

    	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

    	exports['default'] = applyMiddleware;

    	var _compose = __webpack_require__(25);

    	var _compose2 = _interopRequireDefault(_compose);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

    	/**
    	 * Creates a store enhancer that applies middleware to the dispatch method
    	 * of the Redux store. This is handy for a variety of tasks, such as expressing
    	 * asynchronous actions in a concise manner, or logging every action payload.
    	 *
    	 * See `redux-thunk` package as an example of the Redux middleware.
    	 *
    	 * Because middleware is potentially asynchronous, this should be the first
    	 * store enhancer in the composition chain.
    	 *
    	 * Note that each middleware will be given the `dispatch` and `getState` functions
    	 * as named arguments.
    	 *
    	 * @param {...Function} middlewares The middleware chain to be applied.
    	 * @returns {Function} A store enhancer applying the middleware.
    	 */
    	function applyMiddleware() {
    	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    	    middlewares[_key] = arguments[_key];
    	  }

    	  return function (createStore) {
    	    return function (reducer, preloadedState, enhancer) {
    	      var store = createStore(reducer, preloadedState, enhancer);
    	      var _dispatch = store.dispatch;
    	      var chain = [];

    	      var middlewareAPI = {
    	        getState: store.getState,
    	        dispatch: function dispatch(action) {
    	          return _dispatch(action);
    	        }
    	      };
    	      chain = middlewares.map(function (middleware) {
    	        return middleware(middlewareAPI);
    	      });
    	      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

    	      return _extends({}, store, {
    	        dispatch: _dispatch
    	      });
    	    };
    	  };
    	}

    /***/ }),
    /* 25 */
    /***/ (function(module, exports) {

    	exports.__esModule = true;
    	exports["default"] = compose;
    	/**
    	 * Composes single-argument functions from right to left. The rightmost
    	 * function can take multiple arguments as it provides the signature for
    	 * the resulting composite function.
    	 *
    	 * @param {...Function} funcs The functions to compose.
    	 * @returns {Function} A function obtained by composing the argument functions
    	 * from right to left. For example, compose(f, g, h) is identical to doing
    	 * (...args) => f(g(h(...args))).
    	 */

    	function compose() {
    	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    	    funcs[_key] = arguments[_key];
    	  }

    	  if (funcs.length === 0) {
    	    return function (arg) {
    	      return arg;
    	    };
    	  }

    	  if (funcs.length === 1) {
    	    return funcs[0];
    	  }

    	  return funcs.reduce(function (a, b) {
    	    return function () {
    	      return a(b.apply(undefined, arguments));
    	    };
    	  });
    	}

    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _redux = __webpack_require__(5);

    	var _items = __webpack_require__(27);

    	var _items2 = _interopRequireDefault(_items);

    	var _groups = __webpack_require__(28);

    	var _groups2 = _interopRequireDefault(_groups);

    	var _choices = __webpack_require__(29);

    	var _choices2 = _interopRequireDefault(_choices);

    	var _general = __webpack_require__(30);

    	var _general2 = _interopRequireDefault(_general);

    	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    	var appReducer = (0, _redux.combineReducers)({
    	  items: _items2.default,
    	  groups: _groups2.default,
    	  choices: _choices2.default,
    	  general: _general2.default
    	});

    	var rootReducer = function rootReducer(passedState, action) {
    	  var state = passedState;
    	  // If we are clearing all items, groups and options we reassign
    	  // state and then pass that state to our proper reducer. This isn't
    	  // mutating our actual state
    	  // See: http://stackoverflow.com/a/35641992
    	  if (action.type === 'CLEAR_ALL') {
    	    state = undefined;
    	  }

    	  return appReducer(state, action);
    	};

    	exports.default = rootReducer;

    /***/ }),
    /* 27 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	var items = function items() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'ADD_ITEM':
    	      {
    	        // Add object to items array
    	        var newState = [].concat(_toConsumableArray(state), [{
    	          id: action.id,
    	          choiceId: action.choiceId,
    	          groupId: action.groupId,
    	          value: action.value,
    	          label: action.label,
    	          active: true,
    	          highlighted: false,
    	          customProperties: action.customProperties,
    	          placeholder: action.placeholder || false,
    	          keyCode: null
    	        }]);

    	        return newState.map(function (item) {
    	          if (item.highlighted) {
    	            item.highlighted = false;
    	          }
    	          return item;
    	        });
    	      }

    	    case 'REMOVE_ITEM':
    	      {
    	        // Set item to inactive
    	        return state.map(function (item) {
    	          if (item.id === action.id) {
    	            item.active = false;
    	          }
    	          return item;
    	        });
    	      }

    	    case 'HIGHLIGHT_ITEM':
    	      {
    	        return state.map(function (item) {
    	          if (item.id === action.id) {
    	            item.highlighted = action.highlighted;
    	          }
    	          return item;
    	        });
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = items;

    /***/ }),
    /* 28 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	var groups = function groups() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'ADD_GROUP':
    	      {
    	        return [].concat(_toConsumableArray(state), [{
    	          id: action.id,
    	          value: action.value,
    	          active: action.active,
    	          disabled: action.disabled
    	        }]);
    	      }

    	    case 'CLEAR_CHOICES':
    	      {
    	        return state.groups = [];
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = groups;

    /***/ }),
    /* 29 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    	var choices = function choices() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'ADD_CHOICE':
    	      {
    	        /*
    	            A disabled choice appears in the choice dropdown but cannot be selected
    	            A selected choice has been added to the passed input's value (added as an item)
    	            An active choice appears within the choice dropdown
    	         */
    	        return [].concat(_toConsumableArray(state), [{
    	          id: action.id,
    	          elementId: action.elementId,
    	          groupId: action.groupId,
    	          value: action.value,
    	          label: action.label || action.value,
    	          disabled: action.disabled || false,
    	          selected: false,
    	          active: true,
    	          score: 9999,
    	          customProperties: action.customProperties,
    	          placeholder: action.placeholder || false,
    	          keyCode: null
    	        }]);
    	      }

    	    case 'ADD_ITEM':
    	      {
    	        var newState = state;

    	        // If all choices need to be activated
    	        if (action.activateOptions) {
    	          newState = state.map(function (choice) {
    	            choice.active = action.active;
    	            return choice;
    	          });
    	        }
    	        // When an item is added and it has an associated choice,
    	        // we want to disable it so it can't be chosen again
    	        if (action.choiceId > -1) {
    	          newState = state.map(function (choice) {
    	            if (choice.id === parseInt(action.choiceId, 10)) {
    	              choice.selected = true;
    	            }
    	            return choice;
    	          });
    	        }

    	        return newState;
    	      }

    	    case 'REMOVE_ITEM':
    	      {
    	        // When an item is removed and it has an associated choice,
    	        // we want to re-enable it so it can be chosen again
    	        if (action.choiceId > -1) {
    	          return state.map(function (choice) {
    	            if (choice.id === parseInt(action.choiceId, 10)) {
    	              choice.selected = false;
    	            }
    	            return choice;
    	          });
    	        }

    	        return state;
    	      }

    	    case 'FILTER_CHOICES':
    	      {
    	        var filteredResults = action.results;
    	        var filteredState = state.map(function (choice) {
    	          // Set active state based on whether choice is
    	          // within filtered results

    	          choice.active = filteredResults.some(function (result) {
    	            if (result.item.id === choice.id) {
    	              choice.score = result.score;
    	              return true;
    	            }
    	            return false;
    	          });

    	          return choice;
    	        });

    	        return filteredState;
    	      }

    	    case 'ACTIVATE_CHOICES':
    	      {
    	        return state.map(function (choice) {
    	          choice.active = action.active;
    	          return choice;
    	        });
    	      }

    	    case 'CLEAR_CHOICES':
    	      {
    	        return state.choices = [];
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = choices;

    /***/ }),
    /* 30 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	var general = function general() {
    	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { loading: false };
    	  var action = arguments[1];

    	  switch (action.type) {
    	    case 'LOADING':
    	      {
    	        return {
    	          loading: action.isLoading
    	        };
    	      }

    	    default:
    	      {
    	        return state;
    	      }
    	  }
    	};

    	exports.default = general;

    /***/ }),
    /* 31 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});
    	var addItem = exports.addItem = function addItem(value, label, id, choiceId, groupId, customProperties, placeholder, keyCode) {
    	  return {
    	    type: 'ADD_ITEM',
    	    value: value,
    	    label: label,
    	    id: id,
    	    choiceId: choiceId,
    	    groupId: groupId,
    	    customProperties: customProperties,
    	    placeholder: placeholder,
    	    keyCode: keyCode
    	  };
    	};

    	var removeItem = exports.removeItem = function removeItem(id, choiceId) {
    	  return {
    	    type: 'REMOVE_ITEM',
    	    id: id,
    	    choiceId: choiceId
    	  };
    	};

    	var highlightItem = exports.highlightItem = function highlightItem(id, highlighted) {
    	  return {
    	    type: 'HIGHLIGHT_ITEM',
    	    id: id,
    	    highlighted: highlighted
    	  };
    	};

    	var addChoice = exports.addChoice = function addChoice(value, label, id, groupId, disabled, elementId, customProperties, placeholder, keyCode) {
    	  return {
    	    type: 'ADD_CHOICE',
    	    value: value,
    	    label: label,
    	    id: id,
    	    groupId: groupId,
    	    disabled: disabled,
    	    elementId: elementId,
    	    customProperties: customProperties,
    	    placeholder: placeholder,
    	    keyCode: keyCode
    	  };
    	};

    	var filterChoices = exports.filterChoices = function filterChoices(results) {
    	  return {
    	    type: 'FILTER_CHOICES',
    	    results: results
    	  };
    	};

    	var activateChoices = exports.activateChoices = function activateChoices() {
    	  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    	  return {
    	    type: 'ACTIVATE_CHOICES',
    	    active: active
    	  };
    	};

    	var clearChoices = exports.clearChoices = function clearChoices() {
    	  return {
    	    type: 'CLEAR_CHOICES'
    	  };
    	};

    	var addGroup = exports.addGroup = function addGroup(value, id, active, disabled) {
    	  return {
    	    type: 'ADD_GROUP',
    	    value: value,
    	    id: id,
    	    active: active,
    	    disabled: disabled
    	  };
    	};

    	var clearAll = exports.clearAll = function clearAll() {
    	  return {
    	    type: 'CLEAR_ALL'
    	  };
    	};

    	var setIsLoading = exports.setIsLoading = function setIsLoading(isLoading) {
    	  return {
    	    type: 'LOADING',
    	    isLoading: isLoading
    	  };
    		};

    /***/ }),
    /* 32 */
    /***/ (function(module, exports) {

    	Object.defineProperty(exports, "__esModule", {
    	  value: true
    	});

    	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    	/* eslint-disable */
    	/**
    	 * Capitalises the first letter of each word in a string
    	 * @param  {String} str String to capitalise
    	 * @return {String}     Capitalised string
    	 */
    	var capitalise = exports.capitalise = function capitalise(str) {
    	  return str.replace(/\w\S*/g, function (txt) {
    	    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    	  });
    	};

    	/**
    	 * Generates a string of random chars
    	 * @param  {Number} length Length of the string to generate
    	 * @return {String} String of random chars
    	 */
    	var generateChars = exports.generateChars = function generateChars(length) {
    	  var chars = '';

    	  for (var i = 0; i < length; i++) {
    	    var randomChar = getRandomNumber(0, 36);
    	    chars += randomChar.toString(36);
    	  }

    	  return chars;
    	};

    	/**
    	 * Generates a unique id based on an element
    	 * @param  {HTMLElement} element Element to generate the id from
    	 * @param  {String} Prefix for the Id
    	 * @return {String} Unique Id
    	 */
    	var generateId = exports.generateId = function generateId(element, prefix) {
    	  var id = element.id || element.name && element.name + '-' + generateChars(2) || generateChars(4);
    	  id = id.replace(/(:|\.|\[|\]|,)/g, '');
    	  id = prefix + id;

    	  return id;
    	};

    	/**
    	 * Tests the type of an object
    	 * @param  {String}  type Type to test object against
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var getType = exports.getType = function getType(obj) {
    	  return Object.prototype.toString.call(obj).slice(8, -1);
    	};

    	/**
    	 * Tests the type of an object
    	 * @param  {String}  type Type to test object against
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var isType = exports.isType = function isType(type, obj) {
    	  var clas = getType(obj);
    	  return obj !== undefined && obj !== null && clas === type;
    	};

    	/**
    	 * Tests to see if a passed object is a node
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var isNode = exports.isNode = function isNode(o) {
    	  return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === "object" ? o instanceof Node : o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
    	};

    	/**
    	 * Tests to see if a passed object is an element
    	 * @param  {Object}  obj  Object to be tested
    	 * @return {Boolean}
    	 */
    	var isElement = exports.isElement = function isElement(o) {
    	  return (typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === "object" ? o instanceof HTMLElement : //DOM2
    	  o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
    	};

    	/**
    	 * Merges unspecified amount of objects into new object
    	 * @private
    	 * @return {Object} Merged object of arguments
    	 */
    	var extend = exports.extend = function extend() {
    	  var extended = {};
    	  var length = arguments.length;

    	  /**
    	   * Merge one object into another
    	   * @param  {Object} obj  Object to merge into extended object
    	   */
    	  var merge = function merge(obj) {
    	    for (var prop in obj) {
    	      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
    	        // If deep merge and property is an object, merge properties
    	        if (isType('Object', obj[prop])) {
    	          extended[prop] = extend(true, extended[prop], obj[prop]);
    	        } else {
    	          extended[prop] = obj[prop];
    	        }
    	      }
    	    }
    	  };

    	  // Loop through each passed argument
    	  for (var i = 0; i < length; i++) {
    	    // store argument at position i
    	    var obj = arguments[i];

    	    // If we are in fact dealing with an object, merge it.
    	    if (isType('Object', obj)) {
    	      merge(obj);
    	    }
    	  }

    	  return extended;
    	};

    	/**
    	 * CSS transition end event listener
    	 * @return
    	 */
    	var whichTransitionEvent = exports.whichTransitionEvent = function whichTransitionEvent() {
    	  var t,
    	      el = document.createElement('fakeelement');

    	  var transitions = {
    	    'transition': 'transitionend',
    	    'OTransition': 'oTransitionEnd',
    	    'MozTransition': 'transitionend',
    	    'WebkitTransition': 'webkitTransitionEnd'
    	  };

    	  for (t in transitions) {
    	    if (el.style[t] !== undefined) {
    	      return transitions[t];
    	    }
    	  }
    	};

    	/**
    	 * CSS animation end event listener
    	 * @return
    	 */
    	var whichAnimationEvent = exports.whichAnimationEvent = function whichAnimationEvent() {
    	  var t,
    	      el = document.createElement('fakeelement');

    	  var animations = {
    	    'animation': 'animationend',
    	    'OAnimation': 'oAnimationEnd',
    	    'MozAnimation': 'animationend',
    	    'WebkitAnimation': 'webkitAnimationEnd'
    	  };

    	  for (t in animations) {
    	    if (el.style[t] !== undefined) {
    	      return animations[t];
    	    }
    	  }
    	};

    	/**
    	 *  Get the ancestors of each element in the current set of matched elements,
    	 *  up to but not including the element matched by the selector
    	 * @param  {NodeElement} elem     Element to begin search from
    	 * @param  {NodeElement} parent   Parent to find
    	 * @param  {String} selector Class to find
    	 * @return {Array}          Array of parent elements
    	 */
    	var getParentsUntil = exports.getParentsUntil = function getParentsUntil(elem, parent, selector) {
    	  var parents = [];
    	  // Get matches
    	  for (; elem && elem !== document; elem = elem.parentNode) {

    	    // Check if parent has been reached
    	    if (parent) {

    	      var parentType = parent.charAt(0);

    	      // If parent is a class
    	      if (parentType === '.') {
    	        if (elem.classList.contains(parent.substr(1))) {
    	          break;
    	        }
    	      }

    	      // If parent is an ID
    	      if (parentType === '#') {
    	        if (elem.id === parent.substr(1)) {
    	          break;
    	        }
    	      }

    	      // If parent is a data attribute
    	      if (parentType === '[') {
    	        if (elem.hasAttribute(parent.substr(1, parent.length - 1))) {
    	          break;
    	        }
    	      }

    	      // If parent is a tag
    	      if (elem.tagName.toLowerCase() === parent) {
    	        break;
    	      }
    	    }
    	    if (selector) {
    	      var selectorType = selector.charAt(0);

    	      // If selector is a class
    	      if (selectorType === '.') {
    	        if (elem.classList.contains(selector.substr(1))) {
    	          parents.push(elem);
    	        }
    	      }

    	      // If selector is an ID
    	      if (selectorType === '#') {
    	        if (elem.id === selector.substr(1)) {
    	          parents.push(elem);
    	        }
    	      }

    	      // If selector is a data attribute
    	      if (selectorType === '[') {
    	        if (elem.hasAttribute(selector.substr(1, selector.length - 1))) {
    	          parents.push(elem);
    	        }
    	      }

    	      // If selector is a tag
    	      if (elem.tagName.toLowerCase() === selector) {
    	        parents.push(elem);
    	      }
    	    } else {
    	      parents.push(elem);
    	    }
    	  }

    	  // Return parents if any exist
    	  if (parents.length === 0) {
    	    return null;
    	  } else {
    	    return parents;
    	  }
    	};

    	var wrap = exports.wrap = function wrap(element, wrapper) {
    	  wrapper = wrapper || document.createElement('div');
    	  if (element.nextSibling) {
    	    element.parentNode.insertBefore(wrapper, element.nextSibling);
    	  } else {
    	    element.parentNode.appendChild(wrapper);
    	  }
    	  return wrapper.appendChild(element);
    	};

    	var getSiblings = exports.getSiblings = function getSiblings(elem) {
    	  var siblings = [];
    	  var sibling = elem.parentNode.firstChild;
    	  for (; sibling; sibling = sibling.nextSibling) {
    	    if (sibling.nodeType === 1 && sibling !== elem) {
    	      siblings.push(sibling);
    	    }
    	  }
    	  return siblings;
    	};

    	/**
    	 * Find ancestor in DOM tree
    	 * @param  {NodeElement} el  Element to start search from
    	 * @param  {[type]} cls Class of parent
    	 * @return {NodeElement}     Found parent element
    	 */
    	var findAncestor = exports.findAncestor = function findAncestor(el, cls) {
    	  while ((el = el.parentElement) && !el.classList.contains(cls)) {}
    	  return el;
    	};

    	/**
    	 * Find ancestor in DOM tree by attribute name
    	 * @param  {NodeElement} el  Element to start search from
    	 * @param  {string} attr Attribute name of parent
    	 * @return {?NodeElement}     Found parent element or null
    	 */
    	var findAncestorByAttrName = exports.findAncestorByAttrName = function findAncestorByAttrName(el, attr) {
    	  var target = el;

    	  while (target) {
    	    if (target.hasAttribute(attr)) {
    	      return target;
    	    }

    	    target = target.parentElement;
    	  }

    	  return null;
    	};

    	/**
    	 * Debounce an event handler.
    	 * @param  {Function} func      Function to run after wait
    	 * @param  {Number} wait      The delay before the function is executed
    	 * @param  {Boolean} immediate  If  passed, trigger the function on the leading edge, instead of the trailing.
    	 * @return {Function}           A function will be called after it stops being called for a given delay
    	 */
    	var debounce = exports.debounce = function debounce(func, wait, immediate) {
    	  var timeout;
    	  return function () {
    	    var context = this,
    	        args = arguments;
    	    var later = function later() {
    	      timeout = null;
    	      if (!immediate) func.apply(context, args);
    	    };
    	    var callNow = immediate && !timeout;
    	    clearTimeout(timeout);
    	    timeout = setTimeout(later, wait);
    	    if (callNow) func.apply(context, args);
    	  };
    	};

    	/**
    	 * Get an element's distance from the top of the page
    	 * @private
    	 * @param  {NodeElement} el Element to test for
    	 * @return {Number} Elements Distance from top of page
    	 */
    	var getElemDistance = exports.getElemDistance = function getElemDistance(el) {
    	  var location = 0;
    	  if (el.offsetParent) {
    	    do {
    	      location += el.offsetTop;
    	      el = el.offsetParent;
    	    } while (el);
    	  }
    	  return location >= 0 ? location : 0;
    	};

    	/**
    	 * Determine element height multiplied by any offsets
    	 * @private
    	 * @param  {HTMLElement} el Element to test for
    	 * @return {Number}    Height of element
    	 */
    	var getElementOffset = exports.getElementOffset = function getElementOffset(el, offset) {
    	  var elOffset = offset;
    	  if (elOffset > 1) elOffset = 1;
    	  if (elOffset > 0) elOffset = 0;

    	  return Math.max(el.offsetHeight * elOffset);
    	};

    	/**
    	 * Get the next or previous element from a given start point
    	 * @param  {HTMLElement} startEl    Element to start position from
    	 * @param  {String}      className  The class we will look through
    	 * @param  {Number}      direction  Positive next element, negative previous element
    	 * @return {[HTMLElement}           Found element
    	 */
    	var getAdjacentEl = exports.getAdjacentEl = function getAdjacentEl(startEl, className) {
    	  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    	  if (!startEl || !className) return;

    	  var parent = startEl.parentNode.parentNode;
    	  var children = Array.from(parent.querySelectorAll(className));

    	  var startPos = children.indexOf(startEl);
    	  var operatorDirection = direction > 0 ? 1 : -1;

    	  return children[startPos + operatorDirection];
    	};

    	/**
    	 * Get scroll position based on top/bottom position
    	 * @private
    	 * @return {String} Position of scroll
    	 */
    	var getScrollPosition = exports.getScrollPosition = function getScrollPosition(position) {
    	  if (position === 'bottom') {
    	    // Scroll position from the bottom of the viewport
    	    return Math.max((window.scrollY || window.pageYOffset) + (window.innerHeight || document.documentElement.clientHeight));
    	  } else {
    	    // Scroll position from the top of the viewport
    	    return window.scrollY || window.pageYOffset;
    	  }
    	};

    	/**
    	 * Determine whether an element is within the viewport
    	 * @param  {HTMLElement}  el Element to test
    	 * @return {String} Position of scroll
    	 * @return {Boolean}
    	 */
    	var isInView = exports.isInView = function isInView(el, position, offset) {
    	  // If the user has scrolled further than the distance from the element to the top of its parent
    	  return this.getScrollPosition(position) > this.getElemDistance(el) + this.getElementOffset(el, offset) ? true : false;
    	};

    	/**
    	 * Determine whether an element is within
    	 * @param  {HTMLElement} el        Element to test
    	 * @param  {HTMLElement} parent    Scrolling parent
    	 * @param  {Number} direction      Whether element is visible from above or below
    	 * @return {Boolean}
    	 */
    	var isScrolledIntoView = exports.isScrolledIntoView = function isScrolledIntoView(el, parent) {
    	  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    	  if (!el) return;

    	  var isVisible = void 0;

    	  if (direction > 0) {
    	    // In view from bottom
    	    isVisible = parent.scrollTop + parent.offsetHeight >= el.offsetTop + el.offsetHeight;
    	  } else {
    	    // In view from top
    	    isVisible = el.offsetTop >= parent.scrollTop;
    	  }

    	  return isVisible;
    	};

    	/**
    	 * Escape html in a string
    	 * @param  {String} html  Initial string/html
    	 * @return {String}  Sanitised string
    	 */
    	var stripHTML = exports.stripHTML = function stripHTML(html) {
    	  return html.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
    	};

    	/**
    	 * Adds animation to an element and removes it upon animation completion
    	 * @param  {Element} el        Element to add animation to
    	 * @param  {String} animation Animation class to add to element
    	 * @return
    	 */
    	var addAnimation = exports.addAnimation = function addAnimation(el, animation) {
    	  var animationEvent = whichAnimationEvent();

    	  var removeAnimation = function removeAnimation() {
    	    el.classList.remove(animation);
    	    el.removeEventListener(animationEvent, removeAnimation, false);
    	  };

    	  el.classList.add(animation);
    	  el.addEventListener(animationEvent, removeAnimation, false);
    	};

    	/**
    	 * Get a random number between a range
    	 * @param  {Number} min Minimum range
    	 * @param  {Number} max Maximum range
    	 * @return {Number}     Random number
    	 */
    	var getRandomNumber = exports.getRandomNumber = function getRandomNumber(min, max) {
    	  return Math.floor(Math.random() * (max - min) + min);
    	};

    	/**
    	 * Turn a string into a node
    	 * @param  {String} String to convert
    	 * @return {HTMLElement}   Converted node element
    	 */
    	var strToEl = exports.strToEl = function () {
    	  var tmpEl = document.createElement('div');
    	  return function (str) {
    	    var cleanedInput = str.trim();
    	    var r = void 0;
    	    tmpEl.innerHTML = cleanedInput;
    	    r = tmpEl.children[0];

    	    while (tmpEl.firstChild) {
    	      tmpEl.removeChild(tmpEl.firstChild);
    	    }

    	    return r;
    	  };
    	}();

    	/**
    	 * Sets the width of a passed input based on its value
    	 * @return {Number} Width of input
    	 */
    	var getWidthOfInput = exports.getWidthOfInput = function getWidthOfInput(input) {
    	  var value = input.value || input.placeholder;
    	  var width = input.offsetWidth;

    	  if (value) {
    	    var testEl = strToEl('<span>' + stripHTML(value) + '</span>');
    	    testEl.style.position = 'absolute';
    	    testEl.style.padding = '0';
    	    testEl.style.top = '-9999px';
    	    testEl.style.left = '-9999px';
    	    testEl.style.width = 'auto';
    	    testEl.style.whiteSpace = 'pre';

    	    if (document.body.contains(input) && window.getComputedStyle) {
    	      var inputStyle = window.getComputedStyle(input);

    	      if (inputStyle) {
    	        testEl.style.fontSize = inputStyle.fontSize;
    	        testEl.style.fontFamily = inputStyle.fontFamily;
    	        testEl.style.fontWeight = inputStyle.fontWeight;
    	        testEl.style.fontStyle = inputStyle.fontStyle;
    	        testEl.style.letterSpacing = inputStyle.letterSpacing;
    	        testEl.style.textTransform = inputStyle.textTransform;
    	        testEl.style.padding = inputStyle.padding;
    	      }
    	    }

    	    document.body.appendChild(testEl);

    	    if (value && testEl.offsetWidth !== input.offsetWidth) {
    	      width = testEl.offsetWidth + 4;
    	    }

    	    document.body.removeChild(testEl);
    	  }

    	  return width + 'px';
    	};

    	/**
    	 * Sorting function for current and previous string
    	 * @param  {String} a Current value
    	 * @param  {String} b Next value
    	 * @return {Number}   -1 for after previous,
    	 *                    1 for before,
    	 *                    0 for same location
    	 */
    	var sortByAlpha = exports.sortByAlpha = function sortByAlpha(a, b) {
    	  var labelA = (a.label || a.value).toLowerCase();
    	  var labelB = (b.label || b.value).toLowerCase();

    	  if (labelA < labelB) return -1;
    	  if (labelA > labelB) return 1;
    	  return 0;
    	};

    	/**
    	 * Sort by numeric score
    	 * @param  {Object} a Current value
    	 * @param  {Object} b Next value
    	 * @return {Number}   -1 for after previous,
    	 *                    1 for before,
    	 *                    0 for same location
    	 */
    	var sortByScore = exports.sortByScore = function sortByScore(a, b) {
    	  return a.score - b.score;
    	};

    	/**
    	 * Trigger native event
    	 * @param  {NodeElement} element Element to trigger event on
    	 * @param  {String} type         Type of event to trigger
    	 * @param  {Object} customArgs   Data to pass with event
    	 * @return {Object}              Triggered event
    	 */
    	var triggerEvent = exports.triggerEvent = function triggerEvent(element, type) {
    	  var customArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    	  var event = new CustomEvent(type, {
    	    detail: customArgs,
    	    bubbles: true,
    	    cancelable: true
    	  });

    	  return element.dispatchEvent(event);
    	};

    /***/ }),
    /* 33 */
    /***/ (function(module, exports) {

    	/* eslint-disable */
    	(function () {
    	  // Production steps of ECMA-262, Edition 6, 22.1.2.1
    	  // Reference: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-array.from
    	  if (!Array.from) {
    	    Array.from = function () {
    	      var toStr = Object.prototype.toString;

    	      var isCallable = function isCallable(fn) {
    	        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    	      };

    	      var toInteger = function toInteger(value) {
    	        var number = Number(value);
    	        if (isNaN(number)) {
    	          return 0;
    	        }
    	        if (number === 0 || !isFinite(number)) {
    	          return number;
    	        }
    	        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    	      };

    	      var maxSafeInteger = Math.pow(2, 53) - 1;

    	      var toLength = function toLength(value) {
    	        var len = toInteger(value);
    	        return Math.min(Math.max(len, 0), maxSafeInteger);
    	      };

    	      // The length property of the from method is 1.
    	      return function from(arrayLike /*, mapFn, thisArg */) {
    	        // 1. Let C be the this value.
    	        var C = this;

    	        // 2. Let items be ToObject(arrayLike).
    	        var items = Object(arrayLike);

    	        // 3. ReturnIfAbrupt(items).
    	        if (arrayLike == null) {
    	          throw new TypeError("Array.from requires an array-like object - not null or undefined");
    	        }

    	        // 4. If mapfn is undefined, then let mapping be false.
    	        var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
    	        var T;
    	        if (typeof mapFn !== 'undefined') {
    	          // 5. else
    	          // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
    	          if (!isCallable(mapFn)) {
    	            throw new TypeError('Array.from: when provided, the second argument must be a function');
    	          }

    	          // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
    	          if (arguments.length > 2) {
    	            T = arguments[2];
    	          }
    	        }

    	        // 10. Let lenValue be Get(items, "length").
    	        // 11. Let len be ToLength(lenValue).
    	        var len = toLength(items.length);

    	        // 13. If IsConstructor(C) is true, then
    	        // 13. a. Let A be the result of calling the [[Construct]] internal method of C with an argument list containing the single item len.
    	        // 14. a. Else, Let A be ArrayCreate(len).
    	        var A = isCallable(C) ? Object(new C(len)) : new Array(len);

    	        // 16. Let k be 0.
    	        var k = 0;
    	        // 17. Repeat, while k < len (also steps a - h)
    	        var kValue;
    	        while (k < len) {
    	          kValue = items[k];
    	          if (mapFn) {
    	            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
    	          } else {
    	            A[k] = kValue;
    	          }
    	          k += 1;
    	        }
    	        // 18. Let putStatus be Put(A, "length", len, true).
    	        A.length = len;
    	        // 20. Return A.
    	        return A;
    	      };
    	    }();
    	  }

    	  // Reference: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find
    	  if (!Array.prototype.find) {
    	    Array.prototype.find = function (predicate) {

    	      if (this == null) {
    	        throw new TypeError('Array.prototype.find called on null or undefined');
    	      }
    	      if (typeof predicate !== 'function') {
    	        throw new TypeError('predicate must be a function');
    	      }
    	      var list = Object(this);
    	      var length = list.length >>> 0;
    	      var thisArg = arguments[1];
    	      var value;

    	      for (var i = 0; i < length; i++) {
    	        value = list[i];
    	        if (predicate.call(thisArg, value, i, list)) {
    	          return value;
    	        }
    	      }
    	      return undefined;
    	    };
    	  }

    	  function CustomEvent(event, params) {
    	    params = params || {
    	      bubbles: false,
    	      cancelable: false,
    	      detail: undefined
    	    };
    	    var evt = document.createEvent('CustomEvent');
    	    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    	    return evt;
    	  }

    	  CustomEvent.prototype = window.Event.prototype;

    	  window.CustomEvent = CustomEvent;
    	})();

    /***/ })
    /******/ ])
    });

    });

    var Choices = unwrapExports(choices);

    /* src\core\ui\inputs\MultiSelect.html generated by Svelte v2.9.5 */

    function mapToTypeaheadItems$1(items) {
    	return items.map(t => ({
    		label: t.label,
    		value: t.value.toString()
    	}));
    }

    function calculateFieldValue(field, value) {
    	if (field.maxItemCount === 1) {
    		let result = field.value;

    		result = {
    			value: value[0] != null ? value[0].value : null
    		};

    		// We need to convert the value to string, otherwise it doesn't work.
    		// This is due to the way UmfApp deals with url parameters (or something
    		// along those lines).
    		if (result.value != null) {
    			result.value = result.value.toString();
    		}

    		return result;
    	}

    	return {
    		items: value.map(t => t.value)
    	};
    }

    function setInputValue(a, field) {
    	if (field.maxItemCount === 1) {
    		const v = (field.value || {}).value || null;
    		if (v != null) {
    			a.setValueByChoice(v.toString());
    		}
    	}
    	else {
    		const v = ((field.value || {}).items || []).map(t => t.toString());
    		a.setValueByChoice(v);
    	}
    }

    function getIdsQuery(field) {
    	let currentValue = field.maxItemCount === 1 ?
    		[(field.value || {}).value || ""] :
    		(field.value || {}).items || [];

    	// Put values into an array.
    	if (currentValue[0] === "") {
    		currentValue = [];
    	}

    	return currentValue;
    }

    function buildFilter$1(parentForm, parameters, query) {
    	let promise;

    	const filter = { query };
    	if (parameters != null && parameters.length > 0) {
    		promise = parentForm.get().form.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}

    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}

    	return promise;
    }

    function populateChoicesWithAjax(choicesComponent, multiSelectComponent, existingChoices, query, selectedItemIds) {
    	const componentData = multiSelectComponent.get();
    	const { parameters, source } = componentData.field.metadata.customProperties;
    	const parentForm = componentData.form;
    	const { app } = componentData;

    	return new Promise(resolve => {
    		choicesComponent.ajax(callback => buildFilter$1(parentForm, parameters, query).then(filter => {
    			if (selectedItemIds != null) {
    				// eslint-disable-next-line no-param-reassign
    				filter.ids = { items: selectedItemIds };
    			}

    			return app.server.postForm(source, filter).then(data => {
    				// Mark items as added as "choices".
    				const toAdd = data.items.filter(t => {
    					const key = JSON.stringify(t.value);
    					if (existingChoices[key] == null) {
    						// eslint-disable-next-line no-param-reassign
    						existingChoices[key] = true;

    						// Add item.
    						return true;
    					}

    					// Don't add item.
    					return false;
    				});

    				callback(mapToTypeaheadItems$1(toAdd), "value", "label");

    				resolve();
    			});
    		}));
    	});
    }

    var methods$5 = {
    	onChange() {
    		this.get().form.fireAndBubbleUp("input:changed", {
    			app: this.get().app,
    			form: this.get().form,
    			input: this
    		});
    	}
    };

    function oncreate$b() {
    	const field = this.get().field;
    	const { source } = field.metadata.customProperties;
    	const a = new Choices(this.refs.input, {
    		duplicateItems: true,
    		searchResultLimit: 10,
    		removeItemButton: true,
    		maxItemCount: field.maxItemCount,
    		noChoicesText: "Please start typing to search..."
    	});

    	const formElement = this.refs.input.closest("form");
    	const self = this;
    	formElement.addEventListener("submit", () => {
    		if (typeof field.value.value === "undefined" && field.metadata.required) {
    			self.refs.input.parentElement.classList.add("divError");
    		}
    	});

    	if (typeof (source) === "string") {
    		const addedItems = {};
    		let query = "";
    		let timer = null;

    		a.passedElement.addEventListener("search", value => {
    			query = value.detail.value;

    			if (timer != null) {
    			// Cancel previous timer, thus extending the delay until user has stopped typing.
    				clearTimeout(timer);
    			}

    			// Search when user types something, but introduce a short delay
    			// to avoid excessive http requests.
    			timer = setTimeout(() => {
    				populateChoicesWithAjax(a, self, addedItems, query);
    			}, 300);
    		});

    		const currentValue = getIdsQuery(field);
    		populateChoicesWithAjax(a, self, addedItems, "");

    		// If the field has a value, we need to load it.
    		if (currentValue.length > 0) {
    			populateChoicesWithAjax(a, self, addedItems, query, currentValue)
    				.then(() => setInputValue(a, field));
    		}
    	}
    	else {
    		a.setChoices(mapToTypeaheadItems$1(source), "value", "label", true);
    	}

    	a.passedElement.addEventListener("change", () => {
    		field.value = calculateFieldValue(field, a.getValue());
    	});
    }
    function onstate({ changed, current }) {
    	if (changed.field) {
    		if (!current.initialized) {
    			current.initialized = true;
    			setInputValue(a, field);
    		}
    	}
    }
    const file$f = "src\\core\\ui\\inputs\\MultiSelect.html";

    function create_main_fragment$f(component, ctx) {
    	var select;

    	function change_handler(event) {
    		component.onChange();
    	}

    	return {
    		c: function create() {
    			select = createElement("select");
    			addListener(select, "change", change_handler);
    			select.className = "multi-select form-control";
    			select.id = ctx.id;
    			select.tabIndex = ctx.tabindex;
    			select.multiple = true;
    			addLoc(select, file$f, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(select, target, anchor);
    			component.refs.input = select;
    		},

    		p: function update(changed, ctx) {
    			if (changed.id) {
    				select.id = ctx.id;
    			}

    			if (changed.tabindex) {
    				select.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(select);
    			}

    			removeListener(select, "change", change_handler);
    			if (component.refs.input === select) component.refs.input = null;
    		}
    	};
    }

    function SvelteComponent$f(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._handlers.state = [onstate];

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$f(this, this._state);

    	this.root._oncreate.push(() => {
    		onstate.call(this, { changed: assignTrue({}, this._state), current: this._state });
    		oncreate$b.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$f.prototype, protoDev);
    assign(SvelteComponent$f.prototype, methods$5);

    SvelteComponent$f.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Number.html generated by Svelte v2.9.5 */

    function oncreate$c() {
    	const field = this.get().field;
    	const numberConfig = field.metadata.getCustomProperty("numberConfig") ||
    		{
    			minValue: null,
    			maxValue: null,
    			step: 1
    		};

    	this.set({
    		numberConfig
    	});
    }
    const file$g = "src\\core\\ui\\inputs\\Number.html";

    function create_main_fragment$g(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.numberConfig != null) && create_if_block$c(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.numberConfig != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$c(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if numberConfig != null}
    function create_if_block$c(component, ctx) {
    	var input, input_updating = false, input_required_value, input_step_value, input_min_value, input_max_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.value = toNumber(input.value);
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "number");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			input.step = input_step_value = ctx.numberConfig.step;
    			input.min = input_min_value = ctx.numberConfig.minValue;
    			input.max = input_max_value = ctx.numberConfig.maxValue;
    			addLoc(input, file$g, 1, 0, 28);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);

    			input.value = ctx.field.value;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating) input.value = ctx.field.value;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.numberConfig) && input_step_value !== (input_step_value = ctx.numberConfig.step)) {
    				input.step = input_step_value;
    			}

    			if ((changed.numberConfig) && input_min_value !== (input_min_value = ctx.numberConfig.minValue)) {
    				input.min = input_min_value;
    			}

    			if ((changed.numberConfig) && input_max_value !== (input_max_value = ctx.numberConfig.maxValue)) {
    				input.max = input_max_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    function SvelteComponent$g(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('numberConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'numberConfig'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$g(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$c.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$g.prototype, protoDev);

    SvelteComponent$g.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\NumberRange.html generated by Svelte v2.9.5 */

    function oncreate$d() {
    	const field = this.get().field;

    	if (field == null) {
    		return;
    	}

    	const numberConfig = (field.metadata.customProperties || {}).numberConfig || {
    		minValue: null,
    		maxValue: null,
    		step: 1
    	};

    	this.set({
    		numberConfig
    	});
    }
    const file$h = "src\\core\\ui\\inputs\\NumberRange.html";

    function add_css$8() {
    	var style = createElement("style");
    	style.id = 'svelte-6lg6r4-style';
    	style.textContent = ".input-group-addon.svelte-6lg6r4{font-size:0.8rem !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnVtYmVyUmFuZ2UuaHRtbCIsInNvdXJjZXMiOlsiTnVtYmVyUmFuZ2UuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIG51bWJlckNvbmZpZyAhPSBudWxsfVxyXG48ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cclxuICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIj5NaW48L3NwYW4+XHJcblx0PGlucHV0IHR5cGU9XCJudW1iZXJcIlxyXG5cdFx0YmluZDp2YWx1ZT1cImZpZWxkLnZhbHVlLm1pblwiXHJcblx0XHRyZXF1aXJlZD1cIntmaWVsZC5tZXRhZGF0YS5yZXF1aXJlZH1cIlxyXG5cdFx0dGFiaW5kZXg9XCJ7dGFiaW5kZXh9XCJcclxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXHJcbiAgICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIlxyXG4gICAgICAgIHN0ZXA9XCJ7bnVtYmVyQ29uZmlnLnN0ZXB9XCJcclxuICAgICAgICBtaW49XCJ7bnVtYmVyQ29uZmlnLm1pblZhbHVlfVwiXHJcbiAgICAgICAgbWF4PVwie251bWJlckNvbmZpZy5tYXhWYWx1ZX1cIj5cclxuXHJcbiAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uXCI+TWF4PC9zcGFuPlxyXG5cdDxpbnB1dCB0eXBlPVwibnVtYmVyXCJcclxuXHRcdGJpbmQ6dmFsdWU9XCJmaWVsZC52YWx1ZS5tYXhcIlxyXG5cdFx0cmVxdWlyZWQ9XCJ7ZmllbGQubWV0YWRhdGEucmVxdWlyZWR9XCJcclxuXHRcdHRhYmluZGV4PVwie3RhYmluZGV4fVwiXHJcblx0XHRhdXRvY29tcGxldGU9XCJvZmZcIlxyXG4gICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgICBzdGVwPVwie251bWJlckNvbmZpZy5zdGVwfVwiXHJcbiAgICAgICAgbWluPVwie251bWJlckNvbmZpZy5taW5WYWx1ZX1cIlxyXG4gICAgICAgIG1heD1cIntudW1iZXJDb25maWcubWF4VmFsdWV9XCI+XHJcbjwvZGl2PlxyXG57L2lmfVxyXG5cclxuPHNjcmlwdD5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgZmllbGQgPSB0aGlzLmdldCgpLmZpZWxkO1xyXG5cclxuXHRcdFx0aWYgKGZpZWxkID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG51bWJlckNvbmZpZyA9IChmaWVsZC5tZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzIHx8IHt9KS5udW1iZXJDb25maWcgfHwge1xyXG5cdFx0XHRcdG1pblZhbHVlOiBudWxsLFxyXG5cdFx0XHRcdG1heFZhbHVlOiBudWxsLFxyXG5cdFx0XHRcdHN0ZXA6IDFcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHRoaXMuc2V0KHtcclxuXHRcdFx0XHRudW1iZXJDb25maWdcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0XHQuaW5wdXQtZ3JvdXAtYWRkb24ge1xyXG5cdFx0XHRmb250LXNpemU6IDAuOHJlbSAhaW1wb3J0YW50O1xyXG5cdFx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaURFLGtCQUFrQixjQUFDLENBQUMsQUFDbkIsU0FBUyxDQUFFLE1BQU0sQ0FBQyxVQUFVLEFBQzdCLENBQUMifQ== */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$h(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.numberConfig != null) && create_if_block$d(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.numberConfig != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$d(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if numberConfig != null}
    function create_if_block$d(component, ctx) {
    	var div, span, text, text_1, input, input_updating = false, input_required_value, input_step_value, input_min_value, input_max_value, text_2, span_1, text_3, text_4, input_1, input_1_updating = false, input_1_required_value, input_1_step_value, input_1_min_value, input_1_max_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.value.min = toNumber(input.value);
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	function input_1_input_handler() {
    		input_1_updating = true;
    		ctx.field.value.max = toNumber(input_1.value);
    		component.set({ field: ctx.field });
    		input_1_updating = false;
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			span = createElement("span");
    			text = createText("Min");
    			text_1 = createText("\r\n\t");
    			input = createElement("input");
    			text_2 = createText("\r\n\r\n    ");
    			span_1 = createElement("span");
    			text_3 = createText("Max");
    			text_4 = createText("\r\n\t");
    			input_1 = createElement("input");
    			span.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span, file$h, 2, 4, 59);
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "number");
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.autocomplete = "off";
    			input.className = "form-control";
    			input.step = input_step_value = ctx.numberConfig.step;
    			input.min = input_min_value = ctx.numberConfig.minValue;
    			input.max = input_max_value = ctx.numberConfig.maxValue;
    			addLoc(input, file$h, 3, 1, 104);
    			span_1.className = "input-group-addon svelte-6lg6r4";
    			addLoc(span_1, file$h, 13, 4, 396);
    			addListener(input_1, "input", input_1_input_handler);
    			setAttribute(input_1, "type", "number");
    			input_1.required = input_1_required_value = ctx.field.metadata.required;
    			input_1.tabIndex = ctx.tabindex;
    			input_1.autocomplete = "off";
    			input_1.className = "form-control";
    			input_1.step = input_1_step_value = ctx.numberConfig.step;
    			input_1.min = input_1_min_value = ctx.numberConfig.minValue;
    			input_1.max = input_1_max_value = ctx.numberConfig.maxValue;
    			addLoc(input_1, file$h, 14, 1, 441);
    			div.className = "input-group";
    			addLoc(div, file$h, 1, 0, 28);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(span, div);
    			appendNode(text, span);
    			appendNode(text_1, div);
    			appendNode(input, div);

    			input.value = ctx.field.value.min;

    			appendNode(text_2, div);
    			appendNode(span_1, div);
    			appendNode(text_3, span_1);
    			appendNode(text_4, div);
    			appendNode(input_1, div);

    			input_1.value = ctx.field.value.max;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating) input.value = ctx.field.value.min;
    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}

    			if ((changed.numberConfig) && input_step_value !== (input_step_value = ctx.numberConfig.step)) {
    				input.step = input_step_value;
    			}

    			if ((changed.numberConfig) && input_min_value !== (input_min_value = ctx.numberConfig.minValue)) {
    				input.min = input_min_value;
    			}

    			if ((changed.numberConfig) && input_max_value !== (input_max_value = ctx.numberConfig.maxValue)) {
    				input.max = input_max_value;
    			}

    			if (!input_1_updating) input_1.value = ctx.field.value.max;
    			if ((changed.field) && input_1_required_value !== (input_1_required_value = ctx.field.metadata.required)) {
    				input_1.required = input_1_required_value;
    			}

    			if (changed.tabindex) {
    				input_1.tabIndex = ctx.tabindex;
    			}

    			if ((changed.numberConfig) && input_1_step_value !== (input_1_step_value = ctx.numberConfig.step)) {
    				input_1.step = input_1_step_value;
    			}

    			if ((changed.numberConfig) && input_1_min_value !== (input_1_min_value = ctx.numberConfig.minValue)) {
    				input_1.min = input_1_min_value;
    			}

    			if ((changed.numberConfig) && input_1_max_value !== (input_1_max_value = ctx.numberConfig.maxValue)) {
    				input_1.max = input_1_max_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(input, "input", input_input_handler);
    			removeListener(input_1, "input", input_1_input_handler);
    		}
    	};
    }

    function SvelteComponent$h(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('numberConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'numberConfig'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-6lg6r4-style")) add_css$8();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$h(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$d.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$h.prototype, protoDev);

    SvelteComponent$h.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Password.html generated by Svelte v2.9.5 */

    var methods$6 = {
    	onChange(confirmPassword) {
    		if (this.get().field.selected !== confirmPassword.value) {
    			confirmPassword
    				.setCustomValidity("Passwords do not match. Please make sure they are exactly the same.");
    		}
    		else {
    			confirmPassword.setCustomValidity("");
    		}
    	}
    };

    function oncreate$e() {
    	const field = this.get().field;
    	const config = (field.metadata.customProperties || {}).passwordInputConfig;

    	this.set({
    		passwordConfig: config || {
    			regex: null,
    			requireConfirmation: null
    		}
    	});
    }
    const file$i = "src\\core\\ui\\inputs\\Password.html";

    function add_css$9() {
    	var style = createElement("style");
    	style.id = 'svelte-1igx5hi-style';
    	style.textContent = "span.svelte-1igx5hi{color:#9a9a9a;font-size:13px;margin-bottom:5px;display:block}.confirmation-password.svelte-1igx5hi{padding-top:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFzc3dvcmQuaHRtbCIsInNvdXJjZXMiOlsiUGFzc3dvcmQuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHBhc3N3b3JkQ29uZmlnICE9IG51bGx9XHJcbiAgICB7I2lmIHBhc3N3b3JkQ29uZmlnLnJlZ2V4fVxyXG4gICAgICAgIDxzcGFuPntwYXNzd29yZENvbmZpZy5yZWdleERlc2NyaXB0aW9ufTwvc3Bhbj5cclxuXHRcdDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIlxyXG5cdFx0XHRpZD1cIntpZH1cIlxyXG5cdFx0XHRiaW5kOnZhbHVlPVwiZmllbGQuc2VsZWN0ZWRcIlxyXG5cdFx0XHRwYXR0ZXJuPVwie3Bhc3N3b3JkQ29uZmlnLnJlZ2V4fVwiXHJcblx0XHRcdHJlcXVpcmVkPVwie2ZpZWxkLm1ldGFkYXRhLnJlcXVpcmVkfVwiXHJcblx0XHRcdHRhYmluZGV4PVwie3RhYmluZGV4fVwiXHJcblx0XHRcdGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XHJcbiAgICB7OmVsc2V9XHJcblx0PGlucHV0IHR5cGU9XCJwYXNzd29yZFwiXHJcblx0XHRpZD1cIntpZH1cIlxyXG5cdFx0YmluZDp2YWx1ZT1cImZpZWxkLnNlbGVjdGVkXCJcclxuXHRcdHJlcXVpcmVkPVwie2ZpZWxkLm1ldGFkYXRhLnJlcXVpcmVkfVwiXHJcblx0XHR0YWJpbmRleD1cInt0YWJpbmRleH1cIlxyXG5cdFx0Y2xhc3M9XCJmb3JtLWNvbnRyb2xcIj5cclxuICAgIHsvaWZ9XHJcbiAgICB7I2lmIHBhc3N3b3JkQ29uZmlnLnJlcXVpcmVDb25maXJtYXRpb259XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29uZmlybWF0aW9uLXBhc3N3b3JkXCI+XHJcblx0XHQ8aW5wdXQgcGxhY2Vob2xkZXI9XCJQbGVhc2UgY29uZmlybSB0aGUgcGFzc3dvcmQgYnkgZW50ZXJpbmcgaXQgb25lIG1vcmUgdGltZS5cIlxyXG5cdFx0XHR0eXBlPVwicGFzc3dvcmRcIlxyXG5cdFx0XHRvbjpjaGFuZ2U9XCJvbkNoYW5nZSh0aGlzKVwiXHJcblx0XHRcdHJlcXVpcmVkPVwie2ZpZWxkLm1ldGFkYXRhLnJlcXVpcmVkfVwiXHJcblx0XHRcdHRhYmluZGV4PVwie3RhYmluZGV4ICsgMX1cIlxyXG5cdFx0XHRjbGFzcz1cImZvcm0tY29udHJvbFwiPlxyXG4gICAgPC9kaXY+XHJcbiAgICB7L2lmfVxyXG57L2lmfVxyXG5cclxuXHJcbjxzY3JpcHQ+XHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHRcdFx0Y29uc3QgY29uZmlnID0gKGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMgfHwge30pLnBhc3N3b3JkSW5wdXRDb25maWc7XHJcblxyXG5cdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0cGFzc3dvcmRDb25maWc6IGNvbmZpZyB8fCB7XHJcblx0XHRcdFx0XHRyZWdleDogbnVsbCxcclxuXHRcdFx0XHRcdHJlcXVpcmVDb25maXJtYXRpb246IG51bGxcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0b25DaGFuZ2UoY29uZmlybVBhc3N3b3JkKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuZ2V0KCkuZmllbGQuc2VsZWN0ZWQgIT09IGNvbmZpcm1QYXNzd29yZC52YWx1ZSkge1xyXG5cdFx0XHRcdFx0Y29uZmlybVBhc3N3b3JkXHJcblx0XHRcdFx0XHRcdC5zZXRDdXN0b21WYWxpZGl0eShcIlBhc3N3b3JkcyBkbyBub3QgbWF0Y2guIFBsZWFzZSBtYWtlIHN1cmUgdGhleSBhcmUgZXhhY3RseSB0aGUgc2FtZS5cIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uZmlybVBhc3N3b3JkLnNldEN1c3RvbVZhbGlkaXR5KFwiXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdFx0c3BhbiB7XHJcblx0XHRcdGNvbG9yOiAjOWE5YTlhO1xyXG5cdFx0XHRmb250LXNpemU6IDEzcHg7XHJcblx0XHRcdG1hcmdpbi1ib3R0b206IDVweDtcclxuXHRcdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHR9XHJcblxyXG5cdFx0LmNvbmZpcm1hdGlvbi1wYXNzd29yZCB7XHJcblx0XHRcdHBhZGRpbmctdG9wOiAxMHB4O1xyXG5cdFx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMkRFLElBQUksZUFBQyxDQUFDLEFBQ0wsS0FBSyxDQUFFLE9BQU8sQ0FDZCxTQUFTLENBQUUsSUFBSSxDQUNmLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxLQUFLLEFBQ2YsQ0FBQyxBQUVELHNCQUFzQixlQUFDLENBQUMsQUFDdkIsV0FBVyxDQUFFLElBQUksQUFDbEIsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$i(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.passwordConfig != null) && create_if_block$e(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.passwordConfig != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$e(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (2:4) {#if passwordConfig.regex}
    function create_if_block_1$9(component, ctx) {
    	var span, text_value = ctx.passwordConfig.regexDescription, text, text_1, input, input_updating = false, input_pattern_value, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.selected = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(text_value);
    			text_1 = createText("\r\n\t\t");
    			input = createElement("input");
    			span.className = "svelte-1igx5hi";
    			addLoc(span, file$i, 2, 8, 70);
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "password");
    			input.id = ctx.id;
    			input.pattern = input_pattern_value = ctx.passwordConfig.regex;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$i, 3, 2, 120);
    		},

    		m: function mount(target, anchor) {
    			insertNode(span, target, anchor);
    			appendNode(text, span);
    			insertNode(text_1, target, anchor);
    			insertNode(input, target, anchor);

    			input.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if ((changed.passwordConfig) && text_value !== (text_value = ctx.passwordConfig.regexDescription)) {
    				text.data = text_value;
    			}

    			if (!input_updating) input.value = ctx.field.selected;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.passwordConfig) && input_pattern_value !== (input_pattern_value = ctx.passwordConfig.regex)) {
    				input.pattern = input_pattern_value;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    				detachNode(text_1);
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    // (11:4) {:else}
    function create_if_block_2$7(component, ctx) {
    	var input, input_updating = false, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.selected = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "password");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$i, 11, 1, 334);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);

    			input.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating) input.value = ctx.field.selected;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    // (19:4) {#if passwordConfig.requireConfirmation}
    function create_if_block_3$5(component, ctx) {
    	var div, input, input_required_value, input_tabindex_value;

    	function change_handler(event) {
    		component.onChange(this);
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			input.placeholder = "Please confirm the password by entering it one more time.";
    			setAttribute(input, "type", "password");
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = input_tabindex_value = ctx.tabindex + 1;
    			input.className = "form-control";
    			addLoc(input, file$i, 20, 2, 592);
    			div.className = "confirmation-password svelte-1igx5hi";
    			addLoc(div, file$i, 19, 4, 553);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(input, div);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if ((changed.tabindex) && input_tabindex_value !== (input_tabindex_value = ctx.tabindex + 1)) {
    				input.tabIndex = input_tabindex_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (1:0) {#if passwordConfig != null}
    function create_if_block$e(component, ctx) {
    	var text, if_block_1_anchor;

    	function select_block_type(ctx) {
    		if (ctx.passwordConfig.regex) return create_if_block_1$9;
    		return create_if_block_2$7;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	var if_block_1 = (ctx.passwordConfig.requireConfirmation) && create_if_block_3$5(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			text = createText("\r\n    ");
    			if (if_block_1) if_block_1.c();
    			if_block_1_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(text, target, anchor);
    			if (if_block_1) if_block_1.m(target, anchor);
    			insertNode(if_block_1_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(text.parentNode, text);
    			}

    			if (ctx.passwordConfig.requireConfirmation) {
    				if (if_block_1) {
    					if_block_1.p(changed, ctx);
    				} else {
    					if_block_1 = create_if_block_3$5(component, ctx);
    					if_block_1.c();
    					if_block_1.m(if_block_1_anchor.parentNode, if_block_1_anchor);
    				}
    			} else if (if_block_1) {
    				if_block_1.d(1);
    				if_block_1 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(text);
    			}

    			if (if_block_1) if_block_1.d(detach);
    			if (detach) {
    				detachNode(if_block_1_anchor);
    			}
    		}
    	};
    }

    function SvelteComponent$i(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('passwordConfig' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'passwordConfig'");
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1igx5hi-style")) add_css$9();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$i(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$e.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$i.prototype, protoDev);
    assign(SvelteComponent$i.prototype, methods$6);

    SvelteComponent$i.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Text.html generated by Svelte v2.9.5 */

    const file$j = "src\\core\\ui\\inputs\\Text.html";

    function create_main_fragment$j(component, ctx) {
    	var input, input_updating = false, input_required_value;

    	function input_input_handler() {
    		input_updating = true;
    		ctx.field.value = input.value;
    		component.set({ field: ctx.field });
    		input_updating = false;
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			addListener(input, "input", input_input_handler);
    			setAttribute(input, "type", "text");
    			input.id = ctx.id;
    			input.required = input_required_value = ctx.field.metadata.required;
    			input.tabIndex = ctx.tabindex;
    			input.className = "form-control";
    			addLoc(input, file$j, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);

    			input.value = ctx.field.value;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!input_updating) input.value = ctx.field.value;
    			if (changed.id) {
    				input.id = ctx.id;
    			}

    			if ((changed.field) && input_required_value !== (input_required_value = ctx.field.metadata.required)) {
    				input.required = input_required_value;
    			}

    			if (changed.tabindex) {
    				input.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "input", input_input_handler);
    		}
    	};
    }

    function SvelteComponent$j(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	this._fragment = create_main_fragment$j(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$j.prototype, protoDev);

    SvelteComponent$j.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\inputs\Textarea.html generated by Svelte v2.9.5 */

    const file$k = "src\\core\\ui\\inputs\\Textarea.html";

    function add_css$a() {
    	var style = createElement("style");
    	style.id = 'svelte-wch87u-style';
    	style.textContent = "textarea.svelte-wch87u{width:100%;height:100px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dGFyZWEuaHRtbCIsInNvdXJjZXMiOlsiVGV4dGFyZWEuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGV4dGFyZWFcclxuXHRpZD1cIntpZH1cIlxyXG5cdGJpbmQ6dmFsdWU9XCJmaWVsZC5zZWxlY3RlZFwiXHJcblx0cmVxdWlyZWQ9XCJ7ZmllbGQubWV0YWRhdGEucmVxdWlyZWR9XCJcclxuXHR0YWJpbmRleD1cInt0YWJpbmRleH1cIlxyXG5cdGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XHJcbjwvdGV4dGFyZWE+XHJcblxyXG48c3R5bGU+XHJcblx0dGV4dGFyZWEge1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMHB4O1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNDLFFBQVEsY0FBQyxDQUFDLEFBQ1QsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsS0FBSyxBQUNkLENBQUMifQ== */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$k(component, ctx) {
    	var textarea, textarea_updating = false, textarea_required_value;

    	function textarea_input_handler() {
    		textarea_updating = true;
    		ctx.field.selected = textarea.value;
    		component.set({ field: ctx.field });
    		textarea_updating = false;
    	}

    	return {
    		c: function create() {
    			textarea = createElement("textarea");
    			addListener(textarea, "input", textarea_input_handler);
    			textarea.id = ctx.id;
    			textarea.required = textarea_required_value = ctx.field.metadata.required;
    			textarea.tabIndex = ctx.tabindex;
    			textarea.className = "form-control svelte-wch87u";
    			textarea.value = "\r\n";
    			addLoc(textarea, file$k, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(textarea, target, anchor);

    			textarea.value = ctx.field.selected;
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!textarea_updating) textarea.value = ctx.field.selected;
    			if (changed.id) {
    				textarea.id = ctx.id;
    			}

    			if ((changed.field) && textarea_required_value !== (textarea_required_value = ctx.field.metadata.required)) {
    				textarea.required = textarea_required_value;
    			}

    			if (changed.tabindex) {
    				textarea.tabIndex = ctx.tabindex;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(textarea);
    			}

    			removeListener(textarea, "input", textarea_input_handler);
    		}
    	};
    }

    function SvelteComponent$k(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('id' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'id'");
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('tabindex' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'tabindex'");
    	this._intro = true;

    	if (!document.getElementById("svelte-wch87u-style")) add_css$a();

    	this._fragment = create_main_fragment$k(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$k.prototype, protoDev);

    SvelteComponent$k.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /**
     * Represents an event triggered by an action-list.
     */
    var ActionListEventArguments = /** @class */ (function (_super) {
        __extends(ActionListEventArguments, _super);
        function ActionListEventArguments(app, actionFormId) {
            var _this = _super.call(this, app) || this;
            _this.actionFormId = actionFormId;
            return _this;
        }
        return ActionListEventArguments;
    }(FormEventArguments));

    /* src\core\ui\outputs\ActionList.html generated by Svelte v2.9.5 */

    const alertify$1 = alertify;

    let modalId = 0;
    const modals = [];

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    document.addEventListener("keydown", e => {
    	const evt = e || window.event;
    	let isEscape = false;
    	if ("key" in evt) {
    		isEscape = (evt.key === "Escape" || evt.key === "Esc");
    	}
    	else {
    		isEscape = (evt.keyCode === 27);
    	}
    	if (isEscape) {
    		if (modals.length > 0) {
    			// Close topmost modal.
    			modals[modals.length - 1].close();
    		}
    	}
    });

    function data$7() {
    	modalId += 1;
    	return {
    		open: false,
    		current: null,
    		modalId
    	};
    }
    var methods$7 = {
    	async run(action, app) {
    		const self = this;
    		const formInstance = app.getFormInstance(action.form, true);

    		// TODO: find a way to initialize from action.inputFieldValues directly.
    		const serializedInputValues = formInstance.getSerializedInputValuesFromObject(action.inputFieldValues);
    		await formInstance.initializeInputFields(serializedInputValues);

    		const allRequiredInputsHaveData = await formInstance.allRequiredInputsHaveData(false);
    		if (action.action === "run" && allRequiredInputsHaveData) {
    			if (action.confirmationMessage) {
    				alertify$1.confirm(
    					"Warning",
    					action.confirmationMessage,
    					async () => {
    						const response = await formInstance.submit(self.get().app, false);
    						self.onActionRun(formInstance.metadata.id, response, action);
    					},
    					() => { }
    				);
    			}
    			else {
    				const response = await formInstance.submit(this.get().app, false);
    				this.onActionRun(formInstance.metadata.id, response, action);
    			}
    		}
    		else {
    			this.set({ open: true });

    			const f = new SvelteComponent$8({
    				target: this.refs.container,
    				data: {
    					metadata: formInstance.metadata,
    					form: formInstance,
    					app,
    					useUrl: false
    				}
    			});

    			f.init();

    			f.on("form:responseHandled", e => {
    				if (e.invokedByUser && formInstance.metadata.closeOnPostIfModal) {
    					self.close(e.response);
    				}
    			});

    			this.set({ current: f });

    			modals.push(self);
    		}
    	},
    	close(response) {
    		this.set({ open: false });

    		// Destroy underlying form instance.
    		const modalForm = this.get().current;

    		if (response != null) {
    			const formId = modalForm.get().metadata.id;
    			this.onActionRun(formId, response);
    		}

    		modalForm.destroy();
    		modals.pop();
    	},
    	async onActionRun(formId, response) {
    		const parentForm = this.get().parent;
    		const { app } = parentForm.get();

    		if (response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload") {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentForm.submit(null, true);
    		}

    		const eventArgs = new ActionListEventArguments(app, formId);
    		parentForm.fireAndBubbleUp("action-list:run", eventArgs);
    	}
    };

    const file$l = "src\\core\\ui\\outputs\\ActionList.html";

    function add_css$b() {
    	var style = createElement("style");
    	style.id = 'svelte-1yns50m-style';
    	style.textContent = ".hidden.svelte-1yns50m{width:0;height:0;position:absolute;left:-1000px}.actionlist.svelte-1yns50m{margin:0 0;padding:0 5px;text-align:right;margin-bottom:15px}.actionlist.svelte-1yns50m>li.svelte-1yns50m{list-style-type:none;display:inline-block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWN0aW9uTGlzdC5odG1sIiwic291cmNlcyI6WyJBY3Rpb25MaXN0Lmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBmaWVsZC5kYXRhICE9IG51bGwgJiYgZmllbGQuZGF0YS5hY3Rpb25zICE9IG51bGwgJiYgZmllbGQuZGF0YS5hY3Rpb25zLmxlbmd0aCA+IDB9XHJcbjx1bCBjbGFzcz1cImFjdGlvbmxpc3RcIj5cclxuXHR7I2VhY2ggZmllbGQuZGF0YS5hY3Rpb25zIGFzIGFjdGlvbn1cclxuXHQ8bGk+XHJcblx0XHR7I2lmIGFjdGlvbi5hY3Rpb24gIT09IFwicmVkaXJlY3RcIn1cclxuXHRcdDxidXR0b24gb246Y2xpY2s9XCJydW4oYWN0aW9uLCBhcHApXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQge2FjdGlvbi5jc3NDbGFzc31cIj57QGh0bWwgYWN0aW9uLmxhYmVsfTwvYnV0dG9uPlxyXG5cdFx0ezplbHNlIH1cclxuXHRcdDxhIGhyZWY9XCJ7YXBwLm1ha2VVcmwoYWN0aW9uLmZvcm0sIGFjdGlvbi5pbnB1dEZpZWxkVmFsdWVzKX1cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCB7YWN0aW9uLmNzc0NsYXNzfVwiPnthY3Rpb24ubGFiZWx9PC9hPlxyXG5cdFx0ey9pZn1cclxuXHQ8L2xpPlxyXG5cdHsvZWFjaH1cclxuPC91bD5cclxuXHJcbjxpbnB1dCBpZD1cIm1vZGFsLXttb2RhbElkfVwiIHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD1cIm9wZW5cIiBjbGFzcz1cImhpZGRlblwiIC8+XHJcbjxkaXYgY2xhc3M9XCJtb2RhbFwiPlxyXG5cdDxkaXYgY2xhc3M9XCJjYXJkXCI+XHJcblx0XHQ8bGFiZWwgY2xhc3M9XCJjbG9zZVwiIG9uOmNsaWNrPVwiY2xvc2UoKVwiPjwvbGFiZWw+XHJcblx0XHQ8ZGl2IHJlZjpjb250YWluZXI+PC9kaXY+XHJcblx0PC9kaXY+XHJcbjwvZGl2PlxyXG57L2lmfVxyXG5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgRm9ybUNvbXBvbmVudCBmcm9tIFwiY29yZS11aS9Gb3JtXCI7XHJcblx0aW1wb3J0ICogYXMgYWxlcnRpZnlMaWIgZnJvbSBcImFsZXJ0aWZ5anNcIjtcclxuXHRpbXBvcnQgeyBBY3Rpb25MaXN0RXZlbnRBcmd1bWVudHMgfSBmcm9tIFwiLi9BY3Rpb25MaXN0RXZlbnRBcmd1bWVudHNcIjtcclxuXHJcblx0Y29uc3QgYWxlcnRpZnkgPSBhbGVydGlmeUxpYi5kZWZhdWx0O1xyXG5cclxuXHRsZXQgbW9kYWxJZCA9IDA7XHJcblx0Y29uc3QgbW9kYWxzID0gW107XHJcblxyXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzY5NzQzLzExMTQzOFxyXG5cdC8vIENsb3NlIHRvcG1vc3QgbW9kYWwgd2hlbiB1c2VyIHByZXNzZXMgZXNjYXBlIGtleS5cclxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBlID0+IHtcclxuXHRcdGNvbnN0IGV2dCA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0bGV0IGlzRXNjYXBlID0gZmFsc2U7XHJcblx0XHRpZiAoXCJrZXlcIiBpbiBldnQpIHtcclxuXHRcdFx0aXNFc2NhcGUgPSAoZXZ0LmtleSA9PT0gXCJFc2NhcGVcIiB8fCBldnQua2V5ID09PSBcIkVzY1wiKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpc0VzY2FwZSA9IChldnQua2V5Q29kZSA9PT0gMjcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGlzRXNjYXBlKSB7XHJcblx0XHRcdGlmIChtb2RhbHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdC8vIENsb3NlIHRvcG1vc3QgbW9kYWwuXHJcblx0XHRcdFx0bW9kYWxzW21vZGFscy5sZW5ndGggLSAxXS5jbG9zZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0YXN5bmMgcnVuKGFjdGlvbiwgYXBwKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XHJcblx0XHRcdFx0Y29uc3QgZm9ybUluc3RhbmNlID0gYXBwLmdldEZvcm1JbnN0YW5jZShhY3Rpb24uZm9ybSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IGZpbmQgYSB3YXkgdG8gaW5pdGlhbGl6ZSBmcm9tIGFjdGlvbi5pbnB1dEZpZWxkVmFsdWVzIGRpcmVjdGx5LlxyXG5cdFx0XHRcdGNvbnN0IHNlcmlhbGl6ZWRJbnB1dFZhbHVlcyA9IGZvcm1JbnN0YW5jZS5nZXRTZXJpYWxpemVkSW5wdXRWYWx1ZXNGcm9tT2JqZWN0KGFjdGlvbi5pbnB1dEZpZWxkVmFsdWVzKTtcclxuXHRcdFx0XHRhd2FpdCBmb3JtSW5zdGFuY2UuaW5pdGlhbGl6ZUlucHV0RmllbGRzKHNlcmlhbGl6ZWRJbnB1dFZhbHVlcyk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFsbFJlcXVpcmVkSW5wdXRzSGF2ZURhdGEgPSBhd2FpdCBmb3JtSW5zdGFuY2UuYWxsUmVxdWlyZWRJbnB1dHNIYXZlRGF0YShmYWxzZSk7XHJcblx0XHRcdFx0aWYgKGFjdGlvbi5hY3Rpb24gPT09IFwicnVuXCIgJiYgYWxsUmVxdWlyZWRJbnB1dHNIYXZlRGF0YSkge1xyXG5cdFx0XHRcdFx0aWYgKGFjdGlvbi5jb25maXJtYXRpb25NZXNzYWdlKSB7XHJcblx0XHRcdFx0XHRcdGFsZXJ0aWZ5LmNvbmZpcm0oXHJcblx0XHRcdFx0XHRcdFx0XCJXYXJuaW5nXCIsXHJcblx0XHRcdFx0XHRcdFx0YWN0aW9uLmNvbmZpcm1hdGlvbk1lc3NhZ2UsXHJcblx0XHRcdFx0XHRcdFx0YXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmb3JtSW5zdGFuY2Uuc3VibWl0KHNlbGYuZ2V0KCkuYXBwLCBmYWxzZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRzZWxmLm9uQWN0aW9uUnVuKGZvcm1JbnN0YW5jZS5tZXRhZGF0YS5pZCwgcmVzcG9uc2UsIGFjdGlvbik7XHJcblx0XHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0XHQoKSA9PiB7IH1cclxuXHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGZvcm1JbnN0YW5jZS5zdWJtaXQodGhpcy5nZXQoKS5hcHAsIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5vbkFjdGlvblJ1bihmb3JtSW5zdGFuY2UubWV0YWRhdGEuaWQsIHJlc3BvbnNlLCBhY3Rpb24pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuc2V0KHsgb3BlbjogdHJ1ZSB9KTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBmID0gbmV3IEZvcm1Db21wb25lbnQoe1xyXG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMucmVmcy5jb250YWluZXIsXHJcblx0XHRcdFx0XHRcdGRhdGE6IHtcclxuXHRcdFx0XHRcdFx0XHRtZXRhZGF0YTogZm9ybUluc3RhbmNlLm1ldGFkYXRhLFxyXG5cdFx0XHRcdFx0XHRcdGZvcm06IGZvcm1JbnN0YW5jZSxcclxuXHRcdFx0XHRcdFx0XHRhcHAsXHJcblx0XHRcdFx0XHRcdFx0dXNlVXJsOiBmYWxzZVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHRmLmluaXQoKTtcclxuXHJcblx0XHRcdFx0XHRmLm9uKFwiZm9ybTpyZXNwb25zZUhhbmRsZWRcIiwgZSA9PiB7XHJcblx0XHRcdFx0XHRcdGlmIChlLmludm9rZWRCeVVzZXIgJiYgZm9ybUluc3RhbmNlLm1ldGFkYXRhLmNsb3NlT25Qb3N0SWZNb2RhbCkge1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoZS5yZXNwb25zZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuc2V0KHsgY3VycmVudDogZiB9KTtcclxuXHJcblx0XHRcdFx0XHRtb2RhbHMucHVzaChzZWxmKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGNsb3NlKHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBvcGVuOiBmYWxzZSB9KTtcclxuXHJcblx0XHRcdFx0Ly8gRGVzdHJveSB1bmRlcmx5aW5nIGZvcm0gaW5zdGFuY2UuXHJcblx0XHRcdFx0Y29uc3QgbW9kYWxGb3JtID0gdGhpcy5nZXQoKS5jdXJyZW50O1xyXG5cclxuXHRcdFx0XHRpZiAocmVzcG9uc2UgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgZm9ybUlkID0gbW9kYWxGb3JtLmdldCgpLm1ldGFkYXRhLmlkO1xyXG5cdFx0XHRcdFx0dGhpcy5vbkFjdGlvblJ1bihmb3JtSWQsIHJlc3BvbnNlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1vZGFsRm9ybS5kZXN0cm95KCk7XHJcblx0XHRcdFx0bW9kYWxzLnBvcCgpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRhc3luYyBvbkFjdGlvblJ1bihmb3JtSWQsIHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0Y29uc3QgcGFyZW50Rm9ybSA9IHRoaXMuZ2V0KCkucGFyZW50O1xyXG5cdFx0XHRcdGNvbnN0IHsgYXBwIH0gPSBwYXJlbnRGb3JtLmdldCgpO1xyXG5cclxuXHRcdFx0XHRpZiAocmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWRpcmVjdFwiICYmXHJcblx0XHRcdFx0XHRyZXNwb25zZS5tZXRhZGF0YS5oYW5kbGVyICE9PSBcInJlbG9hZFwiKSB7XHJcblx0XHRcdFx0XHQvLyBJZiBhc2tlZCB0byByZWRpcmVjdCB0byBhbm90aGVyIGZvcm0sIHRoZW4gd2UgcmVkaXJlY3RcclxuXHRcdFx0XHRcdC8vIGFuZCBkbyBub3QgcmVsb2FkIHBhcmVudCBmb3JtLCBhcyB0aGF0IHdvdWxkIGJlIGEgd2FzdGVkIGVmZm9ydC5cclxuXHRcdFx0XHRcdGF3YWl0IHBhcmVudEZvcm0uc3VibWl0KG51bGwsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgZXZlbnRBcmdzID0gbmV3IEFjdGlvbkxpc3RFdmVudEFyZ3VtZW50cyhhcHAsIGZvcm1JZCk7XHJcblx0XHRcdFx0cGFyZW50Rm9ybS5maXJlQW5kQnViYmxlVXAoXCJhY3Rpb24tbGlzdDpydW5cIiwgZXZlbnRBcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdGRhdGEoKSB7XHJcblx0XHRcdG1vZGFsSWQgKz0gMTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRvcGVuOiBmYWxzZSxcclxuXHRcdFx0XHRjdXJyZW50OiBudWxsLFxyXG5cdFx0XHRcdG1vZGFsSWRcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQuaGlkZGVuIHtcclxuXHRcdHdpZHRoOiAwO1xyXG5cdFx0aGVpZ2h0OiAwO1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0bGVmdDogLTEwMDBweDtcclxuXHR9XHJcblxyXG5cdC5hY3Rpb25saXN0IHtcclxuXHRcdG1hcmdpbjogMCAwO1xyXG5cdFx0cGFkZGluZzogMCA1cHg7XHJcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcclxuXHRcdG1hcmdpbi1ib3R0b206IDE1cHg7XHJcblx0fVxyXG5cclxuXHQuYWN0aW9ubGlzdCA+IGxpIHtcclxuXHRcdGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcclxuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrSkMsT0FBTyxlQUFDLENBQUMsQUFDUixLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLENBQ1QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsSUFBSSxDQUFFLE9BQU8sQUFDZCxDQUFDLEFBRUQsV0FBVyxlQUFDLENBQUMsQUFDWixNQUFNLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDWCxPQUFPLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDZCxVQUFVLENBQUUsS0FBSyxDQUNqQixhQUFhLENBQUUsSUFBSSxBQUNwQixDQUFDLEFBRUQsMEJBQVcsQ0FBRyxFQUFFLGVBQUMsQ0FBQyxBQUNqQixlQUFlLENBQUUsSUFBSSxDQUNyQixPQUFPLENBQUUsWUFBWSxBQUN0QixDQUFDIn0= */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$l(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null && ctx.field.data.actions != null && ctx.field.data.actions.length > 0) && create_if_block$f(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.field.data.actions != null && ctx.field.data.actions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$f(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (3:1) {#each field.data.actions as action}
    function create_each_block$6(component, ctx) {
    	var li;

    	function select_block_type(ctx) {
    		if (ctx.action.action !== "redirect") return create_if_block_1$a;
    		return create_if_block_2$8;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			li = createElement("li");
    			if_block.c();
    			li.className = "svelte-1yns50m";
    			addLoc(li, file$l, 3, 1, 154);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			if_block.m(li, null);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(li, null);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			if_block.d();
    		}
    	};
    }

    // (5:2) {#if action.action !== "redirect"}
    function create_if_block_1$a(component, ctx) {
    	var button, raw_value = ctx.action.label, button_class_value;

    	return {
    		c: function create() {
    			button = createElement("button");
    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$1);
    			button.className = button_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m";
    			addLoc(button, file$l, 5, 2, 200);
    		},

    		m: function mount(target, anchor) {
    			insertNode(button, target, anchor);
    			button.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.action.label)) {
    				button.innerHTML = raw_value;
    			}

    			button._svelte.ctx = ctx;
    			if ((changed.field) && button_class_value !== (button_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m")) {
    				button.className = button_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}

    			removeListener(button, "click", click_handler$1);
    		}
    	};
    }

    // (7:2) {:else }
    function create_if_block_2$8(component, ctx) {
    	var a, text_value = ctx.action.label, text, a_href_value, a_class_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.action.form, ctx.action.inputFieldValues);
    			a.className = a_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m";
    			addLoc(a, file$l, 7, 2, 323);
    		},

    		m: function mount(target, anchor) {
    			insertNode(a, target, anchor);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.action.label)) {
    				text.data = text_value;
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.action.form, ctx.action.inputFieldValues))) {
    				a.href = a_href_value;
    			}

    			if ((changed.field) && a_class_value !== (a_class_value = "btn btn-default " + ctx.action.cssClass + " svelte-1yns50m")) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null && field.data.actions != null && field.data.actions.length > 0}
    function create_if_block$f(component, ctx) {
    	var ul, text, input, input_id_value, text_1, div, div_1, label, text_2, div_2;

    	var each_value = ctx.field.data.actions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(component, get_each_context$6(ctx, each_value, i));
    	}

    	function input_change_handler() {
    		component.set({ open: input.checked });
    	}

    	function click_handler_1(event) {
    		component.close();
    	}

    	return {
    		c: function create() {
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text = createText("\r\n\r\n");
    			input = createElement("input");
    			text_1 = createText("\r\n");
    			div = createElement("div");
    			div_1 = createElement("div");
    			label = createElement("label");
    			text_2 = createText("\r\n\t\t");
    			div_2 = createElement("div");
    			ul.className = "actionlist svelte-1yns50m";
    			addLoc(ul, file$l, 1, 0, 89);
    			addListener(input, "change", input_change_handler);
    			input.id = input_id_value = "modal-" + ctx.modalId;
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden svelte-1yns50m";
    			addLoc(input, file$l, 13, 0, 483);
    			addListener(label, "click", click_handler_1);
    			label.className = "close";
    			addLoc(label, file$l, 16, 2, 610);
    			addLoc(div_2, file$l, 17, 2, 662);
    			div_1.className = "card";
    			addLoc(div_1, file$l, 15, 1, 588);
    			div.className = "modal";
    			addLoc(div, file$l, 14, 0, 566);
    		},

    		m: function mount(target, anchor) {
    			insertNode(ul, target, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insertNode(text, target, anchor);
    			insertNode(input, target, anchor);

    			input.checked = ctx.open;

    			insertNode(text_1, target, anchor);
    			insertNode(div, target, anchor);
    			appendNode(div_1, div);
    			appendNode(label, div_1);
    			appendNode(text_2, div_1);
    			appendNode(div_2, div_1);
    			component.refs.container = div_2;
    		},

    		p: function update(changed, ctx) {
    			if (changed.field || changed.app) {
    				each_value = ctx.field.data.actions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$6(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			input.checked = ctx.open;
    			if ((changed.modalId) && input_id_value !== (input_id_value = "modal-" + ctx.modalId)) {
    				input.id = input_id_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(ul);
    			}

    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(text);
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    			if (detach) {
    				detachNode(text_1);
    				detachNode(div);
    			}

    			removeListener(label, "click", click_handler_1);
    			if (component.refs.container === div_2) component.refs.container = null;
    		}
    	};
    }

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	child_ctx.each_value = list;
    	child_ctx.action_index = i;
    	return child_ctx;
    }

    function click_handler$1(event) {
    	const { component, ctx } = this._svelte;

    	component.run(ctx.action, ctx.app);
    }

    function SvelteComponent$l(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$7(), options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('modalId' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'modalId'");
    	if (!('open' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'open'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1yns50m-style")) add_css$b();

    	this._fragment = create_main_fragment$l(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$l.prototype, protoDev);
    assign(SvelteComponent$l.prototype, methods$7);

    SvelteComponent$l.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Alert.html generated by Svelte v2.9.5 */

    const file$m = "src\\core\\ui\\outputs\\Alert.html";

    function add_css$c() {
    	var style = createElement("style");
    	style.id = 'svelte-w4iry0-style';
    	style.textContent = ".alert.svelte-w4iry0{margin:5px 8px;padding:10px 15px;border:1px solid #bbb}.alert.svelte-w4iry0>.heading.svelte-w4iry0{font-weight:bold;font-size:16px}.alert.success.svelte-w4iry0{background:#ebfff8}.alert.warning.svelte-w4iry0{background:#fdffeb}.alert.danger.svelte-w4iry0{background:#ffeaea}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWxlcnQuaHRtbCIsInNvdXJjZXMiOlsiQWxlcnQuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIGZpZWxkLmRhdGEgIT0gbnVsbH1cclxuPGRpdiBjbGFzcz1cImFsZXJ0IHtmaWVsZC5kYXRhLnN0eWxlfVwiPlxyXG5cdHsjaWYgZmllbGQuZGF0YS5oZWFkaW5nICE9IG51bGx9XHJcblx0PGRpdiBjbGFzcz1cImhlYWRpbmdcIj57ZmllbGQuZGF0YS5oZWFkaW5nfTwvZGl2PlxyXG5cdHsvaWZ9XHJcblxyXG5cdHsjaWYgZmllbGQuZGF0YS5tZXNzYWdlICE9IG51bGx9XHJcblx0PGRpdiBjbGFzcz1cImJvZHlcIj57QGh0bWwgZmllbGQuZGF0YS5tZXNzYWdlfTwvZGl2PlxyXG5cdHsvaWZ9XHJcbjwvZGl2PlxyXG57L2lmfVxyXG5cclxuPHN0eWxlPlxyXG5cdC5hbGVydCB7XHJcblx0XHRtYXJnaW46IDVweCA4cHg7XHJcblx0XHRwYWRkaW5nOiAxMHB4IDE1cHg7XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCAjYmJiO1xyXG5cdH1cclxuXHJcblx0LmFsZXJ0ID4gLmhlYWRpbmcge1xyXG5cdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XHJcblx0XHRmb250LXNpemU6IDE2cHg7XHJcblx0fVxyXG5cclxuXHQuYWxlcnQuc3VjY2VzcyB7XHJcblx0XHRiYWNrZ3JvdW5kOiAjZWJmZmY4O1xyXG5cdH1cclxuXHJcblx0LmFsZXJ0Lndhcm5pbmcge1xyXG5cdFx0YmFja2dyb3VuZDogI2ZkZmZlYjtcclxuXHR9XHJcblxyXG5cdC5hbGVydC5kYW5nZXIge1xyXG5cdFx0YmFja2dyb3VuZDogI2ZmZWFlYTtcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFhQyxNQUFNLGNBQUMsQ0FBQyxBQUNQLE1BQU0sQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUNmLE9BQU8sQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUNsQixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEFBQ3ZCLENBQUMsQUFFRCxvQkFBTSxDQUFHLFFBQVEsY0FBQyxDQUFDLEFBQ2xCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFNBQVMsQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFFRCxNQUFNLFFBQVEsY0FBQyxDQUFDLEFBQ2YsVUFBVSxDQUFFLE9BQU8sQUFDcEIsQ0FBQyxBQUVELE1BQU0sUUFBUSxjQUFDLENBQUMsQUFDZixVQUFVLENBQUUsT0FBTyxBQUNwQixDQUFDLEFBRUQsTUFBTSxPQUFPLGNBQUMsQ0FBQyxBQUNkLFVBQVUsQ0FBRSxPQUFPLEFBQ3BCLENBQUMifQ== */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$m(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$g(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$g(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (3:1) {#if field.data.heading != null}
    function create_if_block_1$b(component, ctx) {
    	var div, text_value = ctx.field.data.heading, text;

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText(text_value);
    			div.className = "heading svelte-w4iry0";
    			addLoc(div, file$m, 3, 1, 102);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(text, div);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.heading)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    // (7:1) {#if field.data.message != null}
    function create_if_block_2$9(component, ctx) {
    	var div, raw_value = ctx.field.data.message;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = "body";
    			addLoc(div, file$m, 7, 1, 197);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			div.innerHTML = raw_value;
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.message)) {
    				div.innerHTML = raw_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$g(component, ctx) {
    	var div, text, div_class_value;

    	var if_block = (ctx.field.data.heading != null) && create_if_block_1$b(component, ctx);

    	var if_block_1 = (ctx.field.data.message != null) && create_if_block_2$9(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n\t");
    			if (if_block_1) if_block_1.c();
    			div.className = div_class_value = "alert " + ctx.field.data.style + " svelte-w4iry0";
    			addLoc(div, file$m, 1, 0, 26);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			if (if_block) if_block.m(div, null);
    			appendNode(text, div);
    			if (if_block_1) if_block_1.m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data.heading != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$b(component, ctx);
    					if_block.c();
    					if_block.m(div, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (ctx.field.data.message != null) {
    				if (if_block_1) {
    					if_block_1.p(changed, ctx);
    				} else {
    					if_block_1 = create_if_block_2$9(component, ctx);
    					if_block_1.c();
    					if_block_1.m(div, null);
    				}
    			} else if (if_block_1) {
    				if_block_1.d(1);
    				if_block_1 = null;
    			}

    			if ((changed.field) && div_class_value !== (div_class_value = "alert " + ctx.field.data.style + " svelte-w4iry0")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    			if (if_block_1) if_block_1.d();
    		}
    	};
    }

    function SvelteComponent$m(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-w4iry0-style")) add_css$c();

    	this._fragment = create_main_fragment$m(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$m.prototype, protoDev);

    SvelteComponent$m.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Datetime.html generated by Svelte v2.9.5 */

    function format$1(field) {
    	if (field.data != null) {
    		const dateTimeStyle = field.metadata.getCustomProperty("dateTimeStyle");
    		let format = "D MMM YYYY";
    		if (dateTimeStyle === "dateTime") {
    			format = "D MMM YYYY HH:mm A";
    		}
    		else if (dateTimeStyle === "time") {
    			format = "HH:mm";
    		}
    		return hooks(field.data).format(format);
    	}
    	return "";
    }
    function create_main_fragment$n(component, ctx) {
    	var text_value = format$1(ctx.field), text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insertNode(text, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = format$1(ctx.field))) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    function SvelteComponent$n(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$n(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$n.prototype, protoDev);

    SvelteComponent$n.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Documentation.html generated by Svelte v2.9.5 */

    function oncreate$f() {
    	const content = this.refs.container;
    	const output = this.refs.toc;

    	let closeLevel = 1;
    	let result = "<ul>";
    	let counter = 0;

    	content.querySelectorAll("h1, h2, h3").forEach(e => {
    		e.setAttribute("id", counter);
    		const openLevel = e.tagName.match(/\d/g)[0];
    		if (openLevel > closeLevel) {
    			result += `${"<ul><li><a data-target='"}${counter}'>${e.innerText}</a>`;
    		}

    		else if (openLevel < closeLevel) {
    			const closingTags = Array(closeLevel - openLevel)
    				.fill()
    				.map(() => "</li></ul>")
    				.join("");

    			result += `${closingTags}</li><li><a data-target='${counter}'>${e.innerText}</a>`;
    		}
    		else {
    			if (closeLevel !== 1) {
    				result += "</li>";
    			}
    			result += `<li><a data-target='${counter}'>${e.innerText}</a>`;
    		}
    		closeLevel = openLevel;
    		counter += 1;
    	});

    	result += Array(closeLevel).fill().map(() => "</li></ul>").join("");

    	output.innerHTML = result;

    	document.querySelectorAll(".table-of-contents a").forEach(a => {
    		a.addEventListener("click", event => {
    			const target = event.currentTarget.getAttribute("data-target");
    			document.getElementById(target).scrollIntoView({ behavior: "smooth" });

    			// clear active
    			document.querySelectorAll(".table-of-contents li.active").forEach(li => {
    				li.classList.remove("active");
    			});

    			// set active
    			let parent = a.parentElement;
    			while (parent) {
    				if (parent.tagName === "LI") {
    					parent.classList.add("active");
    				}
    				parent = parent.parentElement;
    			}

    			event.stopPropagation();
    		});
    	});
    }
    const file$o = "src\\core\\ui\\outputs\\Documentation.html";

    function add_css$d() {
    	var style = createElement("style");
    	style.id = 'svelte-p5uztd-style';
    	style.textContent = ".wrapper.svelte-p5uztd{max-width:1224px;margin:0 auto;display:grid;grid-gap:20px;grid-template-areas:\"content\" \"nav\"}.table-of-contents.svelte-p5uztd{background:white;grid-area:nav;margin-top:35px}.content.svelte-p5uztd{grid-area:content;margin-bottom:100px}@media(min-width: 700px){.wrapper.svelte-p5uztd{grid-template-columns:75% auto;grid-template-areas:\"content nav\"}}@media(max-width: 699px){.wrapper.svelte-p5uztd{grid-template-areas:\"nav\"}.content.svelte-p5uztd{grid-area:unset}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9jdW1lbnRhdGlvbi5odG1sIiwic291cmNlcyI6WyJEb2N1bWVudGF0aW9uLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsiPGRpdiBjbGFzcz1cIndyYXBwZXJcIj5cclxuXHQ8ZGl2IGNsYXNzPVwiY29udGVudFwiIHJlZjpjb250YWluZXI+XHJcblx0XHR7I2lmIGZpZWxkLmRhdGEgIT0gbnVsbCAmJiBmaWVsZC5kYXRhLnZhbHVlICE9IG51bGx9IHtAaHRtbCBmaWVsZC5kYXRhLnZhbHVlfSB7L2lmfVxyXG5cdDwvZGl2PlxyXG5cclxuXHQ8ZGl2IGNsYXNzPSd0YWJsZS1vZi1jb250ZW50cycgcmVmOnRvYz5cclxuXHQ8L2Rpdj5cclxuPC9kaXY+XHJcblxyXG48c2NyaXB0PlxyXG5cdGV4cG9ydCBkZWZhdWx0IHtcclxuXHRcdG9uY3JlYXRlKCkge1xyXG5cdFx0XHRjb25zdCBjb250ZW50ID0gdGhpcy5yZWZzLmNvbnRhaW5lcjtcclxuXHRcdFx0Y29uc3Qgb3V0cHV0ID0gdGhpcy5yZWZzLnRvYztcclxuXHJcblx0XHRcdGxldCBjbG9zZUxldmVsID0gMTtcclxuXHRcdFx0bGV0IHJlc3VsdCA9IFwiPHVsPlwiO1xyXG5cdFx0XHRsZXQgY291bnRlciA9IDA7XHJcblxyXG5cdFx0XHRjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJoMSwgaDIsIGgzXCIpLmZvckVhY2goZSA9PiB7XHJcblx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBjb3VudGVyKTtcclxuXHRcdFx0XHRjb25zdCBvcGVuTGV2ZWwgPSBlLnRhZ05hbWUubWF0Y2goL1xcZC9nKVswXTtcclxuXHRcdFx0XHRpZiAob3BlbkxldmVsID4gY2xvc2VMZXZlbCkge1xyXG5cdFx0XHRcdFx0cmVzdWx0ICs9IGAke1wiPHVsPjxsaT48YSBkYXRhLXRhcmdldD0nXCJ9JHtjb3VudGVyfSc+JHtlLmlubmVyVGV4dH08L2E+YDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVsc2UgaWYgKG9wZW5MZXZlbCA8IGNsb3NlTGV2ZWwpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGNsb3NpbmdUYWdzID0gQXJyYXkoY2xvc2VMZXZlbCAtIG9wZW5MZXZlbClcclxuXHRcdFx0XHRcdFx0LmZpbGwoKVxyXG5cdFx0XHRcdFx0XHQubWFwKCgpID0+IFwiPC9saT48L3VsPlwiKVxyXG5cdFx0XHRcdFx0XHQuam9pbihcIlwiKTtcclxuXHJcblx0XHRcdFx0XHRyZXN1bHQgKz0gYCR7Y2xvc2luZ1RhZ3N9PC9saT48bGk+PGEgZGF0YS10YXJnZXQ9JyR7Y291bnRlcn0nPiR7ZS5pbm5lclRleHR9PC9hPmA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGNsb3NlTGV2ZWwgIT09IDEpIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IFwiPC9saT5cIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJlc3VsdCArPSBgPGxpPjxhIGRhdGEtdGFyZ2V0PScke2NvdW50ZXJ9Jz4ke2UuaW5uZXJUZXh0fTwvYT5gO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbG9zZUxldmVsID0gb3BlbkxldmVsO1xyXG5cdFx0XHRcdGNvdW50ZXIgKz0gMTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXN1bHQgKz0gQXJyYXkoY2xvc2VMZXZlbCkuZmlsbCgpLm1hcCgoKSA9PiBcIjwvbGk+PC91bD5cIikuam9pbihcIlwiKTtcclxuXHJcblx0XHRcdG91dHB1dC5pbm5lckhUTUwgPSByZXN1bHQ7XHJcblxyXG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRhYmxlLW9mLWNvbnRlbnRzIGFcIikuZm9yRWFjaChhID0+IHtcclxuXHRcdFx0XHRhLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBldmVudCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpO1xyXG5cdFx0XHRcdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KS5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiIH0pO1xyXG5cclxuXHRcdFx0XHRcdC8vIGNsZWFyIGFjdGl2ZVxyXG5cdFx0XHRcdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi50YWJsZS1vZi1jb250ZW50cyBsaS5hY3RpdmVcIikuZm9yRWFjaChsaSA9PiB7XHJcblx0XHRcdFx0XHRcdGxpLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgYWN0aXZlXHJcblx0XHRcdFx0XHRsZXQgcGFyZW50ID0gYS5wYXJlbnRFbGVtZW50O1xyXG5cdFx0XHRcdFx0d2hpbGUgKHBhcmVudCkge1xyXG5cdFx0XHRcdFx0XHRpZiAocGFyZW50LnRhZ05hbWUgPT09IFwiTElcIikge1xyXG5cdFx0XHRcdFx0XHRcdHBhcmVudC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQud3JhcHBlciB7XHJcblx0XHRtYXgtd2lkdGg6IDEyMjRweDtcclxuXHRcdG1hcmdpbjogMCBhdXRvO1xyXG5cdFx0ZGlzcGxheTogZ3JpZDtcclxuXHRcdGdyaWQtZ2FwOiAyMHB4O1xyXG5cdFx0Z3JpZC10ZW1wbGF0ZS1hcmVhczogXCJjb250ZW50XCIgXCJuYXZcIjtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyB7XHJcblx0XHRiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuXHRcdGdyaWQtYXJlYTogbmF2O1xyXG5cdFx0bWFyZ2luLXRvcDogMzVweDtcclxuXHR9XHJcblxyXG5cdC5jb250ZW50IHtcclxuXHRcdGdyaWQtYXJlYTogY29udGVudDtcclxuXHRcdG1hcmdpbi1ib3R0b206IDEwMHB4O1xyXG5cdH1cclxuXHJcblx0QG1lZGlhIChtaW4td2lkdGg6IDcwMHB4KSB7XHJcblx0XHQud3JhcHBlciB7XHJcblx0XHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogNzUlIGF1dG87XHJcblx0XHRcdGdyaWQtdGVtcGxhdGUtYXJlYXM6IFwiY29udGVudCBuYXZcIjtcclxuXHRcdH1cclxuXHJcblx0XHQudGFibGUtb2YtY29udGVudHMgPiB1bCB7XHJcblx0XHRcdHBvc2l0aW9uOiBmaXhlZDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBtZWRpYSAobWF4LXdpZHRoOiA2OTlweCkge1xyXG5cdFx0LndyYXBwZXIge1xyXG5cdFx0XHRncmlkLXRlbXBsYXRlLWFyZWFzOiBcIm5hdlwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdC5jb250ZW50IHtcclxuXHRcdFx0Z3JpZC1hcmVhOiB1bnNldDtcclxuXHRcdH1cclxuXHJcblx0XHQuY29udGVudCBpbWcge1xyXG5cdFx0XHR3aWR0aDogMTAwJTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC5jb250ZW50IGgxIGVtIHtcclxuXHRcdGZvbnQtc2l6ZTogdW5zZXQ7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCBoMSB7XHJcblx0XHRib3JkZXItYm90dG9tOiAzcHggc29saWQgI2VjZWNlYztcclxuXHRcdG1hcmdpbjogMzBweCAwIDIwcHg7XHJcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XHJcblx0XHRwYWRkaW5nOiAwIDAgNXB4IDA7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCBoMiB7XHJcblx0XHRtYXJnaW4tdG9wOiAyNXB4O1xyXG5cdFx0cGFkZGluZzogMTBweCAwO1xyXG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNiNGI0YjQ7XHJcblx0XHRtYXJnaW4tYm90dG9tOiAyNXB4O1xyXG5cdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCBoMyB7XHJcblx0XHRtYXJnaW4tdG9wOiAyNXB4O1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgaDQge1xyXG5cdFx0Zm9udC1zaXplOiAxLjVyZW07XHJcblx0XHRvcGFjaXR5OiAwLjg7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCA+IHVsIHtcclxuXHRcdG1hcmdpbi1sZWZ0OiAyNXB4O1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgaW1nIHtcclxuXHRcdG1hcmdpbi1ib3R0b206IDM1cHg7XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCAjZWNlY2VjO1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcblx0XHRib3gtc2hhZG93OiA1cHggNXB4IDEwcHggI2FhYTtcclxuXHRcdG1heC13aWR0aDogMTAwJTtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyB1bCB7XHJcblx0XHRsaXN0LXN0eWxlOiBub25lO1xyXG5cdH1cclxuXHJcblx0bGkuYWN0aXZlID4gYSB7XHJcblx0XHRmb250LXdlaWdodDogNTAwO1xyXG5cdH1cclxuXHJcblx0LnRhYmxlLW9mLWNvbnRlbnRzIGE6aG92ZXIge1xyXG5cdFx0Zm9udC13ZWlnaHQ6IDYwMDtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyBsaSB7XHJcblx0XHRjdXJzb3I6IHBvaW50ZXI7XHJcblx0fVxyXG5cclxuXHQudGFibGUtb2YtY29udGVudHMgdWwgbGkge1xyXG5cdFx0ZGlzcGxheTogbm9uZTtcclxuXHR9XHJcblxyXG5cdC50YWJsZS1vZi1jb250ZW50cyA+IHVsID4gbGksXHJcblx0LnRhYmxlLW9mLWNvbnRlbnRzID4gdWwgPiBsaSA+IHVsID4gbGkge1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0fVxyXG5cclxuXHQudGFibGUtb2YtY29udGVudHMgbGkuYWN0aXZlID4gdWwgPiBsaSB7XHJcblx0XHRkaXNwbGF5OiBibG9jaztcclxuXHR9XHJcbjwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEyRUMsUUFBUSxjQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsTUFBTSxDQUNqQixNQUFNLENBQUUsQ0FBQyxDQUFDLElBQUksQ0FDZCxPQUFPLENBQUUsSUFBSSxDQUNiLFFBQVEsQ0FBRSxJQUFJLENBQ2QsbUJBQW1CLENBQUUsU0FBUyxDQUFDLEtBQUssQUFDckMsQ0FBQyxBQUVELGtCQUFrQixjQUFDLENBQUMsQUFDbkIsVUFBVSxDQUFFLEtBQUssQ0FDakIsU0FBUyxDQUFFLEdBQUcsQ0FDZCxVQUFVLENBQUUsSUFBSSxBQUNqQixDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsT0FBTyxDQUNsQixhQUFhLENBQUUsS0FBSyxBQUNyQixDQUFDLEFBRUQsTUFBTSxBQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQyxBQUMxQixRQUFRLGNBQUMsQ0FBQyxBQUNULHFCQUFxQixDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQy9CLG1CQUFtQixDQUFFLGFBQWEsQUFDbkMsQ0FBQyxBQUtGLENBQUMsQUFFRCxNQUFNLEFBQUMsWUFBWSxLQUFLLENBQUMsQUFBQyxDQUFDLEFBQzFCLFFBQVEsY0FBQyxDQUFDLEFBQ1QsbUJBQW1CLENBQUUsS0FBSyxBQUMzQixDQUFDLEFBRUQsUUFBUSxjQUFDLENBQUMsQUFDVCxTQUFTLENBQUUsS0FBSyxBQUNqQixDQUFDLEFBS0YsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$o(component, ctx) {
    	var div, div_1, text_1, div_2;

    	var if_block = (ctx.field.data != null && ctx.field.data.value != null) && create_if_block$h(component, ctx);

    	return {
    		c: function create() {
    			div = createElement("div");
    			div_1 = createElement("div");
    			if (if_block) if_block.c();
    			text_1 = createText("\r\n\r\n\t");
    			div_2 = createElement("div");
    			div_1.className = "content svelte-p5uztd";
    			addLoc(div_1, file$o, 1, 1, 24);
    			div_2.className = "table-of-contents svelte-p5uztd";
    			addLoc(div_2, file$o, 5, 1, 160);
    			div.className = "wrapper svelte-p5uztd";
    			addLoc(div, file$o, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(div_1, div);
    			if (if_block) if_block.m(div_1, null);
    			component.refs.container = div_1;
    			appendNode(text_1, div);
    			appendNode(div_2, div);
    			component.refs.toc = div_2;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.field.data.value != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$h(component, ctx);
    					if_block.c();
    					if_block.m(div_1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (if_block) if_block.d();
    			if (component.refs.container === div_1) component.refs.container = null;
    			if (component.refs.toc === div_2) component.refs.toc = null;
    		}
    	};
    }

    // (3:2) {#if field.data != null && field.data.value != null}
    function create_if_block$h(component, ctx) {
    	var raw_value = ctx.field.data.value, raw_before, raw_after;

    	return {
    		c: function create() {
    			raw_before = createElement('noscript');
    			raw_after = createElement('noscript');
    		},

    		m: function mount(target, anchor) {
    			insertNode(raw_before, target, anchor);
    			raw_before.insertAdjacentHTML("afterend", raw_value);
    			insertNode(raw_after, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.value)) {
    				detachBetween(raw_before, raw_after);
    				raw_before.insertAdjacentHTML("afterend", raw_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachBetween(raw_before, raw_after);
    				detachNode(raw_before);
    				detachNode(raw_after);
    			}
    		}
    	};
    }

    function SvelteComponent$o(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-p5uztd-style")) add_css$d();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$o(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$f.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$o.prototype, protoDev);

    SvelteComponent$o.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\DownloadableFile.html generated by Svelte v2.9.5 */

    const file$p = "src\\core\\ui\\outputs\\DownloadableFile.html";

    function create_main_fragment$p(component, ctx) {
    	var a, text_value = ctx.field.data.name, text, a_href_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = "/file/download?id=" + ctx.field.data.id;
    			addLoc(a, file$p, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(a, target, anchor);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.name)) {
    				text.data = text_value;
    			}

    			if ((changed.field) && a_href_value !== (a_href_value = "/file/download?id=" + ctx.field.data.id)) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    function SvelteComponent$p(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$p(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$p.prototype, protoDev);

    SvelteComponent$p.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\FileSize.html generated by Svelte v2.9.5 */

    function filesize(bytes) {
    	const thresh = 1000;
    	if (Math.abs(bytes) < thresh) {
    		return `${bytes} B`;
    	}

    	const units = ["kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

    	let u = -1;
    	let result = bytes;

    	do {
    		result /= thresh;
    		u += 1;
    	} while (Math.abs(result) >= thresh && u < units.length - 1);

    	return `${result.toFixed(1)} ${units[u]}`;
    }
    function create_main_fragment$q(component, ctx) {
    	var text_value = filesize(ctx.field.data.bytes), text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insertNode(text, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = filesize(ctx.field.data.bytes))) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    function SvelteComponent$q(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$q(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$q.prototype, protoDev);

    SvelteComponent$q.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\FormLink.html generated by Svelte v2.9.5 */

    const file$r = "src\\core\\ui\\outputs\\FormLink.html";

    function create_main_fragment$r(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$i(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$i(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (2:1) {#if field.data.form != null}
    function create_if_block_1$c(component, ctx) {
    	var a, text_value = ctx.field.data.label, text, a_href_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues);
    			addLoc(a, file$r, 2, 2, 60);
    		},

    		m: function mount(target, anchor) {
    			insertNode(a, target, anchor);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.label)) {
    				text.data = text_value;
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.field.data.form, ctx.field.data.inputFieldValues))) {
    				a.href = a_href_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    // (4:1) {:else}
    function create_if_block_2$a(component, ctx) {
    	var span, text_value = ctx.field.data.label, text;

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(text_value);
    			addLoc(span, file$r, 4, 2, 166);
    		},

    		m: function mount(target, anchor) {
    			insertNode(span, target, anchor);
    			appendNode(text, span);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$i(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.field.data.form != null) return create_if_block_1$c;
    		return create_if_block_2$a;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    function SvelteComponent$r(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	this._fragment = create_main_fragment$r(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$r.prototype, protoDev);

    SvelteComponent$r.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\HtmlString.html generated by Svelte v2.9.5 */

    function create_main_fragment$s(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null && ctx.field.data.value != null) && create_if_block$j(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.field.data.value != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$j(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null && field.data.value != null}
    function create_if_block$j(component, ctx) {
    	var raw_value = ctx.field.data.value, raw_before, raw_after;

    	return {
    		c: function create() {
    			raw_before = createElement('noscript');
    			raw_after = createElement('noscript');
    		},

    		m: function mount(target, anchor) {
    			insertNode(raw_before, target, anchor);
    			raw_before.insertAdjacentHTML("afterend", raw_value);
    			insertNode(raw_after, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && raw_value !== (raw_value = ctx.field.data.value)) {
    				detachBetween(raw_before, raw_after);
    				raw_before.insertAdjacentHTML("afterend", raw_value);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachBetween(raw_before, raw_after);
    				detachNode(raw_before);
    				detachNode(raw_after);
    			}
    		}
    	};
    }

    function SvelteComponent$s(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$s(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$s.prototype, protoDev);

    SvelteComponent$s.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Image.html generated by Svelte v2.9.5 */

    const file$t = "src\\core\\ui\\outputs\\Image.html";

    function create_main_fragment$t(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$k(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$k(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$k(component, ctx) {
    	var img, img_src_value;

    	return {
    		c: function create() {
    			img = createElement("img");
    			img.src = img_src_value = ctx.field.data.url;
    			img.alt = "";
    			addLoc(img, file$t, 1, 0, 26);
    		},

    		m: function mount(target, anchor) {
    			insertNode(img, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && img_src_value !== (img_src_value = ctx.field.data.url)) {
    				img.src = img_src_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(img);
    			}
    		}
    	};
    }

    function SvelteComponent$t(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$t(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$t.prototype, protoDev);

    SvelteComponent$t.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\InlineForm.html generated by Svelte v2.9.5 */

    function oncreate$g() {
    	const app = this.get().app;
    	const field = this.get().field;
    	const parentFormComponent = this.get().parent;

    	const formInstance = app.getFormInstance(field.data.form, true);

    	formInstance.initializeInputFields(field.data.inputFieldValues).then(() => {
    		const f = new SvelteComponent$8({
    			target: this.refs.container,
    			data: {
    				metadata: formInstance.metadata,
    				form: formInstance,
    				app,
    				useUrl: false,
    				parent: parentFormComponent
    			}
    		});

    		f.init();

    		this.set({ current: f });
    	});

    	this.get().parent.on("destroy", () => this.destroy());
    }
    function ondestroy$1() {
    	const form = this.get().current;

    	if (form != null) {
    		form.destroy();
    	}
    }
    const file$u = "src\\core\\ui\\outputs\\InlineForm.html";

    function add_css$e() {
    	var style = createElement("style");
    	style.id = 'svelte-1xn0nn7-style';
    	style.textContent = ".inline-form.svelte-1xn0nn7{border-width:1px 1px 1px;border-style:solid;border-color:#bbd2d6;margin:30px 0;border-radius:5px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5saW5lRm9ybS5odG1sIiwic291cmNlcyI6WyJJbmxpbmVGb3JtLmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsiPGRpdiByZWY6Y29udGFpbmVyIGNsYXNzPVwiaW5saW5lLWZvcm1cIj48L2Rpdj5cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IEZvcm1Db21wb25lbnQgZnJvbSBcImNvcmUtdWkvRm9ybVwiO1xyXG5cclxuXHRleHBvcnQgZGVmYXVsdCB7XHJcblx0XHRvbmNyZWF0ZSgpIHtcclxuXHRcdFx0Y29uc3QgYXBwID0gdGhpcy5nZXQoKS5hcHA7XHJcblx0XHRcdGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHRcdFx0Y29uc3QgcGFyZW50Rm9ybUNvbXBvbmVudCA9IHRoaXMuZ2V0KCkucGFyZW50O1xyXG5cclxuXHRcdFx0Y29uc3QgZm9ybUluc3RhbmNlID0gYXBwLmdldEZvcm1JbnN0YW5jZShmaWVsZC5kYXRhLmZvcm0sIHRydWUpO1xyXG5cclxuXHRcdFx0Zm9ybUluc3RhbmNlLmluaXRpYWxpemVJbnB1dEZpZWxkcyhmaWVsZC5kYXRhLmlucHV0RmllbGRWYWx1ZXMpLnRoZW4oKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGYgPSBuZXcgRm9ybUNvbXBvbmVudCh7XHJcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMucmVmcy5jb250YWluZXIsXHJcblx0XHRcdFx0XHRkYXRhOiB7XHJcblx0XHRcdFx0XHRcdG1ldGFkYXRhOiBmb3JtSW5zdGFuY2UubWV0YWRhdGEsXHJcblx0XHRcdFx0XHRcdGZvcm06IGZvcm1JbnN0YW5jZSxcclxuXHRcdFx0XHRcdFx0YXBwLFxyXG5cdFx0XHRcdFx0XHR1c2VVcmw6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHRwYXJlbnQ6IHBhcmVudEZvcm1Db21wb25lbnRcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Zi5pbml0KCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0KHsgY3VycmVudDogZiB9KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLmdldCgpLnBhcmVudC5vbihcImRlc3Ryb3lcIiwgKCkgPT4gdGhpcy5kZXN0cm95KCkpO1xyXG5cdFx0fSxcclxuXHRcdG9uZGVzdHJveSgpIHtcclxuXHRcdFx0Y29uc3QgZm9ybSA9IHRoaXMuZ2V0KCkuY3VycmVudDtcclxuXHJcblx0XHRcdGlmIChmb3JtICE9IG51bGwpIHtcclxuXHRcdFx0XHRmb3JtLmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5pbmxpbmUtZm9ybSB7XHJcblx0XHRib3JkZXItd2lkdGg6IDFweCAxcHggMXB4O1xyXG5cdFx0Ym9yZGVyLXN0eWxlOiBzb2xpZDtcclxuXHRcdGJvcmRlci1jb2xvcjogI2JiZDJkNjtcclxuXHRcdG1hcmdpbjogMzBweCAwO1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogNXB4O1xyXG5cdH1cclxuXHJcblx0LmlubGluZS1mb3JtIC5mb3JtLWhlYWRlciB7XHJcblx0XHRib3JkZXItYm90dG9tOiBub25lO1xyXG5cdFx0cGFkZGluZy10b3A6IDA7XHJcblx0XHRwYWRkaW5nLWJvdHRvbTogMDtcclxuXHRcdGJhY2tncm91bmQ6ICNlZWU7XHJcblx0fVxyXG5cclxuXHQuaW5saW5lLWZvcm0gLnJlc3BvbnNlIHtcclxuXHRcdG1hcmdpbi10b3A6IDA7XHJcblx0XHRwYWRkaW5nOiAxMHB4IDE1cHg7XHJcblx0fVxyXG5cclxuXHQuaW5saW5lLWZvcm0gaDIge1xyXG5cdFx0bWFyZ2luOiAwO1xyXG5cdFx0Zm9udC1zaXplOiAxNXB4O1xyXG5cdFx0cGFkZGluZzogMTBweCAxNXB4IDE1cHg7XHJcblx0fVxyXG5cclxuXHQuaW5saW5lLWZvcm0gLnJlc3BvbnNlIC5mb3JtLWhlYWRlciB7XHJcblx0XHRwYWRkaW5nLXRvcDogMTBweDtcclxuXHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjYmJkMmQ2O1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxuXHR9XHJcblxyXG5cdC5pbmxpbmUtZm9ybSAucmVzcG9uc2UgaDIge1xyXG5cdFx0Zm9udC1zaXplOiAycmVtO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTJDQyxZQUFZLGVBQUMsQ0FBQyxBQUNiLFlBQVksQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FDekIsWUFBWSxDQUFFLEtBQUssQ0FDbkIsWUFBWSxDQUFFLE9BQU8sQ0FDckIsTUFBTSxDQUFFLElBQUksQ0FBQyxDQUFDLENBQ2QsYUFBYSxDQUFFLEdBQUcsQUFDbkIsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$u(component, ctx) {
    	var div;

    	return {
    		c: function create() {
    			div = createElement("div");
    			div.className = "inline-form svelte-1xn0nn7";
    			addLoc(div, file$u, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			component.refs.container = div;
    		},

    		p: noop,

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			if (component.refs.container === div) component.refs.container = null;
    		}
    	};
    }

    function SvelteComponent$u(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	this._intro = true;

    	this._handlers.destroy = [ondestroy$1];

    	if (!document.getElementById("svelte-1xn0nn7-style")) add_css$e();

    	if (!options.root) {
    		this._oncreate = [];
    	}

    	this._fragment = create_main_fragment$u(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$g.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$u.prototype, protoDev);

    SvelteComponent$u.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Link.html generated by Svelte v2.9.5 */

    const file$v = "src\\core\\ui\\outputs\\Link.html";

    function create_main_fragment$v(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$l(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$l(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$l(component, ctx) {
    	var a, text_value = ctx.field.data.anchor, text, a_href_value, a_class_value;

    	return {
    		c: function create() {
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.field.data.url;
    			a.className = a_class_value = ctx.field.data.cssClass;
    			addLoc(a, file$v, 1, 0, 26);
    		},

    		m: function mount(target, anchor) {
    			insertNode(a, target, anchor);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.anchor)) {
    				text.data = text_value;
    			}

    			if ((changed.field) && a_href_value !== (a_href_value = ctx.field.data.url)) {
    				a.href = a_href_value;
    			}

    			if ((changed.field) && a_class_value !== (a_class_value = ctx.field.data.cssClass)) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(a);
    			}
    		}
    	};
    }

    function SvelteComponent$v(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$v(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$v.prototype, protoDev);

    SvelteComponent$v.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Number.html generated by Svelte v2.9.5 */

    function formatted({ field }) {
    	if (field.data == null) {
    		return "";
    	}

    	const x = field.data;
    	const parts = x.toString().split(".");
    	parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");

    	return parts.join(".");
    }

    function create_main_fragment$w(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$m(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$m(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null}
    function create_if_block$m(component, ctx) {
    	var text;

    	return {
    		c: function create() {
    			text = createText(ctx.formatted);
    		},

    		m: function mount(target, anchor) {
    			insertNode(text, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.formatted) {
    				text.data = ctx.formatted;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    function SvelteComponent$w(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	this._recompute({ field: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$w(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$w.prototype, protoDev);

    SvelteComponent$w.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('formatted' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'formatted'");
    };

    SvelteComponent$w.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field) {
    		if (this._differs(state.formatted, (state.formatted = formatted(state)))) changed.formatted = true;
    	}
    };

    /* src\core\ui\outputs\ObjectList.html generated by Svelte v2.9.5 */

    function oncreate$h() {
    	const field = this.get().field;
    	if (field.data == null || field.data.metadata == null) {
    		return;
    	}

    	const columns = field.data.metadata;
    	delete columns.customProperties;

    	const formMetadata = new FormMetadata({
    		customProperties: field.data.metadata.customProperties,
    		outputFields: columns
    	});

    	const items = [];
    	for (const item of field.data.items) {
    		items.push(FormInstance.getOutputFieldValues(formMetadata.outputFields, item));
    	}

    	this.set({
    		items,
    		cssClass: formMetadata.getCustomProperty("cssClass") || ""
    	});
    }
    const file$x = "src\\core\\ui\\outputs\\ObjectList.html";

    function add_css$f() {
    	var style = createElement("style");
    	style.id = 'svelte-1hhmh3x-style';
    	style.textContent = ".object-list-item.svelte-1hhmh3x{margin:10px 0;border-bottom:1px solid #eee;padding:10px 0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2JqZWN0TGlzdC5odG1sIiwic291cmNlcyI6WyJPYmplY3RMaXN0Lmh0bWwiXSwic291cmNlc0NvbnRlbnQiOlsieyNpZiBmaWVsZC5kYXRhICE9IG51bGwgJiYgaXRlbXMgIT0gbnVsbH1cclxueyNlYWNoIGl0ZW1zIGFzIGl0ZW1GaWVsZHN9XHJcblx0PGRpdiBjbGFzcz1cIm9iamVjdC1saXN0LWl0ZW0ge2Nzc0NsYXNzfVwiPlxyXG5cdFx0eyNlYWNoIGl0ZW1GaWVsZHMgYXMgaXRlbUZpZWxkfVxyXG5cdFx0eyNpZiBpdGVtRmllbGQubWV0YWRhdGEuaGlkZGVuID09IGZhbHNlICYmICEoaXRlbUZpZWxkLm1ldGFkYXRhLmdldEN1c3RvbVByb3BlcnR5KFwiaGlkZUlmTnVsbFwiKSA9PT0gdHJ1ZSAmJiBpdGVtRmllbGQuZGF0YSA9PT0gbnVsbCl9XHJcblx0XHQgXHQ8Rm9ybU91dHB1dCBmaWVsZD1cIntpdGVtRmllbGR9XCIgYXBwPVwie2FwcH1cIiBmb3JtPVwie2Zvcm19XCIgcGFyZW50PVwie3BhcmVudH1cIiAvPlxyXG5cdFx0ey9pZn1cclxuXHRcdHsvZWFjaH1cclxuXHQ8L2Rpdj5cclxuey9lYWNofVxyXG57L2lmfVxyXG5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgKiBhcyB1bWYgZnJvbSBcImNvcmUtZnJhbWV3b3JrXCI7XHJcblx0aW1wb3J0ICogYXMgdWltZmNvcmUgZnJvbSBcInVpbWYtY29yZVwiO1xyXG5cdGltcG9ydCBGb3JtT3V0cHV0IGZyb20gXCIuLi9PdXRwdXRcIjtcclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHRcdFx0aWYgKGZpZWxkLmRhdGEgPT0gbnVsbCB8fCBmaWVsZC5kYXRhLm1ldGFkYXRhID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGNvbHVtbnMgPSBmaWVsZC5kYXRhLm1ldGFkYXRhO1xyXG5cdFx0XHRkZWxldGUgY29sdW1ucy5jdXN0b21Qcm9wZXJ0aWVzO1xyXG5cclxuXHRcdFx0Y29uc3QgZm9ybU1ldGFkYXRhID0gbmV3IHVpbWZjb3JlLkZvcm1NZXRhZGF0YSh7XHJcblx0XHRcdFx0Y3VzdG9tUHJvcGVydGllczogZmllbGQuZGF0YS5tZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzLFxyXG5cdFx0XHRcdG91dHB1dEZpZWxkczogY29sdW1uc1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbnN0IGl0ZW1zID0gW107XHJcblx0XHRcdGZvciAoY29uc3QgaXRlbSBvZiBmaWVsZC5kYXRhLml0ZW1zKSB7XHJcblx0XHRcdFx0aXRlbXMucHVzaCh1bWYuRm9ybUluc3RhbmNlLmdldE91dHB1dEZpZWxkVmFsdWVzKGZvcm1NZXRhZGF0YS5vdXRwdXRGaWVsZHMsIGl0ZW0pKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdGl0ZW1zLFxyXG5cdFx0XHRcdGNzc0NsYXNzOiBmb3JtTWV0YWRhdGEuZ2V0Q3VzdG9tUHJvcGVydHkoXCJjc3NDbGFzc1wiKSB8fCBcIlwiXHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdGNvbXBvbmVudHM6IHtcclxuXHRcdFx0Rm9ybU91dHB1dFxyXG5cdFx0fVxyXG5cdH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5vYmplY3QtbGlzdC1pdGVtIHtcclxuXHRcdG1hcmdpbjogMTBweCAwO1xyXG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XHJcblx0XHRwYWRkaW5nOiAxMHB4IDA7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaURDLGlCQUFpQixlQUFDLENBQUMsQUFDbEIsTUFBTSxDQUFFLElBQUksQ0FBQyxDQUFDLENBQ2QsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUM3QixPQUFPLENBQUUsSUFBSSxDQUFDLENBQUMsQUFDaEIsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$x(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null && ctx.items != null) && create_if_block$n(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.items != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$n(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (2:0) {#each items as itemFields}
    function create_each_block$7(component, ctx) {
    	var div, div_class_value;

    	var each_value_1 = ctx.itemFields;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(component, get_each_context_1$2(ctx, each_value_1, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			div.className = div_class_value = "object-list-item " + ctx.cssClass + " svelte-1hhmh3x";
    			addLoc(div, file$x, 2, 1, 73);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.items || changed.app || changed.form || changed.parent) {
    				each_value_1 = ctx.itemFields;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if ((changed.cssClass) && div_class_value !== (div_class_value = "object-list-item " + ctx.cssClass + " svelte-1hhmh3x")) {
    				div.className = div_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (4:2) {#each itemFields as itemField}
    function create_each_block_1$2(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.itemField.metadata.hidden == false && !(ctx.itemField.metadata.getCustomProperty("hideIfNull") === true && ctx.itemField.data === null)) && create_if_block_1$d(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.itemField.metadata.hidden == false && !(ctx.itemField.metadata.getCustomProperty("hideIfNull") === true && ctx.itemField.data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$d(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (5:2) {#if itemField.metadata.hidden == false && !(itemField.metadata.getCustomProperty("hideIfNull") === true && itemField.data === null)}
    function create_if_block_1$d(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.itemField,
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.parent
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.items) formoutput_changes.field = ctx.itemField;
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.parent) formoutput_changes.parent = ctx.parent;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (1:0) {#if field.data != null && items != null}
    function create_if_block$n(component, ctx) {
    	var each_anchor;

    	var each_value = ctx.items;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(component, get_each_context$7(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insertNode(each_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.cssClass || changed.items || changed.app || changed.form || changed.parent) {
    				each_value = ctx.items;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$7(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.itemFields = list[i];
    	child_ctx.each_value = list;
    	child_ctx.itemFields_index = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.itemField = list[i];
    	child_ctx.each_value_1 = list;
    	child_ctx.itemField_index = i;
    	return child_ctx;
    }

    function SvelteComponent$x(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('items' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'items'");
    	if (!('cssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'cssClass'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1hhmh3x-style")) add_css$f();

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$x(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$h.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$x.prototype, protoDev);

    SvelteComponent$x.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Table.html generated by Svelte v2.9.5 */

    function buildFilter$2(currentFormInstance, parameters) {
    	let promise;

    	const filter = {};
    	if (parameters != null && parameters.length > 0) {
    		promise = currentFormInstance.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}

    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}

    	return promise;
    }

    const modals$1 = [];

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    document.addEventListener("keydown", e => {
    	const evt = e || window.event;
    	let isEscape = false;
    	if ("key" in evt) {
    		isEscape = (evt.key === "Escape" || evt.key === "Esc");
    	}
    	else {
    		isEscape = (evt.keyCode === 27);
    	}
    	if (isEscape) {
    		if (modals$1.length > 0) {
    			// Close topmost modal.
    			modals$1[modals$1.length - 1].closeBulkActionModal();
    		}
    	}
    });

    function columnsOrdered({ field }) {
    	return field.metadata.customProperties.columns
    	.filter(b => !b.hidden)
    	.sort((a, b) => a.orderIndex - b.orderIndex);
    }

    var methods$8 = {
    	async runBulkAction(action) {
    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		const map = this.get().map;
    		const selectedItemIds = selectedItems.map(t => t[map[action.itemIdentifierField.toLowerCase()]]);

    		this.set({
    			isBulkActionModalOpen: true
    		});

    		const app = this.get().app;
    		const formInstance = app.getFormInstance(action.formId, true);

    		const filter = await buildFilter$2(this.get().form, action.parameters);
    		filter.Items = { items: selectedItemIds };
    		formInstance.setInputFields(filter);

    		const f = new SvelteComponent$8({
    			target: this.refs.bulkActionContainer,
    			data: {
    				metadata: formInstance.metadata,
    				form: formInstance,
    				app,
    				useUrl: false
    			}
    		});

    		f.init();

    		const self = this;
    		f.on("form:responseHandled", e => {
    			self.closeBulkActionModal(e.response);
    		});

    		this.set({
    			currentBulkActionForm: f
    		});

    		modals$1.push(this);
    	},
    	async closeBulkActionModal(response) {
    		const currentBulkActionForm = this.get().currentBulkActionForm;

    		this.set({
    			isBulkActionModalOpen: false,
    			currentBulkActionForm: null
    		});

    		currentBulkActionForm.destroy();

    		const parentFormComponent = this.get().parent;

    		if (response != null &&
    			response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload") {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentFormComponent.submit(null, true);
    		}

    		modals$1.pop();
    	},
    	selectItem(checkboxElement, row) {
    		// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    		row.__selected = checkboxElement.checked;

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	selectAllItems(checkboxElement) {
    		for (const row of this.get().field.data) {
    			// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    			row.__selected = checkboxElement.checked;
    		}

    		const checkboxes = this.refs.table.querySelectorAll("tbody>tr>td .checkbox");

    		for (const checkbox of checkboxes) {
    			checkbox.checked = checkboxElement.checked;
    		}

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	sortData(column, columns) {
    		const parent = this.get().parent;
    		const form = parent.get().form;
    		const field = this.get().field;
    		const paginatorInput = form.inputs
    			.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    		if (paginatorInput != null) {
    			paginatorInput.value.orderBy = column.customProperties.sortableBy;
    			for (const i of columns) {
    				i.ascending = false;
    			}

    			paginatorInput.value.ascending = !paginatorInput.value.ascending;
    			// eslint-disable-next-line no-param-reassign
    			column.ascending = paginatorInput.value.ascending;

    			const params = {};
    			for (const i of form.inputs) {
    				params[i.metadata.id] = i.value;
    			}
    			form.setInputFields(params);
    			parent.submit(null, false);
    		}
    	}
    };

    function oncreate$i() {
    	const { data } = this.get().field;

    	if (data == null) {
    		return;
    	}

    	const { metadata } = this.get().field;
    	const { rowCssClass } = (metadata.customProperties || {});

    	// Create map, with key being the lowercase version of the property name
    	// and value being the actual property name.
    	const map = {};
    	if (data.length > 0) {
    		const firstRow = data[0];

    		for (const property of Object.keys(firstRow)) {
    			map[property.toLowerCase()] = property;
    		}
    	}

    	this.set({
    		// Show table only after the `oncreate` method has run.
    		visible: true,
    		bulkActions: (metadata.customProperties || {}).bulkAction || [],
    		map,
    		getField(row, column) {
    			const value = row[map[column.id.toLowerCase()]];

    			return {
    				value,
    				metadata: column
    			};
    		},
    		getRowCssClass(row) {
    			let cssClass = "";

    			if (rowCssClass != null) {
    				cssClass = rowCssClass.cssClass || "";

    				if (rowCssClass.suffix != null) {
    					cssClass += row[map[rowCssClass.suffix.toLowerCase()]];
    				}
    			}

    			return cssClass;
    		},
    		selectedItemsCount: 0
    	});
    }
    const file$y = "src\\core\\ui\\outputs\\Table.html";

    function add_css$g() {
    	var style = createElement("style");
    	style.id = 'svelte-z80lq2-style';
    	style.textContent = ".btn-row.svelte-z80lq2{text-align:right}.checkbox.svelte-z80lq2{clip:unset;clip-path:unset;position:unset;width:15px;height:15px}.sortable-column.svelte-z80lq2{cursor:pointer}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuaHRtbCIsInNvdXJjZXMiOlsiVGFibGUuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHZpc2libGUgJiYgZmllbGQuZGF0YSAhPSBudWxsICYmIGZpZWxkLmRhdGEubGVuZ3RoID4gMH1cclxuXHQ8dGFibGUgY2xhc3M9XCJ0YWJsZVwiIHJlZjp0YWJsZT5cclxuXHRcdDx0aGVhZD5cclxuXHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwIH1cclxuXHRcdFx0PHRyPlxyXG5cdFx0XHRcdDx0ZCBjb2xzcGFuPVwie2NvbHVtbnNPcmRlcmVkLmxlbmd0aCArIDF9XCIgY2xhc3M9XCJidG4tcm93XCI+XHJcblx0XHRcdFx0XHR7I2VhY2ggYnVsa0FjdGlvbnMgYXMgYWN0aW9ufVxyXG5cdFx0XHRcdFx0XHR7I2lmIHNlbGVjdGVkSXRlbXNDb3VudCA+IDAgfVxyXG5cdFx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBvbjpjbGljaz1cInJ1bkJ1bGtBY3Rpb24oYWN0aW9uKVwiPnthY3Rpb24ubGFiZWx9IDxzbWFsbD4oe3NlbGVjdGVkSXRlbXNDb3VudH0pPC9zbWFsbD48L2J1dHRvbj5cclxuXHRcdFx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBkaXNhYmxlZD57YWN0aW9uLmxhYmVsfTwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdFx0ey9lYWNofVxyXG5cdFx0XHRcdDwvdGQ+XHJcblx0XHRcdDwvdHI+XHJcblx0XHRcdHsvaWZ9XHJcblx0XHRcdDx0cj5cclxuXHRcdFx0XHR7I2lmIGJ1bGtBY3Rpb25zLmxlbmd0aCA+IDB9XHJcblx0XHRcdFx0PHRoPlxyXG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiY2hlY2tib3hcIiBvbjpjaGFuZ2U9XCJzZWxlY3RBbGxJdGVtcyh0aGlzKVwiPlxyXG5cdFx0XHRcdDwvdGg+XHJcblx0XHRcdFx0ey9pZn1cclxuXHJcblx0XHRcdFx0eyNlYWNoIGNvbHVtbnNPcmRlcmVkIGFzIGNvbHVtbn1cclxuXHRcdFx0XHR7I2lmIGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzICE9IG51bGwgJiYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXNbXCJzb3J0YWJsZUJ5XCJdICE9IG51bGx9XHJcblx0XHRcdFx0XHR7I2lmIGNvbHVtbi5hc2NlbmRpbmd9XHJcblx0XHRcdFx0XHQ8dGggY2xhc3M9XCJzb3J0YWJsZS1jb2x1bW5cIiBvbjpjbGljaz1cInNvcnREYXRhKGNvbHVtbixjb2x1bW5zT3JkZXJlZClcIj57Y29sdW1uLmxhYmVsfSA8aSBjbGFzcz1cImZhIGZhLXNvcnQtZG93blwiPjwvaT48L3RoPlxyXG5cdFx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdFx0PHRoIGNsYXNzPVwic29ydGFibGUtY29sdW1uXCIgb246Y2xpY2s9XCJzb3J0RGF0YShjb2x1bW4sY29sdW1uc09yZGVyZWQpXCI+e2NvbHVtbi5sYWJlbH0gPGkgY2xhc3M9XCJmYSBmYS1zb3J0LXVwXCI+PC9pPjwvdGg+XHJcblx0XHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdHs6ZWxzZX1cclxuXHRcdFx0XHQ8dGg+XHJcblx0XHRcdFx0XHR7I2lmIGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzICE9IG51bGwgJiYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXNbXCJkb2N1bWVudGF0aW9uXCJdICE9IG51bGx9XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGVscC10b29sdGlwXCI+e2NvbHVtbi5sYWJlbH1cclxuXHRcdFx0XHRcdFx0PFRvb2x0aXAgZGF0YT1cIntjb2x1bW4uY3VzdG9tUHJvcGVydGllcy5kb2N1bWVudGF0aW9uWzBdfVwiPjwvVG9vbHRpcD5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdFx0e2NvbHVtbi5sYWJlbH1cclxuXHRcdFx0XHRcdHsvaWZ9XHJcblx0XHRcdFx0PC90aD5cclxuXHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdHsvZWFjaH1cclxuXHRcdFx0PC90cj5cclxuXHRcdDwvdGhlYWQ+XHJcblx0XHQ8dGJvZHk+XHJcblx0XHRcdHsjaWYgbWFwICE9IG51bGx9XHJcblx0XHRcdHsjZWFjaCBmaWVsZC5kYXRhIGFzIHJvd31cclxuXHRcdFx0PHRyIGNsYXNzPVwie2dldFJvd0Nzc0NsYXNzKHJvdyl9XCI+XHJcblx0XHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwfVxyXG5cdFx0XHRcdFx0PHRkPlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBmb3JtLWNoZWNrXCI+XHJcblx0XHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiY2hlY2tib3hcIiBvbjpjaGFuZ2U9XCJzZWxlY3RJdGVtKHRoaXMsIHJvdylcIj5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8L3RkPlxyXG5cdFx0XHRcdHsvaWZ9XHJcblxyXG5cdFx0XHRcdHsjZWFjaCBjb2x1bW5zT3JkZXJlZCBhcyBjb2x1bW59XHJcblx0XHRcdFx0PHRkPlxyXG5cdFx0XHRcdFx0eyNpZiAhKGdldEZpZWxkKHJvdywgY29sdW1uKS5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImhpZGVJZk51bGxcIikgPT09IHRydWUgJiYgZ2V0RmllbGQocm93LCBjb2x1bW4pLmRhdGEgPT09IG51bGwpfVxyXG5cdFx0XHRcdFx0IDxGb3JtT3V0cHV0IGZpZWxkPVwie2dldEZpZWxkKHJvdywgY29sdW1uKX1cIiBhcHA9XCJ7YXBwfVwiIGZvcm09XCJ7Zm9ybX1cIiBwYXJlbnQ9XCJ7cGFyZW50fVwiIHNob3dMYWJlbD1cImZhbHNlXCIgLz5cclxuXHRcdFx0XHQgXHR7L2lmfVxyXG5cdFx0XHRcdDwvdGQ+XHJcblx0XHRcdFx0ey9lYWNofVxyXG5cdFx0XHQ8L3RyPlxyXG5cdFx0XHR7L2VhY2h9XHJcblx0XHRcdHsvaWZ9XHJcblx0XHQ8L3Rib2R5PlxyXG5cdDwvdGFibGU+XHJcblxyXG5cdHsjaWYgYnVsa0FjdGlvbnMubGVuZ3RoID4gMH1cclxuXHRcdDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9XCJpc0J1bGtBY3Rpb25Nb2RhbE9wZW5cIiBjbGFzcz1cImhpZGRlblwiIC8+XHJcblx0XHQ8ZGl2IGNsYXNzPVwibW9kYWxcIj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cImNhcmRcIj5cclxuXHRcdFx0XHQ8bGFiZWwgY2xhc3M9XCJjbG9zZVwiIG9uOmNsaWNrPVwiY2xvc2VCdWxrQWN0aW9uTW9kYWwobnVsbClcIj48L2xhYmVsPlxyXG5cdFx0XHRcdDxkaXYgcmVmOmJ1bGtBY3Rpb25Db250YWluZXI+PC9kaXY+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9kaXY+XHJcblx0ey9pZn1cclxuezplbHNlfVxyXG5cdDxkaXYgY2xhc3M9XCJhbGVydC1ub2RhdGFcIj5cclxuXHRcdE5vIGRhdGEuXHJcblx0PC9kaXY+XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGltcG9ydCBGb3JtQ29tcG9uZW50IGZyb20gXCJjb3JlLXVpL0Zvcm1cIjtcclxuXHRpbXBvcnQgRm9ybU91dHB1dCBmcm9tIFwiLi4vT3V0cHV0XCI7XHJcblx0aW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2hlbHAvVG9vbHRpcFwiO1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZEZpbHRlcihjdXJyZW50Rm9ybUluc3RhbmNlLCBwYXJhbWV0ZXJzKSB7XHJcblx0XHRsZXQgcHJvbWlzZTtcclxuXHJcblx0XHRjb25zdCBmaWx0ZXIgPSB7fTtcclxuXHRcdGlmIChwYXJhbWV0ZXJzICE9IG51bGwgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHByb21pc2UgPSBjdXJyZW50Rm9ybUluc3RhbmNlLmdldFNlcmlhbGl6ZWRJbnB1dFZhbHVlcygpLnRoZW4oZGF0YSA9PiB7XHJcblx0XHRcdFx0Zm9yIChjb25zdCBwIG9mIHBhcmFtZXRlcnMpIHtcclxuXHRcdFx0XHRcdGZpbHRlcltwXSA9IGRhdGFbcF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmlsdGVyO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZpbHRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb21pc2U7XHJcblx0fVxyXG5cclxuXHRjb25zdCBtb2RhbHMgPSBbXTtcclxuXHJcblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMzNjk3NDMvMTExNDM4XHJcblx0Ly8gQ2xvc2UgdG9wbW9zdCBtb2RhbCB3aGVuIHVzZXIgcHJlc3NlcyBlc2NhcGUga2V5LlxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4ge1xyXG5cdFx0Y29uc3QgZXZ0ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRsZXQgaXNFc2NhcGUgPSBmYWxzZTtcclxuXHRcdGlmIChcImtleVwiIGluIGV2dCkge1xyXG5cdFx0XHRpc0VzY2FwZSA9IChldnQua2V5ID09PSBcIkVzY2FwZVwiIHx8IGV2dC5rZXkgPT09IFwiRXNjXCIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlzRXNjYXBlID0gKGV2dC5rZXlDb2RlID09PSAyNyk7XHJcblx0XHR9XHJcblx0XHRpZiAoaXNFc2NhcGUpIHtcclxuXHRcdFx0aWYgKG1vZGFscy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0Ly8gQ2xvc2UgdG9wbW9zdCBtb2RhbC5cclxuXHRcdFx0XHRtb2RhbHNbbW9kYWxzLmxlbmd0aCAtIDFdLmNsb3NlQnVsa0FjdGlvbk1vZGFsKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdGNvbnN0IHsgZGF0YSB9ID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHJcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHsgbWV0YWRhdGEgfSA9IHRoaXMuZ2V0KCkuZmllbGQ7XHJcblx0XHRcdGNvbnN0IHsgcm93Q3NzQ2xhc3MgfSA9IChtZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzIHx8IHt9KTtcclxuXHJcblx0XHRcdC8vIENyZWF0ZSBtYXAsIHdpdGgga2V5IGJlaW5nIHRoZSBsb3dlcmNhc2UgdmVyc2lvbiBvZiB0aGUgcHJvcGVydHkgbmFtZVxyXG5cdFx0XHQvLyBhbmQgdmFsdWUgYmVpbmcgdGhlIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLlxyXG5cdFx0XHRjb25zdCBtYXAgPSB7fTtcclxuXHRcdFx0aWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IGZpcnN0Um93ID0gZGF0YVswXTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhmaXJzdFJvdykpIHtcclxuXHRcdFx0XHRcdG1hcFtwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpXSA9IHByb3BlcnR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdC8vIFNob3cgdGFibGUgb25seSBhZnRlciB0aGUgYG9uY3JlYXRlYCBtZXRob2QgaGFzIHJ1bi5cclxuXHRcdFx0XHR2aXNpYmxlOiB0cnVlLFxyXG5cdFx0XHRcdGJ1bGtBY3Rpb25zOiAobWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fSkuYnVsa0FjdGlvbiB8fCBbXSxcclxuXHRcdFx0XHRtYXAsXHJcblx0XHRcdFx0Z2V0RmllbGQocm93LCBjb2x1bW4pIHtcclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gcm93W21hcFtjb2x1bW4uaWQudG9Mb3dlckNhc2UoKV1dO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHZhbHVlLFxyXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogY29sdW1uXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Z2V0Um93Q3NzQ2xhc3Mocm93KSB7XHJcblx0XHRcdFx0XHRsZXQgY3NzQ2xhc3MgPSBcIlwiO1xyXG5cclxuXHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGNzc0NsYXNzID0gcm93Q3NzQ2xhc3MuY3NzQ2xhc3MgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcy5zdWZmaXggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGNzc0NsYXNzICs9IHJvd1ttYXBbcm93Q3NzQ2xhc3Muc3VmZml4LnRvTG93ZXJDYXNlKCldXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjc3NDbGFzcztcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNlbGVjdGVkSXRlbXNDb3VudDogMFxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblx0XHRjb21wdXRlZDoge1xyXG5cdFx0XHRjb2x1bW5zT3JkZXJlZDogKHsgZmllbGQgfSkgPT4gZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5jb2x1bW5zXHJcblx0XHRcdFx0LmZpbHRlcihiID0+ICFiLmhpZGRlbilcclxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4gYS5vcmRlckluZGV4IC0gYi5vcmRlckluZGV4KVxyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0YXN5bmMgcnVuQnVsa0FjdGlvbihhY3Rpb24pIHtcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcclxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZEl0ZW1zID0gdGhpcy5nZXQoKS5maWVsZC5kYXRhLmZpbHRlcih0ID0+IHQuX19zZWxlY3RlZCA9PT0gdHJ1ZSk7XHJcblx0XHRcdFx0Y29uc3QgbWFwID0gdGhpcy5nZXQoKS5tYXA7XHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJdGVtSWRzID0gc2VsZWN0ZWRJdGVtcy5tYXAodCA9PiB0W21hcFthY3Rpb24uaXRlbUlkZW50aWZpZXJGaWVsZC50b0xvd2VyQ2FzZSgpXV0pO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IHRydWVcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXBwID0gdGhpcy5nZXQoKS5hcHA7XHJcblx0XHRcdFx0Y29uc3QgZm9ybUluc3RhbmNlID0gYXBwLmdldEZvcm1JbnN0YW5jZShhY3Rpb24uZm9ybUlkLCB0cnVlKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZmlsdGVyID0gYXdhaXQgYnVpbGRGaWx0ZXIodGhpcy5nZXQoKS5mb3JtLCBhY3Rpb24ucGFyYW1ldGVycyk7XHJcblx0XHRcdFx0ZmlsdGVyLkl0ZW1zID0geyBpdGVtczogc2VsZWN0ZWRJdGVtSWRzIH07XHJcblx0XHRcdFx0Zm9ybUluc3RhbmNlLnNldElucHV0RmllbGRzKGZpbHRlcik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGYgPSBuZXcgRm9ybUNvbXBvbmVudCh7XHJcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMucmVmcy5idWxrQWN0aW9uQ29udGFpbmVyLFxyXG5cdFx0XHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogZm9ybUluc3RhbmNlLm1ldGFkYXRhLFxyXG5cdFx0XHRcdFx0XHRmb3JtOiBmb3JtSW5zdGFuY2UsXHJcblx0XHRcdFx0XHRcdGFwcCxcclxuXHRcdFx0XHRcdFx0dXNlVXJsOiBmYWxzZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRmLmluaXQoKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XHJcblx0XHRcdFx0Zi5vbihcImZvcm06cmVzcG9uc2VIYW5kbGVkXCIsIGUgPT4ge1xyXG5cdFx0XHRcdFx0c2VsZi5jbG9zZUJ1bGtBY3Rpb25Nb2RhbChlLnJlc3BvbnNlKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0Y3VycmVudEJ1bGtBY3Rpb25Gb3JtOiBmXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdG1vZGFscy5wdXNoKHRoaXMpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRhc3luYyBjbG9zZUJ1bGtBY3Rpb25Nb2RhbChyZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRCdWxrQWN0aW9uRm9ybSA9IHRoaXMuZ2V0KCkuY3VycmVudEJ1bGtBY3Rpb25Gb3JtO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IGZhbHNlLFxyXG5cdFx0XHRcdFx0Y3VycmVudEJ1bGtBY3Rpb25Gb3JtOiBudWxsXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRCdWxrQWN0aW9uRm9ybS5kZXN0cm95KCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm1Db21wb25lbnQgPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKHJlc3BvbnNlICE9IG51bGwgJiZcclxuXHRcdFx0XHRcdHJlc3BvbnNlLm1ldGFkYXRhLmhhbmRsZXIgIT09IFwicmVkaXJlY3RcIiAmJlxyXG5cdFx0XHRcdFx0cmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWxvYWRcIikge1xyXG5cdFx0XHRcdFx0Ly8gSWYgYXNrZWQgdG8gcmVkaXJlY3QgdG8gYW5vdGhlciBmb3JtLCB0aGVuIHdlIHJlZGlyZWN0XHJcblx0XHRcdFx0XHQvLyBhbmQgZG8gbm90IHJlbG9hZCBwYXJlbnQgZm9ybSwgYXMgdGhhdCB3b3VsZCBiZSBhIHdhc3RlZCBlZmZvcnQuXHJcblx0XHRcdFx0XHRhd2FpdCBwYXJlbnRGb3JtQ29tcG9uZW50LnN1Ym1pdChudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1vZGFscy5wb3AoKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0c2VsZWN0SXRlbShjaGVja2JveEVsZW1lbnQsIHJvdykge1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRyb3cuX19zZWxlY3RlZCA9IGNoZWNrYm94RWxlbWVudC5jaGVja2VkO1xyXG5cclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcclxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZEl0ZW1zID0gdGhpcy5nZXQoKS5maWVsZC5kYXRhLmZpbHRlcih0ID0+IHQuX19zZWxlY3RlZCA9PT0gdHJ1ZSk7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBzZWxlY3RlZEl0ZW1zQ291bnQ6IHNlbGVjdGVkSXRlbXMubGVuZ3RoIH0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZWxlY3RBbGxJdGVtcyhjaGVja2JveEVsZW1lbnQpIHtcclxuXHRcdFx0XHRmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLmdldCgpLmZpZWxkLmRhdGEpIHtcclxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRcdHJvdy5fX3NlbGVjdGVkID0gY2hlY2tib3hFbGVtZW50LmNoZWNrZWQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBjaGVja2JveGVzID0gdGhpcy5yZWZzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0Ym9keT50cj50ZCAuY2hlY2tib3hcIik7XHJcblxyXG5cdFx0XHRcdGZvciAoY29uc3QgY2hlY2tib3ggb2YgY2hlY2tib3hlcykge1xyXG5cdFx0XHRcdFx0Y2hlY2tib3guY2hlY2tlZCA9IGNoZWNrYm94RWxlbWVudC5jaGVja2VkO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJdGVtcyA9IHRoaXMuZ2V0KCkuZmllbGQuZGF0YS5maWx0ZXIodCA9PiB0Ll9fc2VsZWN0ZWQgPT09IHRydWUpO1xyXG5cdFx0XHRcdHRoaXMuc2V0KHsgc2VsZWN0ZWRJdGVtc0NvdW50OiBzZWxlY3RlZEl0ZW1zLmxlbmd0aCB9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0c29ydERhdGEoY29sdW1uLCBjb2x1bW5zKSB7XHJcblx0XHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5nZXQoKS5wYXJlbnQ7XHJcblx0XHRcdFx0Y29uc3QgZm9ybSA9IHBhcmVudC5nZXQoKS5mb3JtO1xyXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHRcdFx0XHRjb25zdCBwYWdpbmF0b3JJbnB1dCA9IGZvcm0uaW5wdXRzXHJcblx0XHRcdFx0XHQuZmluZCh0ID0+IHQubWV0YWRhdGEuaWQgPT09IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMuY3VzdG9taXphdGlvbnMucGFnaW5hdG9yKTtcclxuXHJcblx0XHRcdFx0aWYgKHBhZ2luYXRvcklucHV0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdHBhZ2luYXRvcklucHV0LnZhbHVlLm9yZGVyQnkgPSBjb2x1bW4uY3VzdG9tUHJvcGVydGllcy5zb3J0YWJsZUJ5O1xyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBpIG9mIGNvbHVtbnMpIHtcclxuXHRcdFx0XHRcdFx0aS5hc2NlbmRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRwYWdpbmF0b3JJbnB1dC52YWx1ZS5hc2NlbmRpbmcgPSAhcGFnaW5hdG9ySW5wdXQudmFsdWUuYXNjZW5kaW5nO1xyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcblx0XHRcdFx0XHRjb2x1bW4uYXNjZW5kaW5nID0gcGFnaW5hdG9ySW5wdXQudmFsdWUuYXNjZW5kaW5nO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHBhcmFtcyA9IHt9O1xyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBpIG9mIGZvcm0uaW5wdXRzKSB7XHJcblx0XHRcdFx0XHRcdHBhcmFtc1tpLm1ldGFkYXRhLmlkXSA9IGkudmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmb3JtLnNldElucHV0RmllbGRzKHBhcmFtcyk7XHJcblx0XHRcdFx0XHRwYXJlbnQuc3VibWl0KG51bGwsIGZhbHNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRjb21wb25lbnRzOiB7XHJcblx0XHRcdEZvcm1PdXRwdXQsXHJcblx0XHRcdFRvb2x0aXBcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQuYnRuLXJvdyB7XHJcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcclxuXHR9XHJcblxyXG5cdC5jaGVja2JveCB7XHJcblx0XHRjbGlwOiB1bnNldDtcclxuXHRcdGNsaXAtcGF0aDogdW5zZXQ7XHJcblx0XHRwb3NpdGlvbjogdW5zZXQ7XHJcblx0XHR3aWR0aDogMTVweDtcclxuXHRcdGhlaWdodDogMTVweDtcclxuXHR9XHJcblxyXG5cdC5zb3J0YWJsZS1jb2x1bW4ge1xyXG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1UQyxRQUFRLGNBQUMsQ0FBQyxBQUNULFVBQVUsQ0FBRSxLQUFLLEFBQ2xCLENBQUMsQUFFRCxTQUFTLGNBQUMsQ0FBQyxBQUNWLElBQUksQ0FBRSxLQUFLLENBQ1gsU0FBUyxDQUFFLEtBQUssQ0FDaEIsUUFBUSxDQUFFLEtBQUssQ0FDZixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2IsQ0FBQyxBQUVELGdCQUFnQixjQUFDLENBQUMsQUFDakIsTUFBTSxDQUFFLE9BQU8sQUFDaEIsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$y(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_4(ctx) {
    		if (ctx.visible && ctx.field.data != null && ctx.field.data.length > 0) return create_if_block$o;
    		return create_if_block_15;
    	}

    	var current_block_type = select_block_type_4(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (7:5) {#each bulkActions as action}
    function create_each_block$8(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.selectedItemsCount > 0) return create_if_block_2$b;
    		return create_if_block_3$6;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (8:6) {#if selectedItemsCount > 0 }
    function create_if_block_2$b(component, ctx) {
    	var button, text_value = ctx.action.label, text, text_1, small, text_2, text_3, text_4;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text = createText(text_value);
    			text_1 = createText(" ");
    			small = createElement("small");
    			text_2 = createText("(");
    			text_3 = createText(ctx.selectedItemsCount);
    			text_4 = createText(")");
    			addLoc(small, file$y, 8, 87, 374);

    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$2);
    			button.className = "btn btn-default";
    			addLoc(button, file$y, 8, 7, 294);
    		},

    		m: function mount(target, anchor) {
    			insertNode(button, target, anchor);
    			appendNode(text, button);
    			appendNode(text_1, button);
    			appendNode(small, button);
    			appendNode(text_2, small);
    			appendNode(text_3, small);
    			appendNode(text_4, small);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.bulkActions) && text_value !== (text_value = ctx.action.label)) {
    				text.data = text_value;
    			}

    			if (changed.selectedItemsCount) {
    				text_3.data = ctx.selectedItemsCount;
    			}

    			button._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}

    			removeListener(button, "click", click_handler$2);
    		}
    	};
    }

    // (10:6) {:else}
    function create_if_block_3$6(component, ctx) {
    	var button, text_value = ctx.action.label, text;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text = createText(text_value);
    			button.className = "btn btn-default";
    			button.disabled = true;
    			addLoc(button, file$y, 10, 7, 444);
    		},

    		m: function mount(target, anchor) {
    			insertNode(button, target, anchor);
    			appendNode(text, button);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.bulkActions) && text_value !== (text_value = ctx.action.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}
    		}
    	};
    }

    // (4:3) {#if bulkActions.length > 0 }
    function create_if_block_1$e(component, ctx) {
    	var tr, td, td_colspan_value;

    	var each_value = ctx.bulkActions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(component, get_each_context$8(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			td = createElement("td");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			td.colSpan = td_colspan_value = ctx.columnsOrdered.length + 1;
    			td.className = "btn-row svelte-z80lq2";
    			addLoc(td, file$y, 5, 4, 154);
    			addLoc(tr, file$y, 4, 3, 144);
    		},

    		m: function mount(target, anchor) {
    			insertNode(tr, target, anchor);
    			appendNode(td, tr);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(td, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.selectedItemsCount || changed.bulkActions) {
    				each_value = ctx.bulkActions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$8(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(td, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if ((changed.columnsOrdered) && td_colspan_value !== (td_colspan_value = ctx.columnsOrdered.length + 1)) {
    				td.colSpan = td_colspan_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (18:4) {#if bulkActions.length > 0}
    function create_if_block_4$4(component, ctx) {
    	var th, input;

    	function change_handler(event) {
    		component.selectAllItems(this);
    	}

    	return {
    		c: function create() {
    			th = createElement("th");
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-z80lq2";
    			addLoc(input, file$y, 19, 5, 626);
    			addLoc(th, file$y, 18, 4, 615);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			appendNode(input, th);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (24:4) {#each columnsOrdered as column}
    function create_each_block_1$3(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_3(ctx) {
    		if (ctx.column.customProperties != null && ctx.column.customProperties["sortableBy"] != null) return create_if_block_5$2;
    		return create_if_block_8;
    	}

    	var current_block_type = select_block_type_3(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (26:5) {#if column.ascending}
    function create_if_block_6$1(component, ctx) {
    	var th, text_value = ctx.column.label, text, text_1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text = createText(text_value);
    			text_1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-down";
    			addLoc(i, file$y, 26, 91, 975);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_1);
    			th.className = "sortable-column svelte-z80lq2";
    			addLoc(th, file$y, 26, 5, 889);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			appendNode(text, th);
    			appendNode(text_1, th);
    			appendNode(i, th);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_1);
    		}
    	};
    }

    // (28:5) {:else}
    function create_if_block_7$1(component, ctx) {
    	var th, text_value = ctx.column.label, text, text_1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text = createText(text_value);
    			text_1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-up";
    			addLoc(i, file$y, 28, 91, 1118);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_2);
    			th.className = "sortable-column svelte-z80lq2";
    			addLoc(th, file$y, 28, 5, 1032);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			appendNode(text, th);
    			appendNode(text_1, th);
    			appendNode(i, th);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_2);
    		}
    	};
    }

    // (33:5) {#if column.customProperties != null && column.customProperties["documentation"] != null}
    function create_if_block_9(component, ctx) {
    	var div, text_value = ctx.column.label, text, text_1;

    	var tooltip_initial_data = { data: ctx.column.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText(text_value);
    			text_1 = createText("\r\n\t\t\t\t\t\t");
    			tooltip._fragment.c();
    			div.className = "help-tooltip";
    			addLoc(div, file$y, 33, 5, 1290);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(text, div);
    			appendNode(text_1, div);
    			tooltip._mount(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}

    			var tooltip_changes = {};
    			if (changed.columnsOrdered) tooltip_changes.data = ctx.column.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    // (37:5) {:else}
    function create_if_block_10(component, ctx) {
    	var text_value = ctx.column.label, text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insertNode(text, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    // (25:4) {#if column.customProperties != null && column.customProperties["sortableBy"] != null}
    function create_if_block_5$2(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_1(ctx) {
    		if (ctx.column.ascending) return create_if_block_6$1;
    		return create_if_block_7$1;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (31:4) {:else}
    function create_if_block_8(component, ctx) {
    	var th;

    	function select_block_type_2(ctx) {
    		if (ctx.column.customProperties != null && ctx.column.customProperties["documentation"] != null) return create_if_block_9;
    		return create_if_block_10;
    	}

    	var current_block_type = select_block_type_2(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			th = createElement("th");
    			if_block.c();
    			addLoc(th, file$y, 31, 4, 1183);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			if_block.m(th, null);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(th, null);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			if_block.d();
    		}
    	};
    }

    // (47:3) {#each field.data as row}
    function create_each_block_2$1(component, ctx) {
    	var tr, text, tr_class_value;

    	var if_block = (ctx.bulkActions.length > 0) && create_if_block_12(component, ctx);

    	var each_value_3 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(component, get_each_context_3(ctx, each_value_3, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n\t\t\t\t");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			tr.className = tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-z80lq2";
    			addLoc(tr, file$y, 47, 3, 1592);
    		},

    		m: function mount(target, anchor) {
    			insertNode(tr, target, anchor);
    			if (if_block) if_block.m(tr, null);
    			appendNode(text, tr);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_12(component, ctx);
    					if_block.c();
    					if_block.m(tr, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.getField || changed.field || changed.columnsOrdered || changed.app || changed.form || changed.parent) {
    				each_value_3 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_3(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_3.length;
    			}

    			if ((changed.getRowCssClass || changed.field) && tr_class_value !== (tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-z80lq2")) {
    				tr.className = tr_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			if (if_block) if_block.d();

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (49:4) {#if bulkActions.length > 0}
    function create_if_block_12(component, ctx) {
    	var td, div, input;

    	return {
    		c: function create() {
    			td = createElement("td");
    			div = createElement("div");
    			input = createElement("input");
    			input._svelte = { component, ctx };

    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-z80lq2";
    			addLoc(input, file$y, 51, 7, 1723);
    			div.className = "form-group form-check";
    			addLoc(div, file$y, 50, 6, 1679);
    			addLoc(td, file$y, 49, 5, 1667);
    		},

    		m: function mount(target, anchor) {
    			insertNode(td, target, anchor);
    			appendNode(div, td);
    			appendNode(input, div);
    		},

    		p: function update(changed, ctx) {
    			input._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (57:4) {#each columnsOrdered as column}
    function create_each_block_3(component, ctx) {
    	var td;

    	var if_block = (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull") === true && ctx.getField(ctx.row, ctx.column).data === null)) && create_if_block_13(component, ctx);

    	return {
    		c: function create() {
    			td = createElement("td");
    			if (if_block) if_block.c();
    			addLoc(td, file$y, 57, 4, 1880);
    		},

    		m: function mount(target, anchor) {
    			insertNode(td, target, anchor);
    			if (if_block) if_block.m(td, null);
    		},

    		p: function update(changed, ctx) {
    			if (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull") === true && ctx.getField(ctx.row, ctx.column).data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_13(component, ctx);
    					if_block.c();
    					if_block.m(td, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (59:5) {#if !(getField(row, column).metadata.getCustomProperty("hideIfNull") === true && getField(row, column).data === null)}
    function create_if_block_13(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.getField(ctx.row, ctx.column),
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.parent,
    	 	showLabel: "false"
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.getField || changed.field || changed.columnsOrdered) formoutput_changes.field = ctx.getField(ctx.row, ctx.column);
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.parent) formoutput_changes.parent = ctx.parent;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (46:3) {#if map != null}
    function create_if_block_11(component, ctx) {
    	var each_anchor;

    	var each_value_2 = ctx.field.data;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(component, get_each_context_2$1(ctx, each_value_2, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insertNode(each_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.getRowCssClass || changed.field || changed.bulkActions || changed.columnsOrdered || changed.getField || changed.app || changed.form || changed.parent) {
    				each_value_2 = ctx.field.data;

    				for (var i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_2.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    // (70:1) {#if bulkActions.length > 0}
    function create_if_block_14(component, ctx) {
    	var input, text, div, div_1, label, text_1, div_2;

    	function input_change_handler() {
    		component.set({ isBulkActionModalOpen: input.checked });
    	}

    	function click_handler_3(event) {
    		component.closeBulkActionModal(null);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			text = createText("\r\n\t\t");
    			div = createElement("div");
    			div_1 = createElement("div");
    			label = createElement("label");
    			text_1 = createText("\r\n\t\t\t\t");
    			div_2 = createElement("div");
    			addListener(input, "change", input_change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden";
    			addLoc(input, file$y, 70, 2, 2255);
    			addListener(label, "click", click_handler_3);
    			label.className = "close";
    			addLoc(label, file$y, 73, 4, 2384);
    			addLoc(div_2, file$y, 74, 4, 2457);
    			div_1.className = "card";
    			addLoc(div_1, file$y, 72, 3, 2360);
    			div.className = "modal";
    			addLoc(div, file$y, 71, 2, 2336);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);

    			input.checked = ctx.isBulkActionModalOpen;

    			insertNode(text, target, anchor);
    			insertNode(div, target, anchor);
    			appendNode(div_1, div);
    			appendNode(label, div_1);
    			appendNode(text_1, div_1);
    			appendNode(div_2, div_1);
    			component.refs.bulkActionContainer = div_2;
    		},

    		p: function update(changed, ctx) {
    			input.checked = ctx.isBulkActionModalOpen;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    			if (detach) {
    				detachNode(text);
    				detachNode(div);
    			}

    			removeListener(label, "click", click_handler_3);
    			if (component.refs.bulkActionContainer === div_2) component.refs.bulkActionContainer = null;
    		}
    	};
    }

    // (1:0) {#if visible && field.data != null && field.data.length > 0}
    function create_if_block$o(component, ctx) {
    	var table, thead, text, tr, text_1, text_4, tbody, text_7, if_block_3_anchor;

    	var if_block = (ctx.bulkActions.length > 0) && create_if_block_1$e(component, ctx);

    	var if_block_1 = (ctx.bulkActions.length > 0) && create_if_block_4$4(component, ctx);

    	var each_value_1 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(component, get_each_context_1$3(ctx, each_value_1, i));
    	}

    	var if_block_2 = (ctx.map != null) && create_if_block_11(component, ctx);

    	var if_block_3 = (ctx.bulkActions.length > 0) && create_if_block_14(component, ctx);

    	return {
    		c: function create() {
    			table = createElement("table");
    			thead = createElement("thead");
    			if (if_block) if_block.c();
    			text = createText("\r\n\t\t\t");
    			tr = createElement("tr");
    			if (if_block_1) if_block_1.c();
    			text_1 = createText("\r\n\r\n\t\t\t\t");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text_4 = createText("\r\n\t\t");
    			tbody = createElement("tbody");
    			if (if_block_2) if_block_2.c();
    			text_7 = createText("\r\n\r\n\t");
    			if (if_block_3) if_block_3.c();
    			if_block_3_anchor = createComment();
    			addLoc(tr, file$y, 16, 3, 571);
    			addLoc(thead, file$y, 2, 2, 98);
    			addLoc(tbody, file$y, 44, 2, 1528);
    			table.className = "table";
    			addLoc(table, file$y, 1, 1, 63);
    		},

    		m: function mount(target, anchor) {
    			insertNode(table, target, anchor);
    			appendNode(thead, table);
    			if (if_block) if_block.m(thead, null);
    			appendNode(text, thead);
    			appendNode(tr, thead);
    			if (if_block_1) if_block_1.m(tr, null);
    			appendNode(text_1, tr);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			appendNode(text_4, table);
    			appendNode(tbody, table);
    			if (if_block_2) if_block_2.m(tbody, null);
    			component.refs.table = table;
    			insertNode(text_7, target, anchor);
    			if (if_block_3) if_block_3.m(target, anchor);
    			insertNode(if_block_3_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$e(component, ctx);
    					if_block.c();
    					if_block.m(thead, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (!if_block_1) {
    					if_block_1 = create_if_block_4$4(component, ctx);
    					if_block_1.c();
    					if_block_1.m(tr, text_1);
    				}
    			} else if (if_block_1) {
    				if_block_1.d(1);
    				if_block_1 = null;
    			}

    			if (changed.columnsOrdered) {
    				each_value_1 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$3(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (ctx.map != null) {
    				if (if_block_2) {
    					if_block_2.p(changed, ctx);
    				} else {
    					if_block_2 = create_if_block_11(component, ctx);
    					if_block_2.c();
    					if_block_2.m(tbody, null);
    				}
    			} else if (if_block_2) {
    				if_block_2.d(1);
    				if_block_2 = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (if_block_3) {
    					if_block_3.p(changed, ctx);
    				} else {
    					if_block_3 = create_if_block_14(component, ctx);
    					if_block_3.c();
    					if_block_3.m(if_block_3_anchor.parentNode, if_block_3_anchor);
    				}
    			} else if (if_block_3) {
    				if_block_3.d(1);
    				if_block_3 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(table);
    			}

    			if (if_block) if_block.d();
    			if (if_block_1) if_block_1.d();

    			destroyEach(each_blocks, detach);

    			if (if_block_2) if_block_2.d();
    			if (component.refs.table === table) component.refs.table = null;
    			if (detach) {
    				detachNode(text_7);
    			}

    			if (if_block_3) if_block_3.d(detach);
    			if (detach) {
    				detachNode(if_block_3_anchor);
    			}
    		}
    	};
    }

    // (79:0) {:else}
    function create_if_block_15(component, ctx) {
    	var div, text;

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText("No data.");
    			div.className = "alert-nodata";
    			addLoc(div, file$y, 79, 1, 2533);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(text, div);
    		},

    		p: noop,

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	child_ctx.each_value = list;
    	child_ctx.action_index = i;
    	return child_ctx;
    }

    function click_handler$2(event) {
    	const { component, ctx } = this._svelte;

    	component.runBulkAction(ctx.action);
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	child_ctx.each_value_1 = list;
    	child_ctx.column_index = i;
    	return child_ctx;
    }

    function click_handler_1(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function click_handler_2(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	child_ctx.each_value_2 = list;
    	child_ctx.row_index = i;
    	return child_ctx;
    }

    function change_handler(event) {
    	const { component, ctx } = this._svelte;

    	component.selectItem(this, ctx.row);
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	child_ctx.each_value_3 = list;
    	child_ctx.column_index_1 = i;
    	return child_ctx;
    }

    function SvelteComponent$y(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	this._recompute({ field: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('visible' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visible'");
    	if (!('bulkActions' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'bulkActions'");

    	if (!('selectedItemsCount' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'selectedItemsCount'");
    	if (!('map' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'map'");
    	if (!('getRowCssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getRowCssClass'");
    	if (!('getField' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getField'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");
    	if (!('isBulkActionModalOpen' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'isBulkActionModalOpen'");
    	this._intro = true;

    	if (!document.getElementById("svelte-z80lq2-style")) add_css$g();

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$y(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$i.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$y.prototype, protoDev);
    assign(SvelteComponent$y.prototype, methods$8);

    SvelteComponent$y.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('columnsOrdered' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'columnsOrdered'");
    };

    SvelteComponent$y.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field) {
    		if (this._differs(state.columnsOrdered, (state.columnsOrdered = columnsOrdered(state)))) changed.columnsOrdered = true;
    	}
    };

    /* src\core\ui\outputs\Paginator.html generated by Svelte v2.9.5 */

    function pages({ field, form, parent }) {
    	const paginatorInput = form.inputs
    		.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    	const pageCount = Math.ceil(field.data.totalCount / paginatorInput.value.pageSize);

    	const params = {};
    	for (const i of form.inputs) {
    		params[i.metadata.id] = i.value;
    	}

    	if (pageCount > 0) {
    		if (pageCount < paginatorInput.value.pageIndex) {
    			paginatorInput.value.pageIndex = 1;
    			form.setInputFields(params);
    			parent.submit(null, false);
    		}
    		const pages = [];

    		for (let p = 1; p <= pageCount; ++p) {
    			const pageParams = Object.assign({}, params);
    			pageParams[paginatorInput.metadata.id] = Object.assign({}, pageParams[paginatorInput.metadata.id]);
    			pageParams[paginatorInput.metadata.id].pageIndex = p;

    			pages.push({
    				text: p,
    				params: pageParams,
    				cssClass: paginatorInput.value.pageIndex === p ? "current" : ""
    			});
    		}

    		const firstParams = Object.assign({}, params);
    		firstParams[paginatorInput.metadata.id] = Object.assign({}, firstParams[paginatorInput.metadata.id]);
    		firstParams[paginatorInput.metadata.id].pageIndex = 1;

    		const first = {
    			text: "First",
    			params: firstParams,
    			cssClass: paginatorInput.value.pageIndex === 1 ? "btn disabled" : ""
    		};
    		const prevParams = Object.assign({}, params);
    		prevParams[paginatorInput.metadata.id] = Object.assign({}, prevParams[paginatorInput.metadata.id]);
    		prevParams[paginatorInput.metadata.id].pageIndex = paginatorInput.value.pageIndex - 1;

    		const previous = {
    			text: "Previous",
    			params: prevParams,
    			cssClass: paginatorInput.value.pageIndex === 1 ? "btn disabled" : ""
    		};

    		const nextParams = Object.assign({}, params);
    		nextParams[paginatorInput.metadata.id] = Object.assign({}, nextParams[paginatorInput.metadata.id]);
    		nextParams[paginatorInput.metadata.id].pageIndex = paginatorInput.value.pageIndex + 1;

    		const next = {
    			text: "Next",
    			params: nextParams,
    			cssClass: paginatorInput.value.pageIndex === pageCount ? "btn disabled" : ""
    		};

    		const lastParams = Object.assign({}, params);
    		lastParams[paginatorInput.metadata.id] = Object.assign({}, lastParams[paginatorInput.metadata.id]);
    		lastParams[paginatorInput.metadata.id].pageIndex = pageCount;

    		const last = {
    			text: "Last",
    			params: lastParams,
    			cssClass: paginatorInput.value.pageIndex === pageCount ? "btn disabled" : ""
    		};

    		let from = paginatorInput.value.pageIndex;
    		let to = paginatorInput.value.pageIndex;

    		if (from < 5) {
    			from = 0; to = 10;
    		}
    		else if (from > pageCount - 5 && pageCount > 10) {
    			to = pageCount; from = pageCount - 10;
    		}
    		else {
    			from -= 5;
    			to += 5;
    		}

    		const innerPages = pages.slice(from, to);
    		innerPages.unshift(previous);
    		innerPages.unshift(first);
    		innerPages.push(next);
    		innerPages.push(last);
    		return innerPages;
    	}

    	return [];
    }

    function data$8() {
    	return {
    		totalCount: 0
    	};
    }
    var methods$9 = {
    	goToPage(page) {
    		const parent = this.get().parent;
    		const form = parent.get().form;

    		form.setInputFields(page.params);
    		parent.submit(null, false);
    	},
    	changePageSize() {
    		const parent = this.get().parent;
    		const form = parent.get().form;
    		const field = this.get().field;

    		const paginatorInput = form.inputs
    			.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    		paginatorInput.value.pageSize = field.pageSize;
    		paginatorInput.value.pageIndex = 1;
    		const params = {};
    		for (const i of form.inputs) {
    			params[i.metadata.id] = i.value;
    		}
    		form.setInputFields(params);
    		parent.submit(null, false);
    	}
    };

    function oncreate$j() {
    	const field = this.get().field;
    	const form = this.get().form;

    	if (field.data == null) {
    		return;
    	}

    	const paginatorInput = form.inputs
    		.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    	field.pageSize = paginatorInput.value.pageSize;
    	this.set({
    		pageSize: field.pageSize
    	});
    	const tableField = new OutputFieldValue();
    	tableField.data = field.data.results;
    	tableField.metadata = field.metadata;

    	// eslint-disable-next-line no-new
    	new SvelteComponent$y({
    		target: this.refs.container,
    		data: {
    			field: tableField,
    			app: this.get().app,
    			form,
    			parent: this.get().parent
    		}
    	});
    }
    const file$z = "src\\core\\ui\\outputs\\Paginator.html";

    function create_main_fragment$z(component, ctx) {
    	var text, div;

    	var if_block = (ctx.field.data != null && ctx.pages.length > 0) && create_if_block$p(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n");
    			div = createElement("div");
    			addLoc(div, file$z, 22, 0, 826);
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(text, target, anchor);
    			insertNode(div, target, anchor);
    			component.refs.container = div;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null && ctx.pages.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$p(component, ctx);
    					if_block.c();
    					if_block.m(text.parentNode, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(text);
    				detachNode(div);
    			}

    			if (component.refs.container === div) component.refs.container = null;
    		}
    	};
    }

    // (11:2) {#each pages as page}
    function create_each_block$9(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.parent.get().useUrl) return create_if_block_1$f;
    		return create_if_block_2$c;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (12:3) {#if parent.get().useUrl}
    function create_if_block_1$f(component, ctx) {
    	var li, a, text_value = ctx.page.text, text, a_href_value, a_class_value;

    	return {
    		c: function create() {
    			li = createElement("li");
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.form.metadata.id, ctx.page.params);
    			a.className = a_class_value = "" + ctx.page.cssClass + " page-link";
    			addLoc(a, file$z, 12, 25, 426);
    			li.className = "page-item";
    			addLoc(li, file$z, 12, 3, 404);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			appendNode(a, li);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.pages) && text_value !== (text_value = ctx.page.text)) {
    				text.data = text_value;
    			}

    			if ((changed.app || changed.form || changed.pages) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.form.metadata.id, ctx.page.params))) {
    				a.href = a_href_value;
    			}

    			if ((changed.pages) && a_class_value !== (a_class_value = "" + ctx.page.cssClass + " page-link")) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}
    		}
    	};
    }

    // (14:3) {:else}
    function create_if_block_2$c(component, ctx) {
    	var li, button, text_value = ctx.page.text, text, button_class_value;

    	return {
    		c: function create() {
    			li = createElement("li");
    			button = createElement("button");
    			text = createText(text_value);
    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$3);
    			button.className = button_class_value = "" + ctx.page.cssClass + " page-link";
    			addLoc(button, file$z, 14, 25, 574);
    			li.className = "page-item";
    			addLoc(li, file$z, 14, 3, 552);
    		},

    		m: function mount(target, anchor) {
    			insertNode(li, target, anchor);
    			appendNode(button, li);
    			appendNode(text, button);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.pages) && text_value !== (text_value = ctx.page.text)) {
    				text.data = text_value;
    			}

    			button._svelte.ctx = ctx;
    			if ((changed.pages) && button_class_value !== (button_class_value = "" + ctx.page.cssClass + " page-link")) {
    				button.className = button_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(li);
    			}

    			removeListener(button, "click", click_handler$3);
    		}
    	};
    }

    // (1:0) {#if field.data != null && pages.length > 0}
    function create_if_block$p(component, ctx) {
    	var div, select, option, text, option_1, text_1, option_2, text_2, option_3, text_3, select_updating = false, text_4, ul, text_6, div_1, text_7, text_8_value = ctx.field.data.results.length, text_8, text_9, text_10_value = ctx.field.data.totalCount, text_10, text_11;

    	function select_change_handler() {
    		select_updating = true;
    		ctx.field.pageSize = selectValue(select);
    		component.set({ field: ctx.field });
    		select_updating = false;
    	}

    	function change_handler(event) {
    		component.changePageSize();
    	}

    	var each_value = ctx.pages;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(component, get_each_context$9(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");
    			select = createElement("select");
    			option = createElement("option");
    			text = createText("10");
    			option_1 = createElement("option");
    			text_1 = createText("20");
    			option_2 = createElement("option");
    			text_2 = createText("50");
    			option_3 = createElement("option");
    			text_3 = createText("100");
    			text_4 = createText("\r\n\r\n\t");
    			ul = createElement("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text_6 = createText("\r\n");
    			div_1 = createElement("div");
    			text_7 = createText("showing ");
    			text_8 = createText(text_8_value);
    			text_9 = createText(" out of ");
    			text_10 = createText(text_10_value);
    			text_11 = createText(" items");
    			option.__value = "10";
    			option.value = option.__value;
    			addLoc(option, file$z, 3, 2, 156);
    			option_1.__value = "20";
    			option_1.value = option_1.__value;
    			addLoc(option_1, file$z, 4, 2, 190);
    			option_2.__value = "50";
    			option_2.value = option_2.__value;
    			addLoc(option_2, file$z, 5, 2, 224);
    			option_3.__value = "100";
    			option_3.value = option_3.__value;
    			addLoc(option_3, file$z, 6, 2, 258);
    			addListener(select, "change", select_change_handler);
    			if (!('field' in ctx)) component.root._beforecreate.push(select_change_handler);
    			addListener(select, "change", change_handler);
    			select.className = "pagination-size input-sm";
    			addLoc(select, file$z, 2, 1, 54);
    			ul.className = "pagination pagination-sm";
    			addLoc(ul, file$z, 9, 1, 307);
    			addLoc(div, file$z, 1, 0, 46);
    			div_1.className = "paginator-summary";
    			addLoc(div_1, file$z, 19, 0, 706);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(select, div);
    			appendNode(option, select);
    			appendNode(text, option);
    			appendNode(option_1, select);
    			appendNode(text_1, option_1);
    			appendNode(option_2, select);
    			appendNode(text_2, option_2);
    			appendNode(option_3, select);
    			appendNode(text_3, option_3);

    			selectOption(select, ctx.field.pageSize);

    			appendNode(text_4, div);
    			appendNode(ul, div);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insertNode(text_6, target, anchor);
    			insertNode(div_1, target, anchor);
    			appendNode(text_7, div_1);
    			appendNode(text_8, div_1);
    			appendNode(text_9, div_1);
    			appendNode(text_10, div_1);
    			appendNode(text_11, div_1);
    		},

    		p: function update(changed, _ctx) {
    			ctx = _ctx;
    			if (!select_updating) selectOption(select, ctx.field.pageSize);

    			if (changed.parent || changed.app || changed.form || changed.pages) {
    				each_value = ctx.pages;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$9(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if ((changed.field) && text_8_value !== (text_8_value = ctx.field.data.results.length)) {
    				text_8.data = text_8_value;
    			}

    			if ((changed.field) && text_10_value !== (text_10_value = ctx.field.data.totalCount)) {
    				text_10.data = text_10_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			removeListener(select, "change", select_change_handler);
    			removeListener(select, "change", change_handler);

    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(text_6);
    				detachNode(div_1);
    			}
    		}
    	};
    }

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.page = list[i];
    	child_ctx.each_value = list;
    	child_ctx.page_index = i;
    	return child_ctx;
    }

    function click_handler$3(event) {
    	const { component, ctx } = this._svelte;

    	component.goToPage(ctx.page);
    }

    function SvelteComponent$z(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign(data$8(), options.data);
    	this._recompute({ field: 1, form: 1, parent: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");

    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    	}

    	this._fragment = create_main_fragment$z(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$j.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    	}
    }

    assign(SvelteComponent$z.prototype, protoDev);
    assign(SvelteComponent$z.prototype, methods$9);

    SvelteComponent$z.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('pages' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'pages'");
    };

    SvelteComponent$z.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field || changed.form || changed.parent) {
    		if (this._differs(state.pages, (state.pages = pages(state)))) changed.pages = true;
    	}
    };

    /* src\core\ui\outputs\Table.html generated by Svelte v2.9.5 */

    function buildFilter$3(currentFormInstance, parameters) {
    	let promise;

    	const filter = {};
    	if (parameters != null && parameters.length > 0) {
    		promise = currentFormInstance.getSerializedInputValues().then(data => {
    			for (const p of parameters) {
    				filter[p] = data[p];
    			}

    			return filter;
    		});
    	}
    	else {
    		promise = Promise.resolve(filter);
    	}

    	return promise;
    }

    const modals$2 = [];

    // https://stackoverflow.com/a/3369743/111438
    // Close topmost modal when user presses escape key.
    document.addEventListener("keydown", e => {
    	const evt = e || window.event;
    	let isEscape = false;
    	if ("key" in evt) {
    		isEscape = (evt.key === "Escape" || evt.key === "Esc");
    	}
    	else {
    		isEscape = (evt.keyCode === 27);
    	}
    	if (isEscape) {
    		if (modals$2.length > 0) {
    			// Close topmost modal.
    			modals$2[modals$2.length - 1].closeBulkActionModal();
    		}
    	}
    });

    function columnsOrdered$1({ field }) {
    	return field.metadata.customProperties.columns
    	.filter(b => !b.hidden)
    	.sort((a, b) => a.orderIndex - b.orderIndex);
    }

    var methods$a = {
    	async runBulkAction(action) {
    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		const map = this.get().map;
    		const selectedItemIds = selectedItems.map(t => t[map[action.itemIdentifierField.toLowerCase()]]);

    		this.set({
    			isBulkActionModalOpen: true
    		});

    		const app = this.get().app;
    		const formInstance = app.getFormInstance(action.formId, true);

    		const filter = await buildFilter$3(this.get().form, action.parameters);
    		filter.Items = { items: selectedItemIds };
    		formInstance.setInputFields(filter);

    		const f = new SvelteComponent$8({
    			target: this.refs.bulkActionContainer,
    			data: {
    				metadata: formInstance.metadata,
    				form: formInstance,
    				app,
    				useUrl: false
    			}
    		});

    		f.init();

    		const self = this;
    		f.on("form:responseHandled", e => {
    			self.closeBulkActionModal(e.response);
    		});

    		this.set({
    			currentBulkActionForm: f
    		});

    		modals$2.push(this);
    	},
    	async closeBulkActionModal(response) {
    		const currentBulkActionForm = this.get().currentBulkActionForm;

    		this.set({
    			isBulkActionModalOpen: false,
    			currentBulkActionForm: null
    		});

    		currentBulkActionForm.destroy();

    		const parentFormComponent = this.get().parent;

    		if (response != null &&
    			response.metadata.handler !== "redirect" &&
    			response.metadata.handler !== "reload") {
    			// If asked to redirect to another form, then we redirect
    			// and do not reload parent form, as that would be a wasted effort.
    			await parentFormComponent.submit(null, true);
    		}

    		modals$2.pop();
    	},
    	selectItem(checkboxElement, row) {
    		// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    		row.__selected = checkboxElement.checked;

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	selectAllItems(checkboxElement) {
    		for (const row of this.get().field.data) {
    			// eslint-disable-next-line no-underscore-dangle, no-param-reassign
    			row.__selected = checkboxElement.checked;
    		}

    		const checkboxes = this.refs.table.querySelectorAll("tbody>tr>td .checkbox");

    		for (const checkbox of checkboxes) {
    			checkbox.checked = checkboxElement.checked;
    		}

    		// eslint-disable-next-line no-underscore-dangle
    		const selectedItems = this.get().field.data.filter(t => t.__selected === true);
    		this.set({ selectedItemsCount: selectedItems.length });
    	},
    	sortData(column, columns) {
    		const parent = this.get().parent;
    		const form = parent.get().form;
    		const field = this.get().field;
    		const paginatorInput = form.inputs
    			.find(t => t.metadata.id === field.metadata.customProperties.customizations.paginator);

    		if (paginatorInput != null) {
    			paginatorInput.value.orderBy = column.customProperties.sortableBy;
    			for (const i of columns) {
    				i.ascending = false;
    			}

    			paginatorInput.value.ascending = !paginatorInput.value.ascending;
    			// eslint-disable-next-line no-param-reassign
    			column.ascending = paginatorInput.value.ascending;

    			const params = {};
    			for (const i of form.inputs) {
    				params[i.metadata.id] = i.value;
    			}
    			form.setInputFields(params);
    			parent.submit(null, false);
    		}
    	}
    };

    function oncreate$k() {
    	const { data } = this.get().field;

    	if (data == null) {
    		return;
    	}

    	const { metadata } = this.get().field;
    	const { rowCssClass } = (metadata.customProperties || {});

    	// Create map, with key being the lowercase version of the property name
    	// and value being the actual property name.
    	const map = {};
    	if (data.length > 0) {
    		const firstRow = data[0];

    		for (const property of Object.keys(firstRow)) {
    			map[property.toLowerCase()] = property;
    		}
    	}

    	this.set({
    		// Show table only after the `oncreate` method has run.
    		visible: true,
    		bulkActions: (metadata.customProperties || {}).bulkAction || [],
    		map,
    		getField(row, column) {
    			const value = row[map[column.id.toLowerCase()]];

    			return {
    				value,
    				metadata: column
    			};
    		},
    		getRowCssClass(row) {
    			let cssClass = "";

    			if (rowCssClass != null) {
    				cssClass = rowCssClass.cssClass || "";

    				if (rowCssClass.suffix != null) {
    					cssClass += row[map[rowCssClass.suffix.toLowerCase()]];
    				}
    			}

    			return cssClass;
    		},
    		selectedItemsCount: 0
    	});
    }
    const file$A = "src\\core\\ui\\outputs\\Table.html";

    function add_css$h() {
    	var style = createElement("style");
    	style.id = 'svelte-z80lq2-style';
    	style.textContent = ".btn-row.svelte-z80lq2{text-align:right}.checkbox.svelte-z80lq2{clip:unset;clip-path:unset;position:unset;width:15px;height:15px}.sortable-column.svelte-z80lq2{cursor:pointer}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuaHRtbCIsInNvdXJjZXMiOlsiVGFibGUuaHRtbCJdLCJzb3VyY2VzQ29udGVudCI6WyJ7I2lmIHZpc2libGUgJiYgZmllbGQuZGF0YSAhPSBudWxsICYmIGZpZWxkLmRhdGEubGVuZ3RoID4gMH1cclxuXHQ8dGFibGUgY2xhc3M9XCJ0YWJsZVwiIHJlZjp0YWJsZT5cclxuXHRcdDx0aGVhZD5cclxuXHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwIH1cclxuXHRcdFx0PHRyPlxyXG5cdFx0XHRcdDx0ZCBjb2xzcGFuPVwie2NvbHVtbnNPcmRlcmVkLmxlbmd0aCArIDF9XCIgY2xhc3M9XCJidG4tcm93XCI+XHJcblx0XHRcdFx0XHR7I2VhY2ggYnVsa0FjdGlvbnMgYXMgYWN0aW9ufVxyXG5cdFx0XHRcdFx0XHR7I2lmIHNlbGVjdGVkSXRlbXNDb3VudCA+IDAgfVxyXG5cdFx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBvbjpjbGljaz1cInJ1bkJ1bGtBY3Rpb24oYWN0aW9uKVwiPnthY3Rpb24ubGFiZWx9IDxzbWFsbD4oe3NlbGVjdGVkSXRlbXNDb3VudH0pPC9zbWFsbD48L2J1dHRvbj5cclxuXHRcdFx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBkaXNhYmxlZD57YWN0aW9uLmxhYmVsfTwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdFx0ey9lYWNofVxyXG5cdFx0XHRcdDwvdGQ+XHJcblx0XHRcdDwvdHI+XHJcblx0XHRcdHsvaWZ9XHJcblx0XHRcdDx0cj5cclxuXHRcdFx0XHR7I2lmIGJ1bGtBY3Rpb25zLmxlbmd0aCA+IDB9XHJcblx0XHRcdFx0PHRoPlxyXG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiY2hlY2tib3hcIiBvbjpjaGFuZ2U9XCJzZWxlY3RBbGxJdGVtcyh0aGlzKVwiPlxyXG5cdFx0XHRcdDwvdGg+XHJcblx0XHRcdFx0ey9pZn1cclxuXHJcblx0XHRcdFx0eyNlYWNoIGNvbHVtbnNPcmRlcmVkIGFzIGNvbHVtbn1cclxuXHRcdFx0XHR7I2lmIGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzICE9IG51bGwgJiYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXNbXCJzb3J0YWJsZUJ5XCJdICE9IG51bGx9XHJcblx0XHRcdFx0XHR7I2lmIGNvbHVtbi5hc2NlbmRpbmd9XHJcblx0XHRcdFx0XHQ8dGggY2xhc3M9XCJzb3J0YWJsZS1jb2x1bW5cIiBvbjpjbGljaz1cInNvcnREYXRhKGNvbHVtbixjb2x1bW5zT3JkZXJlZClcIj57Y29sdW1uLmxhYmVsfSA8aSBjbGFzcz1cImZhIGZhLXNvcnQtZG93blwiPjwvaT48L3RoPlxyXG5cdFx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdFx0PHRoIGNsYXNzPVwic29ydGFibGUtY29sdW1uXCIgb246Y2xpY2s9XCJzb3J0RGF0YShjb2x1bW4sY29sdW1uc09yZGVyZWQpXCI+e2NvbHVtbi5sYWJlbH0gPGkgY2xhc3M9XCJmYSBmYS1zb3J0LXVwXCI+PC9pPjwvdGg+XHJcblx0XHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdHs6ZWxzZX1cclxuXHRcdFx0XHQ8dGg+XHJcblx0XHRcdFx0XHR7I2lmIGNvbHVtbi5jdXN0b21Qcm9wZXJ0aWVzICE9IG51bGwgJiYgY29sdW1uLmN1c3RvbVByb3BlcnRpZXNbXCJkb2N1bWVudGF0aW9uXCJdICE9IG51bGx9XHJcblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGVscC10b29sdGlwXCI+e2NvbHVtbi5sYWJlbH1cclxuXHRcdFx0XHRcdFx0PFRvb2x0aXAgZGF0YT1cIntjb2x1bW4uY3VzdG9tUHJvcGVydGllcy5kb2N1bWVudGF0aW9uWzBdfVwiPjwvVG9vbHRpcD5cclxuXHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0ezplbHNlfVxyXG5cdFx0XHRcdFx0e2NvbHVtbi5sYWJlbH1cclxuXHRcdFx0XHRcdHsvaWZ9XHJcblx0XHRcdFx0PC90aD5cclxuXHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdHsvZWFjaH1cclxuXHRcdFx0PC90cj5cclxuXHRcdDwvdGhlYWQ+XHJcblx0XHQ8dGJvZHk+XHJcblx0XHRcdHsjaWYgbWFwICE9IG51bGx9XHJcblx0XHRcdHsjZWFjaCBmaWVsZC5kYXRhIGFzIHJvd31cclxuXHRcdFx0PHRyIGNsYXNzPVwie2dldFJvd0Nzc0NsYXNzKHJvdyl9XCI+XHJcblx0XHRcdFx0eyNpZiBidWxrQWN0aW9ucy5sZW5ndGggPiAwfVxyXG5cdFx0XHRcdFx0PHRkPlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBmb3JtLWNoZWNrXCI+XHJcblx0XHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiY2hlY2tib3hcIiBvbjpjaGFuZ2U9XCJzZWxlY3RJdGVtKHRoaXMsIHJvdylcIj5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8L3RkPlxyXG5cdFx0XHRcdHsvaWZ9XHJcblxyXG5cdFx0XHRcdHsjZWFjaCBjb2x1bW5zT3JkZXJlZCBhcyBjb2x1bW59XHJcblx0XHRcdFx0PHRkPlxyXG5cdFx0XHRcdFx0eyNpZiAhKGdldEZpZWxkKHJvdywgY29sdW1uKS5tZXRhZGF0YS5nZXRDdXN0b21Qcm9wZXJ0eShcImhpZGVJZk51bGxcIikgPT09IHRydWUgJiYgZ2V0RmllbGQocm93LCBjb2x1bW4pLmRhdGEgPT09IG51bGwpfVxyXG5cdFx0XHRcdFx0IDxGb3JtT3V0cHV0IGZpZWxkPVwie2dldEZpZWxkKHJvdywgY29sdW1uKX1cIiBhcHA9XCJ7YXBwfVwiIGZvcm09XCJ7Zm9ybX1cIiBwYXJlbnQ9XCJ7cGFyZW50fVwiIHNob3dMYWJlbD1cImZhbHNlXCIgLz5cclxuXHRcdFx0XHQgXHR7L2lmfVxyXG5cdFx0XHRcdDwvdGQ+XHJcblx0XHRcdFx0ey9lYWNofVxyXG5cdFx0XHQ8L3RyPlxyXG5cdFx0XHR7L2VhY2h9XHJcblx0XHRcdHsvaWZ9XHJcblx0XHQ8L3Rib2R5PlxyXG5cdDwvdGFibGU+XHJcblxyXG5cdHsjaWYgYnVsa0FjdGlvbnMubGVuZ3RoID4gMH1cclxuXHRcdDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBiaW5kOmNoZWNrZWQ9XCJpc0J1bGtBY3Rpb25Nb2RhbE9wZW5cIiBjbGFzcz1cImhpZGRlblwiIC8+XHJcblx0XHQ8ZGl2IGNsYXNzPVwibW9kYWxcIj5cclxuXHRcdFx0PGRpdiBjbGFzcz1cImNhcmRcIj5cclxuXHRcdFx0XHQ8bGFiZWwgY2xhc3M9XCJjbG9zZVwiIG9uOmNsaWNrPVwiY2xvc2VCdWxrQWN0aW9uTW9kYWwobnVsbClcIj48L2xhYmVsPlxyXG5cdFx0XHRcdDxkaXYgcmVmOmJ1bGtBY3Rpb25Db250YWluZXI+PC9kaXY+XHJcblx0XHRcdDwvZGl2PlxyXG5cdFx0PC9kaXY+XHJcblx0ey9pZn1cclxuezplbHNlfVxyXG5cdDxkaXYgY2xhc3M9XCJhbGVydC1ub2RhdGFcIj5cclxuXHRcdE5vIGRhdGEuXHJcblx0PC9kaXY+XHJcbnsvaWZ9XHJcblxyXG48c2NyaXB0PlxyXG5cdGltcG9ydCBGb3JtQ29tcG9uZW50IGZyb20gXCJjb3JlLXVpL0Zvcm1cIjtcclxuXHRpbXBvcnQgRm9ybU91dHB1dCBmcm9tIFwiLi4vT3V0cHV0XCI7XHJcblx0aW1wb3J0IFRvb2x0aXAgZnJvbSBcIi4uL2hlbHAvVG9vbHRpcFwiO1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZEZpbHRlcihjdXJyZW50Rm9ybUluc3RhbmNlLCBwYXJhbWV0ZXJzKSB7XHJcblx0XHRsZXQgcHJvbWlzZTtcclxuXHJcblx0XHRjb25zdCBmaWx0ZXIgPSB7fTtcclxuXHRcdGlmIChwYXJhbWV0ZXJzICE9IG51bGwgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHByb21pc2UgPSBjdXJyZW50Rm9ybUluc3RhbmNlLmdldFNlcmlhbGl6ZWRJbnB1dFZhbHVlcygpLnRoZW4oZGF0YSA9PiB7XHJcblx0XHRcdFx0Zm9yIChjb25zdCBwIG9mIHBhcmFtZXRlcnMpIHtcclxuXHRcdFx0XHRcdGZpbHRlcltwXSA9IGRhdGFbcF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmlsdGVyO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZpbHRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb21pc2U7XHJcblx0fVxyXG5cclxuXHRjb25zdCBtb2RhbHMgPSBbXTtcclxuXHJcblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMzNjk3NDMvMTExNDM4XHJcblx0Ly8gQ2xvc2UgdG9wbW9zdCBtb2RhbCB3aGVuIHVzZXIgcHJlc3NlcyBlc2NhcGUga2V5LlxyXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGUgPT4ge1xyXG5cdFx0Y29uc3QgZXZ0ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRsZXQgaXNFc2NhcGUgPSBmYWxzZTtcclxuXHRcdGlmIChcImtleVwiIGluIGV2dCkge1xyXG5cdFx0XHRpc0VzY2FwZSA9IChldnQua2V5ID09PSBcIkVzY2FwZVwiIHx8IGV2dC5rZXkgPT09IFwiRXNjXCIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlzRXNjYXBlID0gKGV2dC5rZXlDb2RlID09PSAyNyk7XHJcblx0XHR9XHJcblx0XHRpZiAoaXNFc2NhcGUpIHtcclxuXHRcdFx0aWYgKG1vZGFscy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0Ly8gQ2xvc2UgdG9wbW9zdCBtb2RhbC5cclxuXHRcdFx0XHRtb2RhbHNbbW9kYWxzLmxlbmd0aCAtIDFdLmNsb3NlQnVsa0FjdGlvbk1vZGFsKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0ZXhwb3J0IGRlZmF1bHQge1xyXG5cdFx0b25jcmVhdGUoKSB7XHJcblx0XHRcdGNvbnN0IHsgZGF0YSB9ID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHJcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHsgbWV0YWRhdGEgfSA9IHRoaXMuZ2V0KCkuZmllbGQ7XHJcblx0XHRcdGNvbnN0IHsgcm93Q3NzQ2xhc3MgfSA9IChtZXRhZGF0YS5jdXN0b21Qcm9wZXJ0aWVzIHx8IHt9KTtcclxuXHJcblx0XHRcdC8vIENyZWF0ZSBtYXAsIHdpdGgga2V5IGJlaW5nIHRoZSBsb3dlcmNhc2UgdmVyc2lvbiBvZiB0aGUgcHJvcGVydHkgbmFtZVxyXG5cdFx0XHQvLyBhbmQgdmFsdWUgYmVpbmcgdGhlIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLlxyXG5cdFx0XHRjb25zdCBtYXAgPSB7fTtcclxuXHRcdFx0aWYgKGRhdGEubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IGZpcnN0Um93ID0gZGF0YVswXTtcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhmaXJzdFJvdykpIHtcclxuXHRcdFx0XHRcdG1hcFtwcm9wZXJ0eS50b0xvd2VyQ2FzZSgpXSA9IHByb3BlcnR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdC8vIFNob3cgdGFibGUgb25seSBhZnRlciB0aGUgYG9uY3JlYXRlYCBtZXRob2QgaGFzIHJ1bi5cclxuXHRcdFx0XHR2aXNpYmxlOiB0cnVlLFxyXG5cdFx0XHRcdGJ1bGtBY3Rpb25zOiAobWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcyB8fCB7fSkuYnVsa0FjdGlvbiB8fCBbXSxcclxuXHRcdFx0XHRtYXAsXHJcblx0XHRcdFx0Z2V0RmllbGQocm93LCBjb2x1bW4pIHtcclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gcm93W21hcFtjb2x1bW4uaWQudG9Mb3dlckNhc2UoKV1dO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHZhbHVlLFxyXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogY29sdW1uXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Z2V0Um93Q3NzQ2xhc3Mocm93KSB7XHJcblx0XHRcdFx0XHRsZXQgY3NzQ2xhc3MgPSBcIlwiO1xyXG5cclxuXHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcyAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGNzc0NsYXNzID0gcm93Q3NzQ2xhc3MuY3NzQ2xhc3MgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3dDc3NDbGFzcy5zdWZmaXggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGNzc0NsYXNzICs9IHJvd1ttYXBbcm93Q3NzQ2xhc3Muc3VmZml4LnRvTG93ZXJDYXNlKCldXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjc3NDbGFzcztcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNlbGVjdGVkSXRlbXNDb3VudDogMFxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblx0XHRjb21wdXRlZDoge1xyXG5cdFx0XHRjb2x1bW5zT3JkZXJlZDogKHsgZmllbGQgfSkgPT4gZmllbGQubWV0YWRhdGEuY3VzdG9tUHJvcGVydGllcy5jb2x1bW5zXHJcblx0XHRcdFx0LmZpbHRlcihiID0+ICFiLmhpZGRlbilcclxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4gYS5vcmRlckluZGV4IC0gYi5vcmRlckluZGV4KVxyXG5cdFx0fSxcclxuXHRcdG1ldGhvZHM6IHtcclxuXHRcdFx0YXN5bmMgcnVuQnVsa0FjdGlvbihhY3Rpb24pIHtcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcclxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZEl0ZW1zID0gdGhpcy5nZXQoKS5maWVsZC5kYXRhLmZpbHRlcih0ID0+IHQuX19zZWxlY3RlZCA9PT0gdHJ1ZSk7XHJcblx0XHRcdFx0Y29uc3QgbWFwID0gdGhpcy5nZXQoKS5tYXA7XHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJdGVtSWRzID0gc2VsZWN0ZWRJdGVtcy5tYXAodCA9PiB0W21hcFthY3Rpb24uaXRlbUlkZW50aWZpZXJGaWVsZC50b0xvd2VyQ2FzZSgpXV0pO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IHRydWVcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXBwID0gdGhpcy5nZXQoKS5hcHA7XHJcblx0XHRcdFx0Y29uc3QgZm9ybUluc3RhbmNlID0gYXBwLmdldEZvcm1JbnN0YW5jZShhY3Rpb24uZm9ybUlkLCB0cnVlKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZmlsdGVyID0gYXdhaXQgYnVpbGRGaWx0ZXIodGhpcy5nZXQoKS5mb3JtLCBhY3Rpb24ucGFyYW1ldGVycyk7XHJcblx0XHRcdFx0ZmlsdGVyLkl0ZW1zID0geyBpdGVtczogc2VsZWN0ZWRJdGVtSWRzIH07XHJcblx0XHRcdFx0Zm9ybUluc3RhbmNlLnNldElucHV0RmllbGRzKGZpbHRlcik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGYgPSBuZXcgRm9ybUNvbXBvbmVudCh7XHJcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMucmVmcy5idWxrQWN0aW9uQ29udGFpbmVyLFxyXG5cdFx0XHRcdFx0ZGF0YToge1xyXG5cdFx0XHRcdFx0XHRtZXRhZGF0YTogZm9ybUluc3RhbmNlLm1ldGFkYXRhLFxyXG5cdFx0XHRcdFx0XHRmb3JtOiBmb3JtSW5zdGFuY2UsXHJcblx0XHRcdFx0XHRcdGFwcCxcclxuXHRcdFx0XHRcdFx0dXNlVXJsOiBmYWxzZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRmLmluaXQoKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XHJcblx0XHRcdFx0Zi5vbihcImZvcm06cmVzcG9uc2VIYW5kbGVkXCIsIGUgPT4ge1xyXG5cdFx0XHRcdFx0c2VsZi5jbG9zZUJ1bGtBY3Rpb25Nb2RhbChlLnJlc3BvbnNlKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXQoe1xyXG5cdFx0XHRcdFx0Y3VycmVudEJ1bGtBY3Rpb25Gb3JtOiBmXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdG1vZGFscy5wdXNoKHRoaXMpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRhc3luYyBjbG9zZUJ1bGtBY3Rpb25Nb2RhbChyZXNwb25zZSkge1xyXG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRCdWxrQWN0aW9uRm9ybSA9IHRoaXMuZ2V0KCkuY3VycmVudEJ1bGtBY3Rpb25Gb3JtO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCh7XHJcblx0XHRcdFx0XHRpc0J1bGtBY3Rpb25Nb2RhbE9wZW46IGZhbHNlLFxyXG5cdFx0XHRcdFx0Y3VycmVudEJ1bGtBY3Rpb25Gb3JtOiBudWxsXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRCdWxrQWN0aW9uRm9ybS5kZXN0cm95KCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBhcmVudEZvcm1Db21wb25lbnQgPSB0aGlzLmdldCgpLnBhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKHJlc3BvbnNlICE9IG51bGwgJiZcclxuXHRcdFx0XHRcdHJlc3BvbnNlLm1ldGFkYXRhLmhhbmRsZXIgIT09IFwicmVkaXJlY3RcIiAmJlxyXG5cdFx0XHRcdFx0cmVzcG9uc2UubWV0YWRhdGEuaGFuZGxlciAhPT0gXCJyZWxvYWRcIikge1xyXG5cdFx0XHRcdFx0Ly8gSWYgYXNrZWQgdG8gcmVkaXJlY3QgdG8gYW5vdGhlciBmb3JtLCB0aGVuIHdlIHJlZGlyZWN0XHJcblx0XHRcdFx0XHQvLyBhbmQgZG8gbm90IHJlbG9hZCBwYXJlbnQgZm9ybSwgYXMgdGhhdCB3b3VsZCBiZSBhIHdhc3RlZCBlZmZvcnQuXHJcblx0XHRcdFx0XHRhd2FpdCBwYXJlbnRGb3JtQ29tcG9uZW50LnN1Ym1pdChudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1vZGFscy5wb3AoKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0c2VsZWN0SXRlbShjaGVja2JveEVsZW1lbnQsIHJvdykge1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRyb3cuX19zZWxlY3RlZCA9IGNoZWNrYm94RWxlbWVudC5jaGVja2VkO1xyXG5cclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcclxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZEl0ZW1zID0gdGhpcy5nZXQoKS5maWVsZC5kYXRhLmZpbHRlcih0ID0+IHQuX19zZWxlY3RlZCA9PT0gdHJ1ZSk7XHJcblx0XHRcdFx0dGhpcy5zZXQoeyBzZWxlY3RlZEl0ZW1zQ291bnQ6IHNlbGVjdGVkSXRlbXMubGVuZ3RoIH0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZWxlY3RBbGxJdGVtcyhjaGVja2JveEVsZW1lbnQpIHtcclxuXHRcdFx0XHRmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLmdldCgpLmZpZWxkLmRhdGEpIHtcclxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSwgbm8tcGFyYW0tcmVhc3NpZ25cclxuXHRcdFx0XHRcdHJvdy5fX3NlbGVjdGVkID0gY2hlY2tib3hFbGVtZW50LmNoZWNrZWQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBjaGVja2JveGVzID0gdGhpcy5yZWZzLnRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ0Ym9keT50cj50ZCAuY2hlY2tib3hcIik7XHJcblxyXG5cdFx0XHRcdGZvciAoY29uc3QgY2hlY2tib3ggb2YgY2hlY2tib3hlcykge1xyXG5cdFx0XHRcdFx0Y2hlY2tib3guY2hlY2tlZCA9IGNoZWNrYm94RWxlbWVudC5jaGVja2VkO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRJdGVtcyA9IHRoaXMuZ2V0KCkuZmllbGQuZGF0YS5maWx0ZXIodCA9PiB0Ll9fc2VsZWN0ZWQgPT09IHRydWUpO1xyXG5cdFx0XHRcdHRoaXMuc2V0KHsgc2VsZWN0ZWRJdGVtc0NvdW50OiBzZWxlY3RlZEl0ZW1zLmxlbmd0aCB9KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0c29ydERhdGEoY29sdW1uLCBjb2x1bW5zKSB7XHJcblx0XHRcdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5nZXQoKS5wYXJlbnQ7XHJcblx0XHRcdFx0Y29uc3QgZm9ybSA9IHBhcmVudC5nZXQoKS5mb3JtO1xyXG5cdFx0XHRcdGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKS5maWVsZDtcclxuXHRcdFx0XHRjb25zdCBwYWdpbmF0b3JJbnB1dCA9IGZvcm0uaW5wdXRzXHJcblx0XHRcdFx0XHQuZmluZCh0ID0+IHQubWV0YWRhdGEuaWQgPT09IGZpZWxkLm1ldGFkYXRhLmN1c3RvbVByb3BlcnRpZXMuY3VzdG9taXphdGlvbnMucGFnaW5hdG9yKTtcclxuXHJcblx0XHRcdFx0aWYgKHBhZ2luYXRvcklucHV0ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdHBhZ2luYXRvcklucHV0LnZhbHVlLm9yZGVyQnkgPSBjb2x1bW4uY3VzdG9tUHJvcGVydGllcy5zb3J0YWJsZUJ5O1xyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBpIG9mIGNvbHVtbnMpIHtcclxuXHRcdFx0XHRcdFx0aS5hc2NlbmRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRwYWdpbmF0b3JJbnB1dC52YWx1ZS5hc2NlbmRpbmcgPSAhcGFnaW5hdG9ySW5wdXQudmFsdWUuYXNjZW5kaW5nO1xyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcblx0XHRcdFx0XHRjb2x1bW4uYXNjZW5kaW5nID0gcGFnaW5hdG9ySW5wdXQudmFsdWUuYXNjZW5kaW5nO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHBhcmFtcyA9IHt9O1xyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBpIG9mIGZvcm0uaW5wdXRzKSB7XHJcblx0XHRcdFx0XHRcdHBhcmFtc1tpLm1ldGFkYXRhLmlkXSA9IGkudmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmb3JtLnNldElucHV0RmllbGRzKHBhcmFtcyk7XHJcblx0XHRcdFx0XHRwYXJlbnQuc3VibWl0KG51bGwsIGZhbHNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRjb21wb25lbnRzOiB7XHJcblx0XHRcdEZvcm1PdXRwdXQsXHJcblx0XHRcdFRvb2x0aXBcclxuXHRcdH1cclxuXHR9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQuYnRuLXJvdyB7XHJcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcclxuXHR9XHJcblxyXG5cdC5jaGVja2JveCB7XHJcblx0XHRjbGlwOiB1bnNldDtcclxuXHRcdGNsaXAtcGF0aDogdW5zZXQ7XHJcblx0XHRwb3NpdGlvbjogdW5zZXQ7XHJcblx0XHR3aWR0aDogMTVweDtcclxuXHRcdGhlaWdodDogMTVweDtcclxuXHR9XHJcblxyXG5cdC5zb3J0YWJsZS1jb2x1bW4ge1xyXG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1UQyxRQUFRLGNBQUMsQ0FBQyxBQUNULFVBQVUsQ0FBRSxLQUFLLEFBQ2xCLENBQUMsQUFFRCxTQUFTLGNBQUMsQ0FBQyxBQUNWLElBQUksQ0FBRSxLQUFLLENBQ1gsU0FBUyxDQUFFLEtBQUssQ0FDaEIsUUFBUSxDQUFFLEtBQUssQ0FDZixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2IsQ0FBQyxBQUVELGdCQUFnQixjQUFDLENBQUMsQUFDakIsTUFBTSxDQUFFLE9BQU8sQUFDaEIsQ0FBQyJ9 */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$A(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_4(ctx) {
    		if (ctx.visible && ctx.field.data != null && ctx.field.data.length > 0) return create_if_block$q;
    		return create_if_block_15$1;
    	}

    	var current_block_type = select_block_type_4(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (7:5) {#each bulkActions as action}
    function create_each_block$a(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.selectedItemsCount > 0) return create_if_block_2$d;
    		return create_if_block_3$7;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (8:6) {#if selectedItemsCount > 0 }
    function create_if_block_2$d(component, ctx) {
    	var button, text_value = ctx.action.label, text, text_1, small, text_2, text_3, text_4;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text = createText(text_value);
    			text_1 = createText(" ");
    			small = createElement("small");
    			text_2 = createText("(");
    			text_3 = createText(ctx.selectedItemsCount);
    			text_4 = createText(")");
    			addLoc(small, file$A, 8, 87, 374);

    			button._svelte = { component, ctx };

    			addListener(button, "click", click_handler$4);
    			button.className = "btn btn-default";
    			addLoc(button, file$A, 8, 7, 294);
    		},

    		m: function mount(target, anchor) {
    			insertNode(button, target, anchor);
    			appendNode(text, button);
    			appendNode(text_1, button);
    			appendNode(small, button);
    			appendNode(text_2, small);
    			appendNode(text_3, small);
    			appendNode(text_4, small);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.bulkActions) && text_value !== (text_value = ctx.action.label)) {
    				text.data = text_value;
    			}

    			if (changed.selectedItemsCount) {
    				text_3.data = ctx.selectedItemsCount;
    			}

    			button._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}

    			removeListener(button, "click", click_handler$4);
    		}
    	};
    }

    // (10:6) {:else}
    function create_if_block_3$7(component, ctx) {
    	var button, text_value = ctx.action.label, text;

    	return {
    		c: function create() {
    			button = createElement("button");
    			text = createText(text_value);
    			button.className = "btn btn-default";
    			button.disabled = true;
    			addLoc(button, file$A, 10, 7, 444);
    		},

    		m: function mount(target, anchor) {
    			insertNode(button, target, anchor);
    			appendNode(text, button);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.bulkActions) && text_value !== (text_value = ctx.action.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(button);
    			}
    		}
    	};
    }

    // (4:3) {#if bulkActions.length > 0 }
    function create_if_block_1$g(component, ctx) {
    	var tr, td, td_colspan_value;

    	var each_value = ctx.bulkActions;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(component, get_each_context$a(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			td = createElement("td");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			td.colSpan = td_colspan_value = ctx.columnsOrdered.length + 1;
    			td.className = "btn-row svelte-z80lq2";
    			addLoc(td, file$A, 5, 4, 154);
    			addLoc(tr, file$A, 4, 3, 144);
    		},

    		m: function mount(target, anchor) {
    			insertNode(tr, target, anchor);
    			appendNode(td, tr);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(td, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.selectedItemsCount || changed.bulkActions) {
    				each_value = ctx.bulkActions;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$a(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(td, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if ((changed.columnsOrdered) && td_colspan_value !== (td_colspan_value = ctx.columnsOrdered.length + 1)) {
    				td.colSpan = td_colspan_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (18:4) {#if bulkActions.length > 0}
    function create_if_block_4$5(component, ctx) {
    	var th, input;

    	function change_handler(event) {
    		component.selectAllItems(this);
    	}

    	return {
    		c: function create() {
    			th = createElement("th");
    			input = createElement("input");
    			addListener(input, "change", change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-z80lq2";
    			addLoc(input, file$A, 19, 5, 626);
    			addLoc(th, file$A, 18, 4, 615);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			appendNode(input, th);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(input, "change", change_handler);
    		}
    	};
    }

    // (24:4) {#each columnsOrdered as column}
    function create_each_block_1$4(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_3(ctx) {
    		if (ctx.column.customProperties != null && ctx.column.customProperties["sortableBy"] != null) return create_if_block_5$3;
    		return create_if_block_8$1;
    	}

    	var current_block_type = select_block_type_3(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (26:5) {#if column.ascending}
    function create_if_block_6$2(component, ctx) {
    	var th, text_value = ctx.column.label, text, text_1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text = createText(text_value);
    			text_1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-down";
    			addLoc(i, file$A, 26, 91, 975);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_1$1);
    			th.className = "sortable-column svelte-z80lq2";
    			addLoc(th, file$A, 26, 5, 889);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			appendNode(text, th);
    			appendNode(text_1, th);
    			appendNode(i, th);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_1$1);
    		}
    	};
    }

    // (28:5) {:else}
    function create_if_block_7$2(component, ctx) {
    	var th, text_value = ctx.column.label, text, text_1, i;

    	return {
    		c: function create() {
    			th = createElement("th");
    			text = createText(text_value);
    			text_1 = createText(" ");
    			i = createElement("i");
    			i.className = "fa fa-sort-up";
    			addLoc(i, file$A, 28, 91, 1118);

    			th._svelte = { component, ctx };

    			addListener(th, "click", click_handler_2$1);
    			th.className = "sortable-column svelte-z80lq2";
    			addLoc(th, file$A, 28, 5, 1032);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			appendNode(text, th);
    			appendNode(text_1, th);
    			appendNode(i, th);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}

    			th._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			removeListener(th, "click", click_handler_2$1);
    		}
    	};
    }

    // (33:5) {#if column.customProperties != null && column.customProperties["documentation"] != null}
    function create_if_block_9$1(component, ctx) {
    	var div, text_value = ctx.column.label, text, text_1;

    	var tooltip_initial_data = { data: ctx.column.customProperties.documentation[0] };
    	var tooltip = new SvelteComponent$4({
    		root: component.root,
    		store: component.store,
    		data: tooltip_initial_data
    	});

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText(text_value);
    			text_1 = createText("\r\n\t\t\t\t\t\t");
    			tooltip._fragment.c();
    			div.className = "help-tooltip";
    			addLoc(div, file$A, 33, 5, 1290);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(text, div);
    			appendNode(text_1, div);
    			tooltip._mount(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}

    			var tooltip_changes = {};
    			if (changed.columnsOrdered) tooltip_changes.data = ctx.column.customProperties.documentation[0];
    			tooltip._set(tooltip_changes);
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			tooltip.destroy();
    		}
    	};
    }

    // (37:5) {:else}
    function create_if_block_10$1(component, ctx) {
    	var text_value = ctx.column.label, text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insertNode(text, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.columnsOrdered) && text_value !== (text_value = ctx.column.label)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    // (25:4) {#if column.customProperties != null && column.customProperties["sortableBy"] != null}
    function create_if_block_5$3(component, ctx) {
    	var if_block_anchor;

    	function select_block_type_1(ctx) {
    		if (ctx.column.ascending) return create_if_block_6$2;
    		return create_if_block_7$2;
    	}

    	var current_block_type = select_block_type_1(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (31:4) {:else}
    function create_if_block_8$1(component, ctx) {
    	var th;

    	function select_block_type_2(ctx) {
    		if (ctx.column.customProperties != null && ctx.column.customProperties["documentation"] != null) return create_if_block_9$1;
    		return create_if_block_10$1;
    	}

    	var current_block_type = select_block_type_2(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function create() {
    			th = createElement("th");
    			if_block.c();
    			addLoc(th, file$A, 31, 4, 1183);
    		},

    		m: function mount(target, anchor) {
    			insertNode(th, target, anchor);
    			if_block.m(th, null);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(th, null);
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(th);
    			}

    			if_block.d();
    		}
    	};
    }

    // (47:3) {#each field.data as row}
    function create_each_block_2$2(component, ctx) {
    	var tr, text, tr_class_value;

    	var if_block = (ctx.bulkActions.length > 0) && create_if_block_12$1(component, ctx);

    	var each_value_3 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$1(component, get_each_context_3$1(ctx, each_value_3, i));
    	}

    	return {
    		c: function create() {
    			tr = createElement("tr");
    			if (if_block) if_block.c();
    			text = createText("\r\n\r\n\t\t\t\t");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			tr.className = tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-z80lq2";
    			addLoc(tr, file$A, 47, 3, 1592);
    		},

    		m: function mount(target, anchor) {
    			insertNode(tr, target, anchor);
    			if (if_block) if_block.m(tr, null);
    			appendNode(text, tr);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_12$1(component, ctx);
    					if_block.c();
    					if_block.m(tr, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.getField || changed.field || changed.columnsOrdered || changed.app || changed.form || changed.parent) {
    				each_value_3 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_3$1(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_3.length;
    			}

    			if ((changed.getRowCssClass || changed.field) && tr_class_value !== (tr_class_value = "" + ctx.getRowCssClass(ctx.row) + " svelte-z80lq2")) {
    				tr.className = tr_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(tr);
    			}

    			if (if_block) if_block.d();

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (49:4) {#if bulkActions.length > 0}
    function create_if_block_12$1(component, ctx) {
    	var td, div, input;

    	return {
    		c: function create() {
    			td = createElement("td");
    			div = createElement("div");
    			input = createElement("input");
    			input._svelte = { component, ctx };

    			addListener(input, "change", change_handler$1);
    			setAttribute(input, "type", "checkbox");
    			input.className = "checkbox svelte-z80lq2";
    			addLoc(input, file$A, 51, 7, 1723);
    			div.className = "form-group form-check";
    			addLoc(div, file$A, 50, 6, 1679);
    			addLoc(td, file$A, 49, 5, 1667);
    		},

    		m: function mount(target, anchor) {
    			insertNode(td, target, anchor);
    			appendNode(div, td);
    			appendNode(input, div);
    		},

    		p: function update(changed, ctx) {
    			input._svelte.ctx = ctx;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			removeListener(input, "change", change_handler$1);
    		}
    	};
    }

    // (57:4) {#each columnsOrdered as column}
    function create_each_block_3$1(component, ctx) {
    	var td;

    	var if_block = (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull") === true && ctx.getField(ctx.row, ctx.column).data === null)) && create_if_block_13$1(component, ctx);

    	return {
    		c: function create() {
    			td = createElement("td");
    			if (if_block) if_block.c();
    			addLoc(td, file$A, 57, 4, 1880);
    		},

    		m: function mount(target, anchor) {
    			insertNode(td, target, anchor);
    			if (if_block) if_block.m(td, null);
    		},

    		p: function update(changed, ctx) {
    			if (!(ctx.getField(ctx.row, ctx.column).metadata.getCustomProperty("hideIfNull") === true && ctx.getField(ctx.row, ctx.column).data === null)) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_13$1(component, ctx);
    					if_block.c();
    					if_block.m(td, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(td);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    // (59:5) {#if !(getField(row, column).metadata.getCustomProperty("hideIfNull") === true && getField(row, column).data === null)}
    function create_if_block_13$1(component, ctx) {

    	var formoutput_initial_data = {
    	 	field: ctx.getField(ctx.row, ctx.column),
    	 	app: ctx.app,
    	 	form: ctx.form,
    	 	parent: ctx.parent,
    	 	showLabel: "false"
    	 };
    	var formoutput = new SvelteComponent$6({
    		root: component.root,
    		store: component.store,
    		data: formoutput_initial_data
    	});

    	return {
    		c: function create() {
    			formoutput._fragment.c();
    		},

    		m: function mount(target, anchor) {
    			formoutput._mount(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			var formoutput_changes = {};
    			if (changed.getField || changed.field || changed.columnsOrdered) formoutput_changes.field = ctx.getField(ctx.row, ctx.column);
    			if (changed.app) formoutput_changes.app = ctx.app;
    			if (changed.form) formoutput_changes.form = ctx.form;
    			if (changed.parent) formoutput_changes.parent = ctx.parent;
    			formoutput._set(formoutput_changes);
    		},

    		d: function destroy$$1(detach) {
    			formoutput.destroy(detach);
    		}
    	};
    }

    // (46:3) {#if map != null}
    function create_if_block_11$1(component, ctx) {
    	var each_anchor;

    	var each_value_2 = ctx.field.data;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(component, get_each_context_2$2(ctx, each_value_2, i));
    	}

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insertNode(each_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.getRowCssClass || changed.field || changed.bulkActions || changed.columnsOrdered || changed.getField || changed.app || changed.form || changed.parent) {
    				each_value_2 = ctx.field.data;

    				for (var i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_2$2(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_anchor.parentNode, each_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_2.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			destroyEach(each_blocks, detach);

    			if (detach) {
    				detachNode(each_anchor);
    			}
    		}
    	};
    }

    // (70:1) {#if bulkActions.length > 0}
    function create_if_block_14$1(component, ctx) {
    	var input, text, div, div_1, label, text_1, div_2;

    	function input_change_handler() {
    		component.set({ isBulkActionModalOpen: input.checked });
    	}

    	function click_handler_3(event) {
    		component.closeBulkActionModal(null);
    	}

    	return {
    		c: function create() {
    			input = createElement("input");
    			text = createText("\r\n\t\t");
    			div = createElement("div");
    			div_1 = createElement("div");
    			label = createElement("label");
    			text_1 = createText("\r\n\t\t\t\t");
    			div_2 = createElement("div");
    			addListener(input, "change", input_change_handler);
    			setAttribute(input, "type", "checkbox");
    			input.className = "hidden";
    			addLoc(input, file$A, 70, 2, 2255);
    			addListener(label, "click", click_handler_3);
    			label.className = "close";
    			addLoc(label, file$A, 73, 4, 2384);
    			addLoc(div_2, file$A, 74, 4, 2457);
    			div_1.className = "card";
    			addLoc(div_1, file$A, 72, 3, 2360);
    			div.className = "modal";
    			addLoc(div, file$A, 71, 2, 2336);
    		},

    		m: function mount(target, anchor) {
    			insertNode(input, target, anchor);

    			input.checked = ctx.isBulkActionModalOpen;

    			insertNode(text, target, anchor);
    			insertNode(div, target, anchor);
    			appendNode(div_1, div);
    			appendNode(label, div_1);
    			appendNode(text_1, div_1);
    			appendNode(div_2, div_1);
    			component.refs.bulkActionContainer = div_2;
    		},

    		p: function update(changed, ctx) {
    			input.checked = ctx.isBulkActionModalOpen;
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(input);
    			}

    			removeListener(input, "change", input_change_handler);
    			if (detach) {
    				detachNode(text);
    				detachNode(div);
    			}

    			removeListener(label, "click", click_handler_3);
    			if (component.refs.bulkActionContainer === div_2) component.refs.bulkActionContainer = null;
    		}
    	};
    }

    // (1:0) {#if visible && field.data != null && field.data.length > 0}
    function create_if_block$q(component, ctx) {
    	var table, thead, text, tr, text_1, text_4, tbody, text_7, if_block_3_anchor;

    	var if_block = (ctx.bulkActions.length > 0) && create_if_block_1$g(component, ctx);

    	var if_block_1 = (ctx.bulkActions.length > 0) && create_if_block_4$5(component, ctx);

    	var each_value_1 = ctx.columnsOrdered;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(component, get_each_context_1$4(ctx, each_value_1, i));
    	}

    	var if_block_2 = (ctx.map != null) && create_if_block_11$1(component, ctx);

    	var if_block_3 = (ctx.bulkActions.length > 0) && create_if_block_14$1(component, ctx);

    	return {
    		c: function create() {
    			table = createElement("table");
    			thead = createElement("thead");
    			if (if_block) if_block.c();
    			text = createText("\r\n\t\t\t");
    			tr = createElement("tr");
    			if (if_block_1) if_block_1.c();
    			text_1 = createText("\r\n\r\n\t\t\t\t");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			text_4 = createText("\r\n\t\t");
    			tbody = createElement("tbody");
    			if (if_block_2) if_block_2.c();
    			text_7 = createText("\r\n\r\n\t");
    			if (if_block_3) if_block_3.c();
    			if_block_3_anchor = createComment();
    			addLoc(tr, file$A, 16, 3, 571);
    			addLoc(thead, file$A, 2, 2, 98);
    			addLoc(tbody, file$A, 44, 2, 1528);
    			table.className = "table";
    			addLoc(table, file$A, 1, 1, 63);
    		},

    		m: function mount(target, anchor) {
    			insertNode(table, target, anchor);
    			appendNode(thead, table);
    			if (if_block) if_block.m(thead, null);
    			appendNode(text, thead);
    			appendNode(tr, thead);
    			if (if_block_1) if_block_1.m(tr, null);
    			appendNode(text_1, tr);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			appendNode(text_4, table);
    			appendNode(tbody, table);
    			if (if_block_2) if_block_2.m(tbody, null);
    			component.refs.table = table;
    			insertNode(text_7, target, anchor);
    			if (if_block_3) if_block_3.m(target, anchor);
    			insertNode(if_block_3_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.bulkActions.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$g(component, ctx);
    					if_block.c();
    					if_block.m(thead, text);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (!if_block_1) {
    					if_block_1 = create_if_block_4$5(component, ctx);
    					if_block_1.c();
    					if_block_1.m(tr, text_1);
    				}
    			} else if (if_block_1) {
    				if_block_1.d(1);
    				if_block_1 = null;
    			}

    			if (changed.columnsOrdered) {
    				each_value_1 = ctx.columnsOrdered;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1$4(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (ctx.map != null) {
    				if (if_block_2) {
    					if_block_2.p(changed, ctx);
    				} else {
    					if_block_2 = create_if_block_11$1(component, ctx);
    					if_block_2.c();
    					if_block_2.m(tbody, null);
    				}
    			} else if (if_block_2) {
    				if_block_2.d(1);
    				if_block_2 = null;
    			}

    			if (ctx.bulkActions.length > 0) {
    				if (if_block_3) {
    					if_block_3.p(changed, ctx);
    				} else {
    					if_block_3 = create_if_block_14$1(component, ctx);
    					if_block_3.c();
    					if_block_3.m(if_block_3_anchor.parentNode, if_block_3_anchor);
    				}
    			} else if (if_block_3) {
    				if_block_3.d(1);
    				if_block_3 = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(table);
    			}

    			if (if_block) if_block.d();
    			if (if_block_1) if_block_1.d();

    			destroyEach(each_blocks, detach);

    			if (if_block_2) if_block_2.d();
    			if (component.refs.table === table) component.refs.table = null;
    			if (detach) {
    				detachNode(text_7);
    			}

    			if (if_block_3) if_block_3.d(detach);
    			if (detach) {
    				detachNode(if_block_3_anchor);
    			}
    		}
    	};
    }

    // (79:0) {:else}
    function create_if_block_15$1(component, ctx) {
    	var div, text;

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText("No data.");
    			div.className = "alert-nodata";
    			addLoc(div, file$A, 79, 1, 2533);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(text, div);
    		},

    		p: noop,

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.action = list[i];
    	child_ctx.each_value = list;
    	child_ctx.action_index = i;
    	return child_ctx;
    }

    function click_handler$4(event) {
    	const { component, ctx } = this._svelte;

    	component.runBulkAction(ctx.action);
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	child_ctx.each_value_1 = list;
    	child_ctx.column_index = i;
    	return child_ctx;
    }

    function click_handler_1$1(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function click_handler_2$1(event) {
    	const { component, ctx } = this._svelte;

    	component.sortData(ctx.column,ctx.columnsOrdered);
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.row = list[i];
    	child_ctx.each_value_2 = list;
    	child_ctx.row_index = i;
    	return child_ctx;
    }

    function change_handler$1(event) {
    	const { component, ctx } = this._svelte;

    	component.selectItem(this, ctx.row);
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.column = list[i];
    	child_ctx.each_value_3 = list;
    	child_ctx.column_index_1 = i;
    	return child_ctx;
    }

    function SvelteComponent$A(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this.refs = {};
    	this._state = assign({}, options.data);
    	this._recompute({ field: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('visible' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'visible'");
    	if (!('bulkActions' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'bulkActions'");

    	if (!('selectedItemsCount' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'selectedItemsCount'");
    	if (!('map' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'map'");
    	if (!('getRowCssClass' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getRowCssClass'");
    	if (!('getField' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'getField'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	if (!('parent' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'parent'");
    	if (!('isBulkActionModalOpen' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'isBulkActionModalOpen'");
    	this._intro = true;

    	if (!document.getElementById("svelte-z80lq2-style")) add_css$h();

    	if (!options.root) {
    		this._oncreate = [];
    		this._beforecreate = [];
    		this._aftercreate = [];
    	}

    	this._fragment = create_main_fragment$A(this, this._state);

    	this.root._oncreate.push(() => {
    		oncreate$k.call(this);
    		this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
    	});

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);

    		this._lock = true;
    		callAll(this._beforecreate);
    		callAll(this._oncreate);
    		callAll(this._aftercreate);
    		this._lock = false;
    	}
    }

    assign(SvelteComponent$A.prototype, protoDev);
    assign(SvelteComponent$A.prototype, methods$a);

    SvelteComponent$A.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('columnsOrdered' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'columnsOrdered'");
    };

    SvelteComponent$A.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field) {
    		if (this._differs(state.columnsOrdered, (state.columnsOrdered = columnsOrdered$1(state)))) changed.columnsOrdered = true;
    	}
    };

    /* src\core\ui\outputs\Tabstrip.html generated by Svelte v2.9.5 */

    function getCssClass(tab, tabstrip) {
    	return tab.form === tabstrip.currentTab ?
    		"active" :
    		"";
    }
    const file$B = "src\\core\\ui\\outputs\\Tabstrip.html";

    function create_main_fragment$B(component, ctx) {
    	var div;

    	var each_value = ctx.field.data.tabs;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(component, get_each_context$b(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			div = createElement("div");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			div.className = "tabstrip";
    			addLoc(div, file$B, 0, 0, 0);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if (changed.app || changed.field) {
    				each_value = ctx.field.data.tabs;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$b(component, child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}

    			destroyEach(each_blocks, detach);
    		}
    	};
    }

    // (2:1) {#each field.data.tabs as tab}
    function create_each_block$b(component, ctx) {
    	var div, a, text_value = ctx.tab.label, text, a_href_value, a_class_value;

    	return {
    		c: function create() {
    			div = createElement("div");
    			a = createElement("a");
    			text = createText(text_value);
    			a.href = a_href_value = ctx.app.makeUrl(ctx.tab.form, ctx.tab.inputFieldValues);
    			a.className = a_class_value = getCssClass(ctx.tab, ctx.field.data);
    			addLoc(a, file$B, 3, 2, 67);
    			addLoc(div, file$B, 2, 1, 58);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(a, div);
    			appendNode(text, a);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.tab.label)) {
    				text.data = text_value;
    			}

    			if ((changed.app || changed.field) && a_href_value !== (a_href_value = ctx.app.makeUrl(ctx.tab.form, ctx.tab.inputFieldValues))) {
    				a.href = a_href_value;
    			}

    			if ((changed.field) && a_class_value !== (a_class_value = getCssClass(ctx.tab, ctx.field.data))) {
    				a.className = a_class_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tab = list[i];
    	child_ctx.each_value = list;
    	child_ctx.tab_index = i;
    	return child_ctx;
    }

    function SvelteComponent$B(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('app' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'app'");
    	this._intro = true;

    	this._fragment = create_main_fragment$B(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$B.prototype, protoDev);

    SvelteComponent$B.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\Text.html generated by Svelte v2.9.5 */

    function cssClass({ field, form }) {
    	let cssClass = "";
    	const dynamicCssClass = field.metadata.getCustomProperty("dynamicCssClass");
    	if (dynamicCssClass != null) {
    		cssClass = dynamicCssClass.cssClassPrefix;
    		if (dynamicCssClass.outputFieldAsSuffix != null) {
    			const suffixOutputField = form.outputs
    				.find(t => t.metadata.id === dynamicCssClass.outputFieldAsSuffix);

    			cssClass += suffixOutputField.data;
    		}
    	}
    	return cssClass;
    }

    function BooleanChecker({ field }) {
    	if (typeof (field.data) === "boolean") {
    		return field.data ? "Yes" : "No";
    	}

    	return field.data;
    }

    const file$C = "src\\core\\ui\\outputs\\Text.html";

    function create_main_fragment$C(component, ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.field.data != null) && create_if_block$r(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.field.data != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$r(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if field.data != null }
    function create_if_block$r(component, ctx) {
    	var span, text;

    	return {
    		c: function create() {
    			span = createElement("span");
    			text = createText(ctx.BooleanChecker);
    			span.className = ctx.cssClass;
    			addLoc(span, file$C, 1, 0, 27);
    		},

    		m: function mount(target, anchor) {
    			insertNode(span, target, anchor);
    			appendNode(text, span);
    		},

    		p: function update(changed, ctx) {
    			if (changed.BooleanChecker) {
    				text.data = ctx.BooleanChecker;
    			}

    			if (changed.cssClass) {
    				span.className = ctx.cssClass;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(span);
    			}
    		}
    	};
    }

    function SvelteComponent$C(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	this._recompute({ field: 1, form: 1 }, this._state);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	if (!('form' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'form'");
    	this._intro = true;

    	this._fragment = create_main_fragment$C(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$C.prototype, protoDev);

    SvelteComponent$C.prototype._checkReadOnly = function _checkReadOnly(newState) {
    	if ('cssClass' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'cssClass'");
    	if ('BooleanChecker' in newState && !this._updatingReadonlyProperty) throw new Error("<SvelteComponent>: Cannot set read-only property 'BooleanChecker'");
    };

    SvelteComponent$C.prototype._recompute = function _recompute(changed, state) {
    	if (changed.field || changed.form) {
    		if (this._differs(state.cssClass, (state.cssClass = cssClass(state)))) changed.cssClass = true;
    	}

    	if (changed.field) {
    		if (this._differs(state.BooleanChecker, (state.BooleanChecker = BooleanChecker(state)))) changed.BooleanChecker = true;
    	}
    };

    /* src\core\ui\outputs\TextValue.html generated by Svelte v2.9.5 */

    function create_main_fragment$D(component, ctx) {
    	var text_value = ctx.field.data.value, text;

    	return {
    		c: function create() {
    			text = createText(text_value);
    		},

    		m: function mount(target, anchor) {
    			insertNode(text, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.value)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(text);
    			}
    		}
    	};
    }

    function SvelteComponent$D(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	this._fragment = create_main_fragment$D(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$D.prototype, protoDev);

    SvelteComponent$D.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    /* src\core\ui\outputs\TextValueMultiline.html generated by Svelte v2.9.5 */

    const file$E = "src\\core\\ui\\outputs\\TextValueMultiline.html";

    function add_css$i() {
    	var style = createElement("style");
    	style.id = 'svelte-1gkz7pl-style';
    	style.textContent = "div.svelte-1gkz7pl{white-space:pre;margin:0 0 5px 0;padding:5px 15px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dFZhbHVlTXVsdGlsaW5lLmh0bWwiLCJzb3VyY2VzIjpbIlRleHRWYWx1ZU11bHRpbGluZS5odG1sIl0sInNvdXJjZXNDb250ZW50IjpbInsjaWYgKGZpZWxkLmRhdGEgfHwge30pLnZhbHVlICE9IG51bGx9XHJcbjxkaXY+e2ZpZWxkLmRhdGEudmFsdWV9PC9kaXY+XHJcbnsvaWZ9XHJcblxyXG48c3R5bGU+XHJcblx0ZGl2IHtcclxuXHRcdHdoaXRlLXNwYWNlOiBwcmU7XHJcblx0XHRtYXJnaW46IDAgMCA1cHggMDtcclxuXHRcdHBhZGRpbmc6IDVweCAxNXB4O1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtDLEdBQUcsZUFBQyxDQUFDLEFBQ0osV0FBVyxDQUFFLEdBQUcsQ0FDaEIsTUFBTSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDakIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxJQUFJLEFBQ2xCLENBQUMifQ== */";
    	appendNode(style, document.head);
    }

    function create_main_fragment$E(component, ctx) {
    	var if_block_anchor;

    	var if_block = ((ctx.field.data || {}).value != null) && create_if_block$s(component, ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = createComment();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((ctx.field.data || {}).value != null) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$s(component, ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (if_block) if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if (field.data || {}).value != null}
    function create_if_block$s(component, ctx) {
    	var div, text_value = ctx.field.data.value, text;

    	return {
    		c: function create() {
    			div = createElement("div");
    			text = createText(text_value);
    			div.className = "svelte-1gkz7pl";
    			addLoc(div, file$E, 1, 0, 40);
    		},

    		m: function mount(target, anchor) {
    			insertNode(div, target, anchor);
    			appendNode(text, div);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.field) && text_value !== (text_value = ctx.field.data.value)) {
    				text.data = text_value;
    			}
    		},

    		d: function destroy$$1(detach) {
    			if (detach) {
    				detachNode(div);
    			}
    		}
    	};
    }

    function SvelteComponent$E(options) {
    	this._debugName = '<SvelteComponent>';
    	if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
    	init(this, options);
    	this._state = assign({}, options.data);
    	if (!('field' in this._state)) console.warn("<SvelteComponent> was created without expected data property 'field'");
    	this._intro = true;

    	if (!document.getElementById("svelte-1gkz7pl-style")) add_css$i();

    	this._fragment = create_main_fragment$E(this, this._state);

    	if (options.target) {
    		if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign(SvelteComponent$E.prototype, protoDev);

    SvelteComponent$E.prototype._checkReadOnly = function _checkReadOnly(newState) {
    };

    var FormLogToConsole = /** @class */ (function (_super) {
        __extends(FormLogToConsole, _super);
        function FormLogToConsole() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormLogToConsole.prototype.run = function (form, eventHandlerMetadata, args) {
            // tslint:disable-next-line:no-console
            console.log("[" + eventHandlerMetadata.runAt + "] form event handler '" + eventHandlerMetadata.id + "' from '" + form.metadata.id + "'");
            return Promise.resolve();
        };
        return FormLogToConsole;
    }(FormEventHandler));

    /**
     * Reloads form after an action.
     */
    var ReloadFormAfterAction = /** @class */ (function (_super) {
        __extends(ReloadFormAfterAction, _super);
        function ReloadFormAfterAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReloadFormAfterAction.prototype.run = function (form, eventHandlerMetadata, args) {
            var isTopLevelForm = args.form.get("parent") == null;
            if (isTopLevelForm && eventHandlerMetadata.customProperties.formId === args.actionFormId) {
                args.form.submit(args.app, form, null, false);
            }
            return Promise.resolve();
        };
        return ReloadFormAfterAction;
    }(FormEventHandler));

    var BindToOutput = /** @class */ (function (_super) {
        __extends(BindToOutput, _super);
        function BindToOutput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BindToOutput.prototype.run = function (input, eventHandler, args) {
            var promises = [];
            var lowercaseInputId = eventHandler.customProperties.outputFieldId.toLowerCase();
            for (var prop in args.response) {
                if (args.response.hasOwnProperty(prop) && prop.toLowerCase() === lowercaseInputId) {
                    var serializedValue = input.serializeValue(args.response[prop]);
                    var promise = input.init(serializedValue);
                    promises.push(promise);
                    break;
                }
            }
            return Promise.all(promises);
        };
        return BindToOutput;
    }(InputFieldEventHandler));

    var InputLogToConsole = /** @class */ (function (_super) {
        __extends(InputLogToConsole, _super);
        function InputLogToConsole() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InputLogToConsole.prototype.run = function (input, eventHandlerMetadata, args) {
            return input.serialize().then(function (t) {
                // tslint:disable-next-line:no-console
                console.log("[" + eventHandlerMetadata.runAt + "] input event handler '" + eventHandlerMetadata.id + "' from '" + input.metadata.id + "'");
            });
        };
        return InputLogToConsole;
    }(InputFieldEventHandler));

    var DependOn = /** @class */ (function (_super) {
        __extends(DependOn, _super);
        function DependOn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DependOn.prototype.run = function (input, eventHandlerMetadata, args) {
            var subscribedToField = eventHandlerMetadata.customProperties.field;
            var fieldChanged = args.input.get("field").metadata.id;
            if (subscribedToField === fieldChanged) {
                return input.serialize().then(function (t) {
                    var parentInputController = args.input.get("field");
                    var childWrapper = args.form.getInputComponent(input.metadata.id);
                    var childShouldBeVisible = ["typeahead", "dropdown"].indexOf(parentInputController.metadata.type) !== -1
                        ? parentInputController.value != null && parentInputController.value.value != null
                        : parentInputController.value != null;
                    childWrapper.show(childShouldBeVisible);
                });
            }
            return Promise.resolve();
        };
        return DependOn;
    }(InputFieldEventHandler));

    var OutputLogToConsole = /** @class */ (function (_super) {
        __extends(OutputLogToConsole, _super);
        function OutputLogToConsole() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OutputLogToConsole.prototype.run = function (output, eventHandlerMetadata, args) {
            // tslint:disable-next-line:no-console
            console.log("[" + eventHandlerMetadata.runAt + "] output event handler '" + eventHandlerMetadata.id + "' from '" + output.metadata.id + "'");
            return Promise.resolve();
        };
        return OutputLogToConsole;
    }(OutputFieldEventHandler));

    var alertify$2 = alertify;
    var Growl = /** @class */ (function () {
        function Growl() {
        }
        Growl.prototype.run = function (metadata) {
            alertify$2.notify(metadata.customProperties.message, metadata.customProperties.style, 5);
            return Promise.resolve();
        };
        return Growl;
    }());

    var controlRegister = new ControlRegister();
    controlRegister.registerInputFieldControl("text", SvelteComponent$j, StringInputController);
    controlRegister.registerInputFieldControl("email", SvelteComponent$d, EmailInputController);
    controlRegister.registerInputFieldControl("datetime", SvelteComponent$a, DateInputController);
    controlRegister.registerInputFieldControl("date-range", SvelteComponent$b, DateRangeInputController);
    controlRegister.registerInputFieldControl("number", SvelteComponent$g, NumberInputController);
    controlRegister.registerInputFieldControl("dropdown", SvelteComponent$c, DropdownInputController);
    controlRegister.registerInputFieldControl("boolean", SvelteComponent$9, BooleanInputController);
    controlRegister.registerInputFieldControl("paginator", null, PaginatorInputController);
    controlRegister.registerInputFieldControl("typeahead", SvelteComponent$f, TypeaheadInputController);
    controlRegister.registerInputFieldControl("my-typeahead", SvelteComponent$f, TypeaheadInputController);
    controlRegister.registerInputFieldControl("multiselect", SvelteComponent$f, MultiSelectInputController);
    controlRegister.registerInputFieldControl("password", SvelteComponent$i, PasswordInputController);
    controlRegister.registerInputFieldControl("textarea", SvelteComponent$k, TextareaInputController, new OutputControlConfiguration(false, true));
    controlRegister.registerInputFieldControl("file-uploader", SvelteComponent$e, FileUploaderController, new OutputControlConfiguration(true, true));
    controlRegister.registerInputFieldControl("number-range", SvelteComponent$h, NumberRangeInputController);
    controlRegister.registerOutputFieldControl("text", SvelteComponent$C);
    controlRegister.registerOutputFieldControl("number", SvelteComponent$w);
    controlRegister.registerOutputFieldControl("datetime", SvelteComponent$n);
    controlRegister.registerOutputFieldControl("table", SvelteComponent$A, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("formlink", SvelteComponent$r);
    controlRegister.registerOutputFieldControl("tabstrip", SvelteComponent$B, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("paginated-data", SvelteComponent$z, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("action-list", SvelteComponent$l, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("inline-form", SvelteComponent$u, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("text-value", SvelteComponent$D);
    controlRegister.registerOutputFieldControl("text-value-multiline", SvelteComponent$E, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("downloadable-file", SvelteComponent$p);
    controlRegister.registerOutputFieldControl("alert", SvelteComponent$m, new OutputControlConfiguration(true, true));
    controlRegister.registerOutputFieldControl("file-size", SvelteComponent$q);
    controlRegister.registerOutputFieldControl("image", SvelteComponent$t, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("link", SvelteComponent$v);
    controlRegister.registerOutputFieldControl("object-list", SvelteComponent$x, new OutputControlConfiguration(false, true));
    controlRegister.registerOutputFieldControl("html-string", SvelteComponent$s);
    controlRegister.registerOutputFieldControl("documentation", SvelteComponent$o, new OutputControlConfiguration(true, true));
    // Form event handlers.
    controlRegister.registerFormEventHandler("log-to-console", new FormLogToConsole());
    controlRegister.registerFormEventHandler("reload-form-after-action", new ReloadFormAfterAction());
    // Input event handlers.
    controlRegister.registerInputFieldEventHandler("bind-to-output", new BindToOutput());
    controlRegister.registerInputFieldEventHandler("log-to-console", new InputLogToConsole());
    controlRegister.registerInputFieldEventHandler("depend-on", new DependOn());
    // Output event handlers.
    controlRegister.registerOutputFieldEventHandler("log-to-console", new OutputLogToConsole());
    // Functions.
    controlRegister.registerFunction("growl", new Growl());

    var alertify$3 = alertify;
    alertify$3.defaults = {
        closable: false,
        notifier: {
            delay: 0,
            position: "bottom-right",
            closeButton: true
        },
        glossary: {
            title: "AlertifyJS",
            ok: "Yes",
            cancel: "No"
        },
        // theme settings
        theme: {
            // class name attached to prompt dialog input textbox.
            input: "ajs-input",
            // class name attached to ok button
            ok: "ajs-ok",
            // class name attached to cancel button
            cancel: "ajs-cancel"
        }
    };
    var alertifyErrorMsg = [];
    var MyApp = /** @class */ (function (_super) {
        __extends(MyApp, _super);
        function MyApp(theServer) {
            return _super.call(this, theServer, controlRegister) || this;
        }
        MyApp.prototype.showError = function (message) {
            var msg = alertify$3.error(message);
            alertifyErrorMsg.push(msg);
        };
        return MyApp;
    }(UmfApp));
    var server = new UmfServer("/api/form/metadata", "/api/form/run");
    var app = new MyApp(server);
    // Create a global variable, which can be accessed from any component.
    window.app = app;
    app.on("request:started", function (request) {
        showLoader();
    });
    app.on("request:completed", function (error) {
        if (error != null) {
            app.showError(error);
        }
        hideLoader();
    });
    app.load().then(function (response) {
        var router = new AppRouter(document.getElementById("main"), app);
        app.useRouter(router);
        router.on("router:activated", function () {
            for (var _i = 0, alertifyErrorMsg_1 = alertifyErrorMsg; _i < alertifyErrorMsg_1.length; _i++) {
                var msg = alertifyErrorMsg_1[_i];
                msg.dismiss();
            }
        });
        app.registerResponseHandler(new FormComponentResponseHandler());
        app.registerResponseHandler(new MessageResponseHandler());
        app.registerResponseHandler(new ReloadResponseHandler(function (form, inputFieldValues) {
            return app.load().then(function (t) {
                buildMenu(app);
                return app.makeUrl(form, inputFieldValues);
            });
        }));
        app.registerResponseHandler(new RedirectResponseHandler(function (form, inputFieldValues) {
            app.go(form, inputFieldValues);
        }));
        buildMenu(app);
    });
    function buildMenu(theApp) {
        // Remove old menu.
        var myNode = document.getElementById("topmenu");
        while (myNode.firstChild) {
            myNode.removeChild(myNode.firstChild);
        }
        // tslint:disable-next-line:no-unused-expression
        new SvelteComponent$2({
            target: document.getElementById("topmenu"),
            data: {
                forms: theApp.forms,
                menu: theApp.menu,
                theApp: theApp,
                makeUrl: function (formId, inputFieldValues) { return theApp.makeUrl(formId, inputFieldValues); }
            }
        });
    }
    function showLoader() {
        var progress = document.getElementById("progress");
        progress.setAttribute("style", "width:50%");
        var loader = document.getElementById("loader");
        loader.setAttribute("class", "");
    }
    function hideLoader() {
        var loader = document.getElementById("loader");
        var progress = document.getElementById("progress");
        progress.setAttribute("style", "width:100%");
        setTimeout(function () {
            loader.setAttribute("class", "d-none");
        }, 500);
    }

}());
