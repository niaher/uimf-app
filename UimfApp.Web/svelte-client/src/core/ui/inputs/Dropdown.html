{{#if options != null }}
<select
	id="{{id}}"
	bind:value="field.selected"
	required="{{field.metadata.required}}"
	tabindex="{{tabindex}}"
	on:change="onChange()"
	class="form-control">
	<option value=""></option>
	{{#each options as option}}
	<option value="{{option.value}}">{{option.label}}</option>
	{{/each}}
</select>
{{/if}}

<script>
	function mapToTypeaheadItems(items) {
		return items.map(t => ({
			label: t.label,
			value: t.value.toString()
		}));
	}

	function buildFilter(parentForm, parameters) {
		let promise;

		const filter = {};
		if (parameters != null && parameters.length > 0) {
			promise = parentForm.get("form").getSerializedInputValues().then(data => {
				for (const p of parameters) {
					filter[p] = data[p];
				}

				return filter;
			});
		}
		else {
			promise = Promise.resolve(filter);
		}

		return promise;
	}

	export default {
		oncreate() {
			const field = this.get("field");
			const { source, items } = field.metadata.customProperties;

			if (items != null) {
				this.set({ options: items });
			}
			else if (typeof (source) === "string") {
				const { parameters } = field.metadata.customProperties;
				const app = this.get("app");
				const parentForm = this.get("form");

				buildFilter(parentForm, parameters).then(filter => {
					app.server.postForm(source, filter).then(data => {
						this.set({ options: mapToTypeaheadItems(data.items) });
					});
				});
			}
		},
		methods: {
			onChange() {
				this.get("field").initFromSelected();
				this.get("form").fireAndBubbleUp("input:changed", {
					app: this.get("app"),
					form: this.get("form"),
					input: this
				});
			}
		}
	};
</script>
